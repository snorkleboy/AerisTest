"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _DOM = _interopRequireDefault(require("../../display/DOM"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `ImageAnimation` object is a subclass of `Animation` that is responsible for managing a
 * series of images required for animation playback.
 */
var ImageAnimation =
/** @class */
function (_super) {
  __extends(ImageAnimation, _super);
  /**
   * Initializes a new animation instance with the provided DOM target and configuration.
   *
   * @param {HTMLElement} target
   * @param {ImageAnimationOptions} [opts=null]
   * @memberof ImageAnimation
   */


  function ImageAnimation(target, opts) {
    if (opts === void 0) {
      opts = undefined;
    }

    var _this = this;

    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenStopped: true,
      showWhenLoading: true
    }, opts);
    _this = _super.call(this, opts) || this;
    _this.element = target ? (0, _DOM.default)(target) : undefined;
    _this._images = {};
    _this._targets = {};
    _this._idPrefix = 'awxb-map-layer-';
    _this._isReset = false;
    _this._loading = false;
    _this._hasLoaded = false;

    if (!(0, _utils.isEmpty)(opts.key)) {
      _this._idPrefix += opts.key + "-";
    } // setup containers


    if (_this.element) {
      _this.element.addClass('amp-map');
    }

    _this._startup();

    return _this;
  }

  Object.defineProperty(ImageAnimation.prototype, "showWhenLoading", {
    get: function () {
      return this.opts.showWhenLoading;
    },
    set: function (value) {
      this.opts.showWhenLoading = value;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof ImageAnimation
   */

  ImageAnimation.prototype.dataByTime = function () {
    return this._images;
  };
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.play = function () {
    if (this.isAnimating()) return; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    }

    if (!this._hasImages() || this._totalImages() < this.totalIntervals) {
      this._load();

      return;
    }

    _super.prototype.play.call(this);
  };
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.stop = function () {
    _super.prototype.stop.call(this);

    if (this._loading) {
      this.reset();
    }
  };
  /**
   * Resets the animation to its original state.
   *
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.reset = function (updateTime) {
    var _this = this;

    if (updateTime === void 0) {
      updateTime = false;
    }

    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    }

    if (this._loaders) {
      Object.keys(this._loaders).forEach(function (key) {
        _this._loaders[key].onload = undefined;
      });
    }

    this._images = {};
    this._loaders = {};

    if (this.element) {
      this.element.empty();
    }

    _super.prototype.reset.call(this, updateTime);
  }; // public goToTime(time: any) {
  // 	super.goToTime(time);
  // 	// // show or hide animation container depending on current interval and if it's future or not
  // 	// if (!this.canShow(time)) {
  // 	// 	this.hide();
  // 	// } else if (this._hasImages()) {
  // 	// 	this.show();
  // 	// }
  // 	return this;
  // }

  /**
   * Returns whether the animation is ready for playback.
   *
   * An image animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.isReady = function () {
    var needed = this.totalIntervals;

    var loaded = this._totalImages();

    return !this.isLoading() && (this._hasImages() && loaded === needed || needed === 0);
  };
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.canAnimate = function () {
    var can = _super.prototype.canAnimate.call(this);

    if (can && this._hasLoaded && !this._hasImages()) {
      can = false;
    } else if (can && !this.isFuture() && !this.containsPast() || this.isFuture() && !this.containsFuture()) {
      can = false;
    }

    return can;
  };
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.isLoading = function () {
    return this._loading;
  };
  /**
   * Shows the animation content.
   *
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.show = function () {
    if (this.element) {
      this.element.show();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).show();
    }

    this.trigger('show');
  };
  /**
   * Hides the animation content.
   *
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.hide = function () {
    if (this.element) {
      this.element.hide();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).hide();
    }

    this.trigger('hide');
  };
  /**
   * Returns whether the animation container is currently visible.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype.isVisible = function () {
    if (this.element) {
      var element = this.element;

      if ((0, _utils.isDOM)(this.element) && this.element.length > 0) {
        element = this.element[0];
      }

      return element.style.display !== 'none';
    }

    if (this._currentImage) {
      return this._currentImage.style.display !== 'none';
    }

    return true;
  };

  ImageAnimation.prototype._target = function (key) {
    return this._targets[key];
  };
  /**
   * @ignore
   * Sets the visibility of currently active image.
   *
   * @private
   * @param {boolean} visible
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._setImageVisible = function (visible) {
    if (visible) {
      (0, _DOM.default)(this._currentImage).show();
    } else {
      (0, _DOM.default)(this._currentImage).hide();
    }
  };
  /**
   * @ignore
   * Updates the animation by showing the appropriate image for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._updateForTime = function (time) {
    var image = this._imageClosestToTime(time);

    if (image) {
      if (image !== this._currentImage) {
        (0, _DOM.default)(image).show();

        this._setImageVisible(false);

        this._currentImage = image;
      }
    } else if (!this.isAnimating() && this.opt('showWhenStopped') === true) {
      time = this._intervalClosestToTime(time);

      if (this.canShow(time)) {
        this._isReset = false;

        this._loadInterval(time, true, null);
      }
    }

    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    }
  };
  /**
   * @ignore
   * Returns the image closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {*}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._imageClosestToTime = function (time) {
    var image = null;
    var closest = this.from;
    var diff = Math.abs(time - closest);

    if (!this._images) {
      return null;
    }

    Object.keys(this._images).forEach(function (imageTime) {
      var imageDiff = Math.abs(time - +imageTime);

      if (imageDiff < diff) {
        diff = imageDiff;
        closest = +imageTime;
      }
    });

    if (closest !== this._lastImageTime && this._images[closest]) {
      image = this._images[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger(_Animation.default.Event.ADVANCE_IMAGE, {
        time: closest,
        img: image
      });
    }

    return image;
  };
  /**
   * @ignore
   * Returns whether animation images are available.
   *
   * @private
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._hasImages = function () {
    return this._totalImages() > 0;
  };
  /**
   * @ignore
   * Returns the total number of animation images.
   *
   * @private
   * @returns {number}
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._totalImages = function () {
    var _this = this;

    if ((0, _utils.isUndefined)(this._images)) return 0;
    return Object.keys(this._images).filter(function (time) {
      return (0, _utils.isset)(_this._images[time]);
    }).length;
  };
  /**
   * @ignore
   * Loads all images based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._load = function () {
    var _this = this;

    this._isReset = false;
    this._loading = true;
    var times = this.neededIntervals() || []; // reduce times by interval images we may already have cached

    Object.keys(this._images).forEach(function (key) {
      var time = parseInt(key, 10);
      var index = times.indexOf(time);

      if (index !== -1) {
        times.splice(index, 1);
      }
    });

    var onLoadComplete = function () {
      _this._loading = false;
      _this._hasLoaded = true;

      _this.trigger(_Animation.default.Event.LOAD_DONE);

      if (!_this.timeline) {
        _this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    } // set size of animation container


    if (this.element && this.opts.autosize === true && this.provider) {
      var size = this.provider.animationSizeForImage(this);
      this.element.css({
        width: size.width + "px",
        height: size.height + "px"
      });
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // }


    this.trigger(_Animation.default.Event.LOAD_START, {
      times: times
    });
    var loadingInterval = 0;

    var loadNextInterval = function () {
      _this._loadInterval(times[loadingInterval], true, function () {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!_this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (_this.opts.refresh > 0) {
              if (_this._reloadTimer) {
                window.clearTimeout(_this._reloadTimer);
              }

              _this._reloadTimer = setTimeout(function () {
                _this.reset();

                _this._load();
              }, _this.opts.refresh * 1000);
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    loadNextInterval();
  };
  /**
   * @ignore
   * Loads a single image for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._loadInterval = function (time, cache, callback) {
    var _this = this;

    time = Math.round(time); // don't reload interval if it already exists in the DOM

    var el = document.getElementById("" + this._idPrefix + time);

    if (el) {
      var $el = (0, _DOM.default)(el);
      $el.show();

      this._setImageVisible(false);

      this._currentImage = $el;

      this._setImageVisible(true);

      if (callback) {
        callback();
      }

      return;
    }

    if (!this._images) {
      this._images = {};
    }

    if (!this._loaders) {
      this._loaders = {};
    } // skip the request if we already have a cached image for this interval


    if (this._images[time]) {
      if (callback) {
        callback();
      }

      return;
    } // don't load if we already have a loader running for this interval


    if (this._loaders[time]) {
      return;
    }

    var date = new Date(time);
    var url;

    if (this.provider) {
      url = this.provider.animationUrlForDate(this, date);
    }

    var onFailure = function (failedTime) {
      _this._images[failedTime] = new Image();

      _this.trigger(_Animation.default.Event.LOAD_ERROR, {
        date: date,
        interval: Object.keys(_this._images).length - 1
      });

      if (callback) {
        callback();
      }
    };

    if (!url) {
      onFailure(time);
      return;
    }

    var image = new Image();
    this._loaders[time] = image;

    image.onload = function () {
      if (_this._isReset) return;

      if (_this._loaders[time]) {
        delete _this._loaders[time];
      }

      var id = "" + _this._idPrefix + time;
      var size = {
        width: image.width,
        height: image.height
      };

      if (_this.provider) {
        size = _this.provider.animationSizeForImage(_this);
      }

      var img = "<img id=\"" + id + "\" src=\"" + image.src + "\" width=\"" + size.width + "\" height=\"" + size.height + "\" style=\"position:absolute;\">";

      if (_this.element) {
        _this.element.append(img);
      }

      if (cache) {
        _this._images[time] = _this._hasDOMTarget() ? (0, _DOM.default)("#" + id) : image;
      }

      _this._setImageVisible(false);

      _this._currentImage = _this._hasDOMTarget() ? (0, _DOM.default)("#" + id) : image;

      if (callback) {
        callback();
      }

      var loadedCount = Object.keys(_this._images).length;

      _this.trigger(_Animation.default.Event.LOAD_IMAGE, {
        date: new Date(time),
        src: image.src,
        img: image
      });

      _this.trigger(_Animation.default.Event.LOAD_PROGRESS, {
        time: time,
        interval: loadedCount - 1,
        loaded: loadedCount,
        total: _this.totalIntervals
      }); // if (callback) {
      // 	callback();
      // }

    };

    image.onerror = function () {
      onFailure(time);
    };

    image.src = url;
  };
  /**
   * @ignore
   * Returns whether a DOM target for the animation has been defined.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  ImageAnimation.prototype._hasDOMTarget = function () {
    return this.element && this.element.length > 0;
  };

  return ImageAnimation;
}(_Animation.default);

var _default = ImageAnimation;
exports.default = _default;
module.exports = exports.default;