import Animation, { AnimationOptions } from './Animation';
/**
 * An interface implemented by an object that contains a renderable object associated with a
 * specific time.
 */
export interface ITimeRepresentable {
    /**
     * GMT timestamp in milliseconds
     */
    timestamp: number;
    /**
     * Renderable object that is added to a map view
     */
    renderable: any;
}
/**
 * An interface implemented by an object that provides annotation information requested by a data
 * animation.
 */
export interface IDataAnimationProvider {
    /**
     * Asks the data source for the annotation information required for the animation.
     *
     * @param {DataAnimation} animation
     * @returns {Promise<any>}
     * @memberof IDataAnimationProvider
     */
    animationData(animation: DataAnimation): Promise<any>;
}
/**
 * A `DataAnimation` object is a subclass of `Animation` that is responsible for managing data
 * required for animation playback.
 */
export default class DataAnimation extends Animation {
    /**
     * The receiver's data provider.
     *
     * @type {IDataAnimationProvider}
     * @memberof DataAnimation
     */
    provider: IDataAnimationProvider;
    private data;
    private itemsByTime;
    private dataBeyondBounds;
    protected lastInterval: number;
    /**
     * Initializes a new animation instance with the provided configuration.
     *
     * @param {AnimationOptions} [opts=null]
     * @memberof DataAnimation
     */
    constructor(opts?: AnimationOptions);
    /**
     * Returns the animation data keyed by time interval.
     *
     * @returns {{ [key: number]: any }}
     * @memberof DataAnimation
     */
    dataByTime(): {
        [key: number]: any;
    };
    /**
     * Updates the data for the animation.
     *
     * @param {*} data
     * @memberof DataAnimation
     */
    setData(data: any): void;
    /**
     * Begins playing the animation if not currently running.
     *
     * If data is not yet available for playback, then it will be requested from the animation
     * data provider.
     *
     * @returns
     * @memberof DataAnimation
     */
    play(): void;
    /**
     * @ignore
     * Updates the animation by showing the appropriate data for the specifyed time interval.
     *
     * @protected
     * @param {*} time
     * @returns
     * @memberof DataAnimation
     */
    protected _updateForTime(time: any): void;
    restart(): void;
    /**
     * Resets the animation to its original state.
     *
     * All cached animation data will be removed and new data will have to be requested from the
     * data provider again when playback begins.
     *
     * @memberof DataAnimation
     */
    reset(): void;
    /**
     * Returns whether the animation element is currently visible.
     *
     * @returns {boolean}
     * @memberof DataAnimation
     */
    isVisible(): boolean;
    /**
     * Returns whether the animation is ready for playback.
     *
     * A data animation is only ready once required data has been set.
     *
     * @returns {boolean}
     * @memberof DataAnimation
     */
    isReady(): boolean;
    /**
     * Returns whether the animation can animated based on whether or not data has been loaded
     * and already cached for playback.
     *
     * @returns {boolean}
     * @memberof DataAnimation
     */
    canAnimate(): boolean;
    /**
     * @ignore
     * Called when the animation `from` or `to` values have changed so that the animation intervals
     * can be recalculated and data processed into the corresponding time interval blocks.
     *
     * @protected
     * @memberof DataAnimation
     */
    protected _handleTimingChange(): void;
    /**
     * @ignore
     * Prepares the data for animating by assigning each data element into the corresponding time
     * interval block.
     *
     * @protected
     * @param {*} items
     * @returns
     * @memberof DataAnimation
     */
    protected _prepareDataItems(items: any): void;
    /**
     * @ignore
     * Calculates the time intervals required by the animation based on the animation time range
     * and step increment.
     *
     * @protected
     * @returns {{ [time: number]: any }}
     * @memberof DataAnimation
     */
    protected _prepareIntervals(): {
        [time: number]: any;
    };
    /**
     * @ignore
     * Returns the data closest to the specified time interval.
     *
     * @protected
     * @param {number} time
     * @returns {number}
     * @memberof DataAnimation
     */
    protected dataIntervalClosestToTime(time: number): number;
    /**
     * @ignore
     * Returns the data for the specified time range.
     *
     * @protected
     * @param {number} from
     * @param {number} to
     * @returns {any[]}
     * @memberof DataAnimation
     */
    protected _elementsInIntervalRange(from: number, to: number): any[];
}
