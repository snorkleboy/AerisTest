"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _DataAnimation = _interopRequireDefault(require("./DataAnimation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `TextAnimation` object is a subclass of `DataAnimation` that is responsible for managing a
 * series of text annotations required for animation playback.
 */
var TextAnimation =
/** @class */
function (_super) {
  __extends(TextAnimation, _super);
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof TextAnimation
   */


  function TextAnimation(opts) {
    if (opts === void 0) {
      opts = null;
    }

    var _this = this;

    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    _this = _super.call(this, opts) || this;
    return _this;
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof TextAnimation
   */


  TextAnimation.prototype._updateForTime = function (time) {
    var _this = this;

    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    var interval = this.currentTime; // if (interval === this.lastInterval) return;

    var from = Math.min(this.lastInterval, interval);
    var to = Math.max(this.lastInterval, interval);
    var elements; // if animation is restarting, we need to update all text elements with their initial value
    // so we need to grab the starting value by unique identifier to update the text values with

    if (interval < this.lastInterval) {
      var ids_1 = [];
      var results_1 = [];
      var intervals = Object.keys(this.dataByTime()).sort().map(function (o) {
        return parseInt(o, 10);
      });
      intervals.forEach(function (t) {
        var items = _this.dataByTime()[t];

        items.forEach(function (item) {
          if (ids_1.indexOf(item.id) === -1) {
            results_1.push(item);
            ids_1.push(item.id);
          }
        });
      });
      elements = results_1;
    } else {
      elements = this._elementsInIntervalRange(from, to);
    }

    if (elements.length > 0) {
      this.trigger(_Animation.default.Event.DATA_UPDATE, {
        items: elements
      });
    }

    this.lastInterval = interval;
  };
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof TextAnimation
   */


  TextAnimation.prototype._prepareDataItems = function (items) {
    var _this = this;

    if (this.increment <= 0 || !(0, _utils.isPlainObject)(items)) return;

    var intervals = this._prepareIntervals();

    var data = items; // add data to interval arrays

    Object.keys(data).forEach(function (id) {
      var _a = items[id],
          renderable = _a.renderable,
          item = _a.data,
          style = _a.style;
      Object.keys(item).forEach(function (timestamp) {
        var ts = parseInt(timestamp, 10);

        var interval = _this.dataIntervalClosestToTime(ts);

        if (ts < _this.to && intervals[interval]) {
          intervals[interval].push({
            id: id,
            value: item[ts],
            renderable: renderable,
            style: style
          });
        }
      });
    });
    this.trigger(_Animation.default.Event.LOAD_DONE);
  };

  return TextAnimation;
}(_DataAnimation.default);

var _default = TextAnimation;
exports.default = _default;
module.exports = exports.default;