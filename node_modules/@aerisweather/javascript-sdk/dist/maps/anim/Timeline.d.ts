import Animation, { AnimationOptions } from './Animation';
/**
 * A `Timeline` object is a subclass of `Animation` that manages, syncs and controls multiple
 * animations. All animations within are controlled by a single timeline, resulting in animations
 * being synced across time during playback.
 */
export default class Timeline extends Animation {
    private _animations;
    private _loading;
    /**
     * The animation instances being managed by this timeline.
     *
     * @type {{ [key: string]: Animation }}
     * @memberof Timeline
     */
    animations: {
        [key: string]: Animation;
    };
    /**
     * Initializes a new timeline instance with the provided configuration.
     *
     * @param {AnimationOptions} [opts=null]
     * @memberof Timeline
     */
    constructor(opts?: AnimationOptions);
    /**
     * Returns the timeline animation associated with the specified key, if exists.
     *
     * @param {string} key
     * @returns {Animation}
     * @memberof Timeline
     */
    get(key: string): Animation;
    /**
     * Adds an animation instance to the timeline for the specified key.
     *
     * @param {string} key
     * @param {Animation} animation
     * @memberof Timeline
     */
    add(key: string, animation: Animation): void;
    /**
     * Removes an animation instance from the timeline.
     *
     * @param {Animation} animation
     * @memberof Timeline
     */
    remove(animation: Animation): void;
    /**
     * Removes an animation instance from the timeline for the specified key.
     *
     * @param {string} key
     * @memberof Timeline
     */
    removeBy(key: string): void;
    /**
     * Begins playing the animation if not currently running.
     *
     * Playback will wait for all internal animation instances to become ready, which means each
     * animation will need to load its required animation data before the timeline can begin
     * playback.
     *
     * @returns
     * @memberof Timeline
     */
    play(): void;
    /**
     * Stops playing the animation if currently running.
     *
     * Starting the animation again using `start()` after calling `stop()` will restart the
     * animation from the beginning.
     *
     * @memberof Timeline
     */
    stop(): void;
    /**
     * Pauses the animation at the current position.
     *
     * To resume playback from a paused animation's current position, use `resume()`.
     *
     * @memberof Timeline
     */
    pause(): void;
    /**
     * Restarts the animation from the beginning.
     *
     * @memberof Timeline
     */
    restart(): void;
    /**
     * Resets the animation to its original state.
     *
     * @memberof Timeline
     */
    reset(updateTime?: boolean): void;
    /**
     * Returns whether internal animations are currently loading data required for playback.
     *
     * @returns {boolean}
     * @memberof Timeline
     */
    isLoading(): boolean;
    /**
     * Advances the animation to the specified time.
     *
     * @param {*} time
     * @returns
     * @memberof Timeline
     */
    goToTime(time: any): import("../interfaces/IAnimatable").default;
    /**
     * Sets the start date of the animation.
     *
     * @param {(Date | number)} date
     * @returns
     * @memberof Timeline
     */
    setStartDate(date: Date | number): this;
    /**
     * Sets the start date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Timeline
     */
    setStartOffset(offset: number): this;
    /**
     * Sets the end date of the animation.
     *
     * @param {(Date | number)} date
     * @returns
     * @memberof Timeline
     */
    setEndDate(date: Date | number): this;
    /**
     * Sets the end date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Timeline
     */
    setEndOffset(offset: number): this;
    /**
     * Updates the animation's start and end times based on the configured offsets and the current
     * time and date.
     *
     * @memberof Timeline
     */
    refresh(): void;
    /**
     * @ignore
     * Performs a function on each internal animation instance.
     *
     * @private
     * @param {(anim: Animation) => void} fn
     * @memberof Timeline
     */
    private _each;
    /**
     * @ignore
     * Called when the animation time range has changed.
     *
     * @protected
     * @memberof Timeline
     */
    protected _onTimingChange(): void;
}
