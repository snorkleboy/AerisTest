"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `DataAnimation` object is a subclass of `Animation` that is responsible for managing data
 * required for animation playback.
 */
var DataAnimation =
/** @class */
function (_super) {
  __extends(DataAnimation, _super);
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof DataAnimation
   */


  function DataAnimation(opts) {
    if (opts === void 0) {
      opts = null;
    }

    var _this = this;

    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    _this = _super.call(this, opts) || this;
    _this.itemsByTime = {};
    _this.lastInterval = 0;
    _this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add event handler to re-add all data elements that fall after the end of the timeline
    // range when the animation is stopped

    _this.on('stop', function () {
      _this.trigger(_Animation.default.Event.DATA_ADD, {
        items: _this.dataBeyondBounds.after.filter(function (item) {
          return item !== undefined;
        })
      }); // eslint-disable-line max-len

    });

    return _this;
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof DataAnimation
   */


  DataAnimation.prototype.dataByTime = function () {
    return this.itemsByTime;
  };
  /**
   * Updates the data for the animation.
   *
   * @param {*} data
   * @memberof DataAnimation
   */


  DataAnimation.prototype.setData = function (data) {
    this.data = data;

    this._prepareDataItems(data);
  };
  /**
   * Begins playing the animation if not currently running.
   *
   * If data is not yet available for playback, then it will be requested from the animation
   * data provider.
   *
   * @returns
   * @memberof DataAnimation
   */


  DataAnimation.prototype.play = function () {
    var _this = this;

    if (!this.canAnimate() && this.provider) {
      this.provider.animationData(this).then(function (data) {
        _this.setData(data);

        _this.lastInterval = _this.to;
      });
      return;
    }

    _super.prototype.play.call(this);
  };
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof DataAnimation
   */


  DataAnimation.prototype._updateForTime = function (time) {
    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    var interval = this.currentTime;
    if (interval === this.lastInterval) return;
    var from = Math.min(this.lastInterval, interval);
    var to = Math.max(this.lastInterval, interval); // let data = this._elementsInIntervalRange(from, to);

    var data;
    var remove = interval < this.lastInterval;

    if (interval === this.from) {
      // remove all items in range if we're restarting from the beginning
      remove = true;
      data = this._elementsInIntervalRange(this.from, this.to);
    } else {
      // otherwise get the elements within the new from/to range, unless we're removing in
      // which case we remove all elements within the `from` to bounds end
      data = this._elementsInIntervalRange(from, remove ? this.to : to);
    }

    if (data.length > 0) {
      if (remove) {
        var itemsToRemove = [].concat(this.itemsByTime[this.from]);
        itemsToRemove.forEach(function (item) {
          var index = data.indexOf(item);

          if (index !== -1) {
            data.splice(index, 1);
          }
        }); // add all elements that fall after end of timeline range so they get removed

        data = data.concat(this.dataBeyondBounds.after);
        this.trigger(_Animation.default.Event.DATA_REMOVE, {
          items: data.filter(function (item) {
            return item !== undefined;
          })
        }); // eslint-disable-line max-len
      } else {
        this.trigger(_Animation.default.Event.DATA_ADD, {
          items: data.filter(function (item) {
            return item !== undefined;
          })
        }); // eslint-disable-line max-len
      }
    }

    this.lastInterval = interval;
  };

  DataAnimation.prototype.restart = function () {
    this.lastInterval = this.to;

    _super.prototype.restart.call(this);
  };
  /**
   * Resets the animation to its original state.
   *
   * All cached animation data will be removed and new data will have to be requested from the
   * data provider again when playback begins.
   *
   * @memberof DataAnimation
   */


  DataAnimation.prototype.reset = function () {
    this.data = null;
    this.itemsByTime = {};

    _super.prototype.reset.call(this);
  };
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  DataAnimation.prototype.isVisible = function () {
    return true;
  };
  /**
   * Returns whether the animation is ready for playback.
   *
   * A data animation is only ready once required data has been set.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  DataAnimation.prototype.isReady = function () {
    return this.data != null;
  };
  /**
   * Returns whether the animation can animated based on whether or not data has been loaded
   * and already cached for playback.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  DataAnimation.prototype.canAnimate = function () {
    var can = _super.prototype.canAnimate.call(this);

    return can && this.dataByTime() && Object.keys(this.dataByTime()).length > 0;
  };
  /**
   * @ignore
   * Called when the animation `from` or `to` values have changed so that the animation intervals
   * can be recalculated and data processed into the corresponding time interval blocks.
   *
   * @protected
   * @memberof DataAnimation
   */


  DataAnimation.prototype._handleTimingChange = function () {
    if (this.data) {
      this._prepareDataItems(this.data);
    }
  };
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof DataAnimation
   */


  DataAnimation.prototype._prepareDataItems = function (items) {
    var _this = this;

    if (this.increment <= 0 || !(0, _utils.isArray)(items)) return;

    var intervals = this._prepareIntervals();

    var data = items;
    var timeKey = 'timestamp';
    this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add data to interval arrays

    (data || []).forEach(function (item) {
      if ((0, _utils.has)(item, timeKey)) {
        var itemTime = (0, _utils.get)(item, timeKey);

        if (itemTime < _this.from) {
          _this.dataBeyondBounds.before.push(item.renderable);
        } else if (itemTime > _this.to) {
          _this.dataBeyondBounds.after.push(item.renderable);
        } else {
          var interval = _this.dataIntervalClosestToTime(itemTime);

          if (itemTime < _this.to && intervals[interval]) {
            intervals[interval].push(item.renderable);
          }
        }
      }
    });
    this.trigger(_Animation.default.Event.LOAD_DONE);
  };
  /**
   * @ignore
   * Calculates the time intervals required by the animation based on the animation time range
   * and step increment.
   *
   * @protected
   * @returns {{ [time: number]: any }}
   * @memberof DataAnimation
   */


  DataAnimation.prototype._prepareIntervals = function () {
    var time = this.from;
    var to = this.to; // setup intervals object and arrays

    var intervals = {};

    while (time < to) {
      intervals[Math.round(time)] = [];
      time += this.increment;
    }

    this.itemsByTime = intervals;
    return this.dataByTime();
  };
  /**
   * @ignore
   * Returns the data closest to the specified time interval.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof DataAnimation
   */


  DataAnimation.prototype.dataIntervalClosestToTime = function (time) {
    var intervals = Object.keys(this.dataByTime()).sort().reverse().map(function (o) {
      return parseInt(o, 10);
    }); // eslint-disable-line max-len

    var interval = 0;

    if (time < this.from || time > this.to) {
      interval = time;
    } else {
      intervals.forEach(function (value) {
        if (time >= value && interval === 0) {
          interval = value;
        }
      });
    } // the following will add data that falls before the start of the animation to the first
    // interval, which isn't necessarily what is wanted for now
    // if (interval === 0 && time < intervals[0]) {
    // 	interval = intervals[0];
    // }


    return interval;
  };
  /**
   * @ignore
   * Returns the data for the specified time range.
   *
   * @protected
   * @param {number} from
   * @param {number} to
   * @returns {any[]}
   * @memberof DataAnimation
   */


  DataAnimation.prototype._elementsInIntervalRange = function (from, to) {
    var _this = this;

    if (from === to) return [];
    var result = [];
    var intervals = Object.keys(this.dataByTime()).sort().map(function (o) {
      return parseInt(o, 10);
    });
    var include = [];
    intervals.forEach(function (interval) {
      var add = false;

      if (to < from) {
        if (interval >= to && interval < from) {
          add = true;
        }
      } else if (interval === from && interval === to) {
        add = true;
      } else if (interval >= from && interval < to || interval === to) {
        add = true;
      } // make sure we aren't re-adding the same interval multiple times


      if (add && include.indexOf(interval) === -1) {
        include.push(interval);
        result = (result || []).concat(_this.dataByTime()[interval]);
      }
    });
    return result;
  };

  return DataAnimation;
}(_Animation.default);

var _default = DataAnimation;
exports.default = _default;
module.exports = exports.default;