"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _utils = require("../../utils");

var _strings = require("../../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * An `Animation` object provides the core functionality necessary for a single time-based animation. The animation
 * is defined by a specified start and end date.
 */
var Animation =
/** @class */
function (_super) {
  __extends(Animation, _super);
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {*} [opts=null]
   * @memberof Animation
   */


  function Animation(opts) {
    if (opts === void 0) {
      opts = null;
    }

    var _this = _super.call(this) || this;

    _this._startOffset = 0;
    _this._endOffset = 0;
    _this._elapsed = 0;
    _this._time = 0;
    _this._offset = 0;
    _this._delay = 1 / 60;
    _this._increment = 0;
    _this._timer = null;
    _this._restartTimer = null;
    _this._paused = false;
    _this._currentInterval = 0;
    _this._active = false;
    _this._enabled = true;
    opts = (0, _utils.extend)({}, {
      key: undefined,
      enabled: true,
      from: 0,
      to: 0,
      duration: 2,
      endDelay: 1,
      intervals: 10,
      autoplay: false,
      future: false,
      alwaysShow: false
    }, opts);
    _this._now = new Date();

    var time = _this._now.getTime();

    var offsetForDate = function (date, relativeTo) {
      return date.getTime() - relativeTo.getTime();
    }; // convert strings to numbers as needed


    Object.keys(opts).forEach(function (key) {
      var val = opts[key]; // convert time string offsets to numerical second offsets

      if ((key === 'from' || key === 'to') && (0, _utils.isString)(val)) {
        if (/(year|month|day|hour|minute|second)/.test(val)) {
          val = (0, _utils.toTimeOffsetHours)(val) * 3600;
        }
      }

      if ((0, _utils.isNumeric)(val)) {
        val = parseFloat(val);
      } // // if from or to are < 3600, then assume an hour value was provided and convert to seconds
      // if ((key === 'from' || key === 'to') && Math.abs(val) < 3600) {
      // 	val *= 3600;
      // }


      opts[key] = val;
    }); // convert from/to date strings to Date objects

    if ((0, _utils.isString)(opts.from)) {
      opts.from = (0, _strings.toDate)("" + opts.from);
    }

    if ((0, _utils.isString)(opts.to)) {
      opts.to = (0, _strings.toDate)("" + opts.to);
    }

    _this.opts = opts;

    if ((0, _utils.isDate)(opts.from)) {
      var date = opts.from;
      _this._startOffset = date.getTime() - time;
      _this.from = date.getTime();
    } else {
      _this._startOffset = parseFloat("" + opts.from) * 1000;
      _this.from = time + _this._startOffset;
    }

    if ((0, _utils.isDate)(opts.to)) {
      var date = opts.to;
      _this._endOffset = date.getTime() - time;
      _this.to = date.getTime();
    } else {
      _this._endOffset = parseFloat("" + opts.to) * 1000;
      _this.to = time + _this._endOffset;
    }

    _this._enabled = opts.enabled;
    _this.duration = opts.duration || 2;
    _this.endDelay = opts.endDelay || 1;
    _this.totalIntervals = opts.intervals || 10;
    _this._time = _this.from;
    _this._times = [];

    _this._startup();

    return _this;
  }

  Object.defineProperty(Animation.prototype, "key", {
    /**
     * The key associated with the animation, if any.
     *
     * @readonly
     * @type {string}
     * @memberof Animation
     */
    get: function () {
      return this.opts.key;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "timeline", {
    /**
     * Parent timeline managing this animation, if any.
     *
     * @type {Timeline}
     * @memberof Animation
     */
    get: function () {
      return this._timeline;
    },
    set: function (value) {
      var _this = this;

      this._timeline = value;

      if (value) {
        this.from = value.from;
        this.to = value.to; // update config options to match parent timeline

        ['duration', 'endDelay', 'intervals'].forEach(function (key) {
          _this.opt(key, value.opt(key));
        });
        this.goToTime(value.currentTime);
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "from", {
    /**
     * Starting Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return parseFloat("" + this.opts.from);
    },
    set: function (value) {
      this.stop();
      this.opts.from = value;
      this._startOffset = value - this._now.getTime();

      this._onTimingChange();

      this.trigger(Animation.Event.START_CHANGE, {
        from: this.startDate(),
        to: this.endDate()
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "to", {
    /**
     * Ending Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return parseFloat("" + this.opts.to);
    },
    set: function (value) {
      this.stop();
      this.opts.to = value;
      this._endOffset = value - this._now.getTime();

      this._onTimingChange();

      this.trigger(Animation.Event.END_CHANGE, {
        from: this.startDate(),
        to: this.endDate()
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "now", {
    /**
     * Current time value that represents now. This value is used to determine past/future time
     * periods within the full time range.
     *
     * @type {Date}
     * @memberof Animation
     */
    get: function () {
      return this._now;
    },
    set: function (value) {
      this._now = value;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "duration", {
    /**
     * Total time in seconds for the animation to complete. The animation speed will be determined
     * by the duration and total intervals, so a longer duration will result in a slower animation
     * speed for the same number of intervals.
     *
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this.opts.duration;
    },
    set: function (value) {
      this.opts.duration = value;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "endDelay", {
    /**
     * Delay duration in seconds to hold the last interval of the animation before restarting from
     * the beginning.
     *
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this.opts.endDelay;
    },
    set: function (value) {
      this.opts.endDelay = value;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "totalTime", {
    /**
     * Returns the total time, in milliseconds, of the animation based on the start and end timestamps.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this.to - this.from;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "currentTime", {
    /**
     * Returns the current time of the animation's position in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this._time;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "currentOffset", {
    /**
     * Returns the current time offset from the beginning of the animation in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this._offset;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "increment", {
    get: function () {
      return this._increment;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Animation.prototype, "position", {
    /**
     * The animation's current position in the range of `0` to `1.0`, where `0` is the beginning
     * and `1.0` is the end.
     *
     * @type {number}
     * @memberof Animation
     */
    get: function () {
      return this._offset / this.totalTime;
    },
    set: function (value) {
      this.goToTime(this.from + (this.to - this.from) * value);
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Sets or returns the configuration value for the specified key path.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof Animation
   */

  Animation.prototype.opt = function (key, value) {
    if (value) {
      (0, _utils.set)(this.opts, key, value);

      if (key === 'intervals') {
        this._updateTimes();
      }
    }

    return (0, _utils.get)(this.opts, key);
  };
  /**
   * Either plays or stops the animation playback depending on the current state.
   *
   * @memberof Animation
   */


  Animation.prototype.toggle = function () {
    if (this.isAnimating() || this.isLoading()) {
      this.stop();
    } else {
      this.play();
    }
  };
  /**
   * Begins playing the animation if not currently running.
   *
   * @returns
   * @memberof Animation
   */


  Animation.prototype.play = function () {
    if (this.isAnimating()) {
      return;
    } // if not resuming from paused state, start from beginning of the timeline


    if (!this._paused) {
      this.goToTime(this.from);
    } // if from and to are the same times, just go to that time and don't animate


    if (!this.canAnimate()) {
      return;
    }

    this._paused = false;
    this._active = true;

    this._updateTiming();

    this.trigger(Animation.Event.PLAY, {
      from: this.startDate(),
      to: this.endDate()
    });

    this._start();
  };
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @returns
   * @memberof Animation
   */


  Animation.prototype.stop = function () {
    this._clearTimers();

    if (!this.isAnimating() && !this.isLoading()) {
      return;
    }

    this._paused = false;
    this._active = false;
    this.trigger(Animation.Event.STOP);
    this.goToInit();
  };
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Animation
   */


  Animation.prototype.pause = function () {
    this._clearTimers();

    this._paused = true;
  };
  /**
   * Resumes playing the animation from the paused position.
   *
   * @memberof Animation
   */


  Animation.prototype.resume = function () {
    if (this.isAnimating() && this._paused) {
      this._start();
    }

    this._paused = false;
  };
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Animation
   */


  Animation.prototype.restart = function () {
    var _this = this;

    this._clearTimers();

    this._restartTimer = setTimeout(function () {
      _this.goToTime(_this.from);

      _this._start();
    }, this.endDelay * 1000);
  };
  /**
   * Resets the animation to its original state.
   *
   * @memberof Animation
   */


  Animation.prototype.reset = function (updateTime) {
    if (updateTime === void 0) {
      updateTime = false;
    }

    if (this.isAnimating()) {
      this.stop();
    } else if (updateTime) {
      this.goToInit();
    }

    this.trigger(Animation.Event.RESET);
  };
  /**
   * Called when an animation is first created, stopped or reset and determines the time interval
   * to display for the static position so that it's closest to the current time as possible.
   *
   * @memberof Animation
   */


  Animation.prototype.goToInit = function () {
    var now = this._now.getTime();

    var time = now;

    if (time > this.to) {
      time = this.to;
    } else if (time < this.from) {
      time = this.from;
    }

    if (this.from >= now) {
      time = this.from;
    } else if (this.to <= now) {
      time = this.to;
    }

    if (time > 0) {
      this.goToTime(time);
    }
  };
  /**
   * Advances the animation to the specified time.
   *
   * @param {(number | Date)} time The time in milliseconds to update the animation's playhead
   * to, which must be within the `to` and `from` time range.
   * @returns {IAnimatable}
   * @memberof Animation
   */


  Animation.prototype.goToTime = function (time) {
    var _time;

    if ((0, _utils.isDate)(time)) {
      _time = time.getTime();
    } else {
      _time = time;
    }

    this._offset = _time - this.from;

    var closest = this._intervalClosestToTime(_time);

    this._currentInterval = closest;
    this._time = _time;

    this._updateForTime(closest);

    this.trigger(Animation.Event.ADVANCE, {
      time: this._time,
      offset: this._offset
    });
    return this;
  };
  /**
   * Returns an array of timestamps defining the interval steps that will be rendered during
   * playback.
   *
   * Total intervals returned will be evenly distributed across the animations time range based
   * on the value for `opts.intervals`.
   *
   * @returns {number[]}
   * @memberof Animation
   */


  Animation.prototype.neededIntervals = function () {
    return this._times.slice(0);
  };
  /**
   * Returns the current time interval in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  Animation.prototype.currentInterval = function () {
    return this._currentInterval;
  };
  /**
   * Returns the current time interval as a `Date`.
   *
   * @returns {Date}
   * @memberof Animation
   */


  Animation.prototype.currentDate = function () {
    return new Date(this.currentTime);
  };
  /**
   * Returns the start date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  Animation.prototype.startDate = function () {
    return new Date(this.from);
  };
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to
   * update the start time to
   * @returns
   * @memberof Animation
   */


  Animation.prototype.setStartDate = function (date) {
    var time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time > this.to) {
      console.error("[Aeris] Animation start date cannot be set to a date after the current\n\t\t\t\tend date value. You may need to change the end date first.");
      return;
    }

    this.from = time; // const now = new Date().getTime();
    // if (this.from > now) {
    // 	this.goToTime(now);
    // } else if (this.currentTime < this.from) {
    // 	this.goToTime(this.from);
    // }

    return this;
  };
  /**
   * Returns the current start offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  Animation.prototype.startOffset = function () {
    return this._startOffset;
  };
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  Animation.prototype.setStartOffset = function (offset) {
    var time = this._now.getTime() + offset;

    if (time > this.to) {
      console.error("[Aeris] Animation start offset cannot be set to a time offset after the\n\t\t\t\tcurrent end date value. You may need to change the end date or time offset first.");
      return;
    }

    this.from = time;
    return this;
  };
  /**
   * Returns the end date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  Animation.prototype.endDate = function () {
    return new Date(this.to);
  };
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to update
   * the end time to
   * @returns
   * @memberof Animation
   */


  Animation.prototype.setEndDate = function (date) {
    var time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time < this.from) {
      console.error("[Aeris] Animation end date cannot be set to a date before the current\n\t\t\t\tstart date value. You may need to change the start date first.");
      return;
    }

    this.to = time;

    var now = this._now.getTime();

    if (this.to > now) {
      this.goToTime(now);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }

    return this;
  };
  /**
   * Returns the current end offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  Animation.prototype.endOffset = function () {
    return this._endOffset;
  };
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  Animation.prototype.setEndOffset = function (offset) {
    var time = this._now.getTime() + offset;

    if (time < this.from) {
      console.error("[Aeris] Animation end offset cannot be set to a time offset before the\n\t\t\t\tcurrent start date value. You may need to change the start date or time offset first.");
      return;
    }

    this.to = time;
    return this;
  };
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Animation
   */


  Animation.prototype.refresh = function () {
    this._now = new Date();
    this.from = this._now.getTime() + this._startOffset;
    this.to = this._now.getTime() + this._endOffset;
  };
  /**
   * Returns whether or not the animation can animation.
   *
   * This method will return `false` if the animation's `from` and `to` values are the same, or
   * if the animation is disabled.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.canAnimate = function () {
    return this.to !== this.from && this.isEnabled();
  };
  /**
   * Returns whether the animation should be visible for the specified time.
   *
   * This method will return `false` if the animation is specified as a future animation and the
   * `time` is in the past, or if the animation is not specified as a future animation and the
   * `time` is in the future.
   *
   * @param {number} [time]
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.canShow = function (time) {
    if (this.opts.alwaysShow === true) {
      return true;
    }

    if (!time) {
      time = this._time;
    }

    var now = this._now.getTime();

    if (this.isFuture()) {
      return time > now;
    }

    return time <= now;
  };
  /**
   * Sets whether the animation should be enabled.
   *
   * @param {boolean} enable
   * @memberof Animation
   */


  Animation.prototype.enabled = function (enable) {
    this._enabled = enable;
  };
  /**
   * Returns whether the animation is currently enabled. Disabled animations would not animate
   * during playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isEnabled = function () {
    return this._enabled;
  };
  /**
   * Returns whether the animation should automatically begin playback after being created.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isAutoPlay = function () {
    return this.opts.autoplay;
  };
  /**
   * Returns whether the animation is ready for playback.
   *
   * Subclasses may override this value to indicate additional data or assets are required to be
   * loaded in order to begin playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isReady = function () {
    return true;
  };
  /**
   * Returns whether the animation is currently loading data or assets required for playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isLoading = function () {
    return false;
  };
  /**
   * Returns whether the animation is currently running.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isAnimating = function () {
    return this._active;
  };
  /**
   * Returns whether the animation is currently paused.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isPaused = function () {
    return this._paused;
  };
  /**
   * Returns whether the animation has been specified as a future-only animation, meaning it's
   * only valid for time intervals into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.isFuture = function () {
    return this.opts.future === true;
  };
  /**
   * Returns whether the animation's time range extends into the past.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.containsPast = function () {
    return this.startDate().getTime() < this._now.getTime();
  };
  /**
   * Returns whether the animation's time range extends into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  Animation.prototype.containsFuture = function () {
    return this.endDate().getTime() > this._now.getTime();
  };
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  Animation.prototype._startup = function () {
    this._updateTimes();

    if (this.opts.autoplay) {// this.play();
    } else {
      // determine the time interval to display initially before animation begins
      this.goToInit();
    }
  };
  /**
   * @ignore
   * Begins running the internal animation timer.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  Animation.prototype._start = function () {
    var _this = this;

    if (this.timeline) return;
    this._active = true;
    this._timer = setInterval(function () {
      var next = _this._time + _this._increment;

      if (next > _this.to) {
        _this.restart();
      } else {
        _this.goToTime(next);
      }
    }, this._delay * 1000);
  };
  /**
   * @ignore
   * Stops and clears all running timers.
   *
   * @private
   * @memberof Animation
   */


  Animation.prototype._clearTimers = function () {
    if (this._timer) {
      window.clearInterval(this._timer);
    }

    if (this._restartTimer) {
      window.clearTimeout(this._restartTimer);
    }

    this._timer = undefined;
    this._restartTimer = undefined;
  };
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  Animation.prototype._onTimingChange = function () {
    this._updateTiming();

    this._updateTimes();

    this._handleTimingChange();

    if (this.currentTime < this.from) {
      this.goToTime(this.from);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }
  };
  /**
   * @ignore
   * Calculates the step increment to use on each timer interval update based on the animation
   * duration and delay.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  Animation.prototype._updateTiming = function () {
    if (this.to < this.from) return;
    this._increment = (this.to - this.from) / this.duration * this._delay;
  };

  Animation.prototype._updateTimes = function () {
    this._times = this._timesForIntervals();
  };

  Animation.prototype._handleTimingChange = function () {// subclasses should update the animation data for the specified time
  };

  Animation.prototype._updateForTime = function (time) {// subclasses should update the animation data for the specified time
  };
  /**
   * Returns the closest valid animation interval to the specified time.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof Animation
   */


  Animation.prototype._intervalClosestToTime = function (time) {
    var closest = this.from;
    var diff = Math.abs(time - closest);

    if (undefined === this._times) {
      this._updateTimes();
    }

    this._times.forEach(function (t) {
      var tdiff = Math.abs(time - t);

      if (tdiff < diff) {
        diff = tdiff;
        closest = t;
      }
    });

    return Math.round(closest);
  };
  /**
   * Returns an array of step time intervals, in milliseconds, that will be used during playback.
   *
   * @protected
   * @returns {number[]}
   * @memberof Animation
   */


  Animation.prototype._timesForIntervals = function () {
    var _this = this;

    if (this.from === this.to) return []; // const now = new Date().getTime();
    // if (null !== this._startOffset) {
    // 	this.from = now + this._startOffset;
    // 	this._time = this.from;
    // }
    // if (null !== this._endOffset) {
    // 	this.to = now + this._endOffset;
    // }

    var times = [];

    var append = function (time) {
      if (_this.canShow(time) && times.indexOf(time) === -1) {
        times.push(time);
      }
    }; // calculate time intervals needed


    var total = this.opts.intervals;
    var interval = Math.round((this.to - this.from) / (total - 1));
    var lastTime = null;

    for (var i = 0; i < total - 1; i += 1) {
      var t = this.from + interval * i;

      if (i === 0 || t !== lastTime) {
        append(Math.round(t));
        lastTime = t;
      }
    }

    if (times.length > 0) append(this.to);
    this.totalIntervals = times.length;
    return times;
  };
  /**
   * Events that can be triggered by an `Animation` instance.
   */


  Animation.Event = {
    /** Fired when the animation begins playback. */
    PLAY: 'play',

    /** Fired when the animation stops playback. */
    STOP: 'stop',

    /** Fired when the animation advances to a new time. */
    ADVANCE: 'advance',

    /** Fired when the animation is reset. */
    RESET: 'reset',

    /** Fired when the animation start time changes. */
    START_CHANGE: 'start:change',

    /** Fired when the animation end time changes. */
    END_CHANGE: 'end:change',

    /** Fired when the animation starts requesting data required for the animation. */
    LOAD_START: 'load:start',

    /** Fired when the animation is done loading data for the animation. */
    LOAD_DONE: 'load:done',

    /** Fired when an error occurred while loading data for the animation. */
    LOAD_ERROR: 'load:error',

    /** Fired when the loading progress is updated. */
    LOAD_PROGRESS: 'load:progress',

    /** Fired when an image has loaded for an image-based animation. */
    LOAD_IMAGE: 'load:image',

    /** Fired when the image-based animation advances to a new image. */
    ADVANCE_IMAGE: 'advance:image',

    /** Fired when the data-based animation added data for the current interval. */
    DATA_ADD: 'data:add',

    /** Fired when the data-based animation removed data for the current interval. */
    DATA_REMOVE: 'data:remove',

    /** Fired when the data-based animation updated data for the current interval. */
    DATA_UPDATE: 'data:update'
  };
  return Animation;
}(_EventDispatcher.default);

var _default = Animation;
exports.default = _default;
module.exports = exports.default;