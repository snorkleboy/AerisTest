import Timeline from './Timeline';
import EventDispatcher from '../../event/EventDispatcher';
import IAnimatable from '../interfaces/IAnimatable';
/**
 * A data type that represents the configuration options for an animation.
 */
export declare type AnimationOptions = {
    /**
     * Animation identifier.
     */
    key?: string;
    /**
     * Whether the animation is enabled.
     */
    enabled?: boolean;
    /**
     * Start time offset in seconds relative to the current time, e.g. `-5 * 3600` for five hours ago.
     */
    from?: number | string;
    /**
     * End time offset in seconds relative to the current time, e.g. `2 * 3600` for two hours from now.
     */
    to?: number | string;
    /**
     * Duration of the animation in seconds.
     */
    duration?: number;
    /**
     * End delay in seconds, which is the duration of the hold time on the last frame before
     * restarting playback at the beginning.
     */
    endDelay?: number;
    /**
     * Total number of intervals to request data for, specifically for image-related animations.
     */
    intervals?: number;
    /**
     * Whether to begin playing the animation as soon as it's initialized. Default value is `false`.
     */
    autoplay?: boolean;
    /**
     * Refresh duration in seconds. This is typically only used for data-related animations that
     * may need to reload stale data after a determined length of time.
     */
    refresh?: number;
    /**
     * Whether this animation is considered a future animation.
     */
    future?: boolean;
    /**
     * Whether to always show this animation, meaning it will also be visible if the animation is
     * not a future animation and the current playhead is in the future, or the animation is a
     * future animation and the playhead is in the past.
     */
    alwaysShow?: boolean;
};
/**
 * An `Animation` object provides the core functionality necessary for a single time-based animation. The animation
 * is defined by a specified start and end date.
 */
export default class Animation extends EventDispatcher implements IAnimatable {
    totalIntervals: number;
    protected opts: AnimationOptions;
    /**
     * The key associated with the animation, if any.
     *
     * @readonly
     * @type {string}
     * @memberof Animation
     */
    readonly key: string;
    private _timeline;
    /**
     * Parent timeline managing this animation, if any.
     *
     * @type {Timeline}
     * @memberof Animation
     */
    timeline: Timeline;
    /**
     * Starting Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    from: number;
    /**
     * Ending Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    to: number;
    /**
     * Current time value that represents now. This value is used to determine past/future time
     * periods within the full time range.
     *
     * @type {Date}
     * @memberof Animation
     */
    now: Date;
    /**
     * Total time in seconds for the animation to complete. The animation speed will be determined
     * by the duration and total intervals, so a longer duration will result in a slower animation
     * speed for the same number of intervals.
     *
     * @type {number}
     * @memberof Animation
     */
    duration: number;
    /**
     * Delay duration in seconds to hold the last interval of the animation before restarting from
     * the beginning.
     *
     * @type {number}
     * @memberof Animation
     */
    endDelay: number;
    /**
     * Returns the total time, in milliseconds, of the animation based on the start and end timestamps.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    readonly totalTime: number;
    /**
     * Returns the current time of the animation's position in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    readonly currentTime: number;
    /**
     * Returns the current time offset from the beginning of the animation in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    readonly currentOffset: number;
    readonly increment: number;
    /**
     * The animation's current position in the range of `0` to `1.0`, where `0` is the beginning
     * and `1.0` is the end.
     *
     * @type {number}
     * @memberof Animation
     */
    position: number;
    private _startOffset;
    private _endOffset;
    private _now;
    private _elapsed;
    private _time;
    private _offset;
    protected _times: number[];
    private _delay;
    private _increment;
    private _timer;
    private _restartTimer;
    private _paused;
    private _currentInterval;
    private _active;
    private _enabled;
    /**
     * Initializes a new animation instance with the provided configuration.
     *
     * @param {*} [opts=null]
     * @memberof Animation
     */
    constructor(opts?: AnimationOptions);
    /**
     * Sets or returns the configuration value for the specified key path.
     *
     * @param {string} key
     * @param {*} [value]
     * @returns {*}
     * @memberof Animation
     */
    opt(key: string, value?: any): any;
    /**
     * Either plays or stops the animation playback depending on the current state.
     *
     * @memberof Animation
     */
    toggle(): void;
    /**
     * Begins playing the animation if not currently running.
     *
     * @returns
     * @memberof Animation
     */
    play(): void;
    /**
     * Stops playing the animation if currently running.
     *
     * Starting the animation again using `start()` after calling `stop()` will restart the
     * animation from the beginning.
     *
     * @returns
     * @memberof Animation
     */
    stop(): void;
    /**
     * Pauses the animation at the current position.
     *
     * To resume playback from a paused animation's current position, use `resume()`.
     *
     * @memberof Animation
     */
    pause(): void;
    /**
     * Resumes playing the animation from the paused position.
     *
     * @memberof Animation
     */
    resume(): void;
    /**
     * Restarts the animation from the beginning.
     *
     * @memberof Animation
     */
    restart(): void;
    /**
     * Resets the animation to its original state.
     *
     * @memberof Animation
     */
    reset(updateTime?: boolean): void;
    /**
     * Called when an animation is first created, stopped or reset and determines the time interval
     * to display for the static position so that it's closest to the current time as possible.
     *
     * @memberof Animation
     */
    goToInit(): void;
    /**
     * Advances the animation to the specified time.
     *
     * @param {(number | Date)} time The time in milliseconds to update the animation's playhead
     * to, which must be within the `to` and `from` time range.
     * @returns {IAnimatable}
     * @memberof Animation
     */
    goToTime(time: number | Date): IAnimatable;
    /**
     * Returns an array of timestamps defining the interval steps that will be rendered during
     * playback.
     *
     * Total intervals returned will be evenly distributed across the animations time range based
     * on the value for `opts.intervals`.
     *
     * @returns {number[]}
     * @memberof Animation
     */
    neededIntervals(): number[];
    /**
     * Returns the current time interval in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    currentInterval(): number;
    /**
     * Returns the current time interval as a `Date`.
     *
     * @returns {Date}
     * @memberof Animation
     */
    currentDate(): Date;
    /**
     * Returns the start date of the animation.
     *
     * @returns {Date}
     * @memberof Animation
     */
    startDate(): Date;
    /**
     * Sets the start date of the animation.
     *
     * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to
     * update the start time to
     * @returns
     * @memberof Animation
     */
    setStartDate(date: Date | number): this;
    /**
     * Returns the current start offset relative to now, in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    startOffset(): number;
    /**
     * Sets the start date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Animation
     */
    setStartOffset(offset: number): this;
    /**
     * Returns the end date of the animation.
     *
     * @returns {Date}
     * @memberof Animation
     */
    endDate(): Date;
    /**
     * Sets the end date of the animation.
     *
     * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to update
     * the end time to
     * @returns
     * @memberof Animation
     */
    setEndDate(date: Date | number): this;
    /**
     * Returns the current end offset relative to now, in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    endOffset(): number;
    /**
     * Sets the end date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Animation
     */
    setEndOffset(offset: number): this;
    /**
     * Updates the animation's start and end times based on the configured offsets and the current
     * time and date.
     *
     * @memberof Animation
     */
    refresh(): void;
    /**
     * Returns whether or not the animation can animation.
     *
     * This method will return `false` if the animation's `from` and `to` values are the same, or
     * if the animation is disabled.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    canAnimate(): boolean;
    /**
     * Returns whether the animation should be visible for the specified time.
     *
     * This method will return `false` if the animation is specified as a future animation and the
     * `time` is in the past, or if the animation is not specified as a future animation and the
     * `time` is in the future.
     *
     * @param {number} [time]
     * @returns {boolean}
     * @memberof Animation
     */
    canShow(time?: number): boolean;
    /**
     * Sets whether the animation should be enabled.
     *
     * @param {boolean} enable
     * @memberof Animation
     */
    enabled(enable: boolean): void;
    /**
     * Returns whether the animation is currently enabled. Disabled animations would not animate
     * during playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isEnabled(): boolean;
    /**
     * Returns whether the animation should automatically begin playback after being created.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isAutoPlay(): boolean;
    /**
     * Returns whether the animation is ready for playback.
     *
     * Subclasses may override this value to indicate additional data or assets are required to be
     * loaded in order to begin playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isReady(): boolean;
    /**
     * Returns whether the animation is currently loading data or assets required for playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isLoading(): boolean;
    /**
     * Returns whether the animation is currently running.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isAnimating(): boolean;
    /**
     * Returns whether the animation is currently paused.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isPaused(): boolean;
    /**
     * Returns whether the animation has been specified as a future-only animation, meaning it's
     * only valid for time intervals into the future.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isFuture(): boolean;
    /**
     * Returns whether the animation's time range extends into the past.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    containsPast(): boolean;
    /**
     * Returns whether the animation's time range extends into the future.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    containsFuture(): boolean;
    /**
     * Events that can be triggered by an `Animation` instance.
     */
    static Event: {
        /** Fired when the animation begins playback. */
        PLAY: string;
        /** Fired when the animation stops playback. */
        STOP: string;
        /** Fired when the animation advances to a new time. */
        ADVANCE: string;
        /** Fired when the animation is reset. */
        RESET: string;
        /** Fired when the animation start time changes. */
        START_CHANGE: string;
        /** Fired when the animation end time changes. */
        END_CHANGE: string;
        /** Fired when the animation starts requesting data required for the animation. */
        LOAD_START: string;
        /** Fired when the animation is done loading data for the animation. */
        LOAD_DONE: string;
        /** Fired when an error occurred while loading data for the animation. */
        LOAD_ERROR: string;
        /** Fired when the loading progress is updated. */
        LOAD_PROGRESS: string;
        /** Fired when an image has loaded for an image-based animation. */
        LOAD_IMAGE: string;
        /** Fired when the image-based animation advances to a new image. */
        ADVANCE_IMAGE: string;
        /** Fired when the data-based animation added data for the current interval. */
        DATA_ADD: string;
        /** Fired when the data-based animation removed data for the current interval. */
        DATA_REMOVE: string;
        /** Fired when the data-based animation updated data for the current interval. */
        DATA_UPDATE: string;
    };
    /**
     * @ignore
     * @protected
     * @memberof Animation
     */
    protected _startup(): void;
    /**
     * @ignore
     * Begins running the internal animation timer.
     *
     * @private
     * @returns
     * @memberof Animation
     */
    private _start;
    /**
     * @ignore
     * Stops and clears all running timers.
     *
     * @private
     * @memberof Animation
     */
    private _clearTimers;
    /**
     * @ignore
     * @protected
     * @memberof Animation
     */
    protected _onTimingChange(): void;
    /**
     * @ignore
     * Calculates the step increment to use on each timer interval update based on the animation
     * duration and delay.
     *
     * @private
     * @returns
     * @memberof Animation
     */
    private _updateTiming;
    protected _updateTimes(): void;
    protected _handleTimingChange(): void;
    protected _updateForTime(time: number): void;
    /**
     * Returns the closest valid animation interval to the specified time.
     *
     * @protected
     * @param {number} time
     * @returns {number}
     * @memberof Animation
     */
    protected _intervalClosestToTime(time: number): number;
    /**
     * Returns an array of step time intervals, in milliseconds, that will be used during playback.
     *
     * @protected
     * @returns {number[]}
     * @memberof Animation
     */
    protected _timesForIntervals(): number[];
}
