"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _TileAnimation = _interopRequireDefault(require("./TileAnimation"));

var _ImageAnimation = _interopRequireDefault(require("./ImageAnimation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `Timeline` object is a subclass of `Animation` that manages, syncs and controls multiple
 * animations. All animations within are controlled by a single timeline, resulting in animations
 * being synced across time during playback.
 */
var Timeline =
/** @class */
function (_super) {
  __extends(Timeline, _super);
  /**
   * Initializes a new timeline instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof Timeline
   */


  function Timeline(opts) {
    if (opts === void 0) {
      opts = null;
    }

    var _this = _super.call(this, opts) || this;

    _this._loading = false;
    _this._animations = {};
    return _this;
  }

  Object.defineProperty(Timeline.prototype, "animations", {
    /**
     * The animation instances being managed by this timeline.
     *
     * @type {{ [key: string]: Animation }}
     * @memberof Timeline
     */
    get: function () {
      return this._animations || {};
    },
    set: function (value) {
      var _this = this;

      this.stop();
      this._animations = value;

      this._each(function (anim) {
        anim.timeline = _this;
      });
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the timeline animation associated with the specified key, if exists.
   *
   * @param {string} key
   * @returns {Animation}
   * @memberof Timeline
   */

  Timeline.prototype.get = function (key) {
    return this._animations[key];
  };
  /**
   * Adds an animation instance to the timeline for the specified key.
   *
   * @param {string} key
   * @param {Animation} animation
   * @memberof Timeline
   */


  Timeline.prototype.add = function (key, animation) {
    this.stop();
    animation.timeline = this;
    this._animations[key] = animation;
  };
  /**
   * Removes an animation instance from the timeline.
   *
   * @param {Animation} animation
   * @memberof Timeline
   */


  Timeline.prototype.remove = function (animation) {
    var _this = this;

    Object.keys(this._animations).forEach(function (key) {
      var anim = _this._animations[key];

      if (anim === animation) {
        _this.removeBy(key);
      }
    });
  };
  /**
   * Removes an animation instance from the timeline for the specified key.
   *
   * @param {string} key
   * @memberof Timeline
   */


  Timeline.prototype.removeBy = function (key) {
    var anim = this._animations[key];

    if (anim) {
      this.stop();
      anim.timeline = undefined;
    }

    delete this._animations[key];
  };
  /**
   * Begins playing the animation if not currently running.
   *
   * Playback will wait for all internal animation instances to become ready, which means each
   * animation will need to load its required animation data before the timeline can begin
   * playback.
   *
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.play = function () {
    var _this = this;

    var ready = true;
    var waiting = []; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    } // can't start timeline animation if internal animations aren't ready
    // (e.g. need to load data or imagery)


    this._each(function (anim) {
      var showFutureWhileLoading = _this.containsPast() === false;

      if (anim instanceof _TileAnimation.default && anim.isFuture()) {
        anim.showWhenLoading = showFutureWhileLoading;
      } else if (anim instanceof _ImageAnimation.default && anim.isFuture()) {
        anim.showWhenLoading = showFutureWhileLoading;
      }

      if (anim.isEnabled() && !anim.isReady()) {
        // this.trigger(Animation.Event.LOAD_START);
        _this._loading = true;
        ready = false;
        waiting.push(anim);
        anim.once(_Animation.default.Event.LOAD_DONE, function () {
          waiting.splice(waiting.indexOf(anim), 1);

          if (waiting.length === 0) {
            _this.trigger(_Animation.default.Event.LOAD_DONE);

            _this.play();
          }
        }); // calling `play` on an animation starts the data loading process but doesn't
        // actually begin playback since it's tied to an animation timeline

        anim.play();
      }
    });

    if (ready) {
      this._loading = false;
      this.trigger(_Animation.default.Event.LOAD_DONE);

      this._each(function (anim) {
        anim.play();
      });

      _super.prototype.play.call(this);
    } else {
      this.trigger(_Animation.default.Event.LOAD_START);
    }
  };
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof Timeline
   */


  Timeline.prototype.stop = function () {
    this._each(function (anim) {
      anim.stop();
    });

    _super.prototype.stop.call(this);

    if (this._loading) {
      this.trigger(_Animation.default.Event.LOAD_DONE);
    }

    this._loading = false;
  };
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Timeline
   */


  Timeline.prototype.pause = function () {
    this._each(function (anim) {
      anim.pause();
    });

    _super.prototype.pause.call(this);
  };
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Timeline
   */


  Timeline.prototype.restart = function () {
    this._each(function (anim) {
      anim.restart();
    });

    _super.prototype.restart.call(this);
  };
  /**
   * Resets the animation to its original state.
   *
   * @memberof Timeline
   */


  Timeline.prototype.reset = function (updateTime) {
    if (updateTime === void 0) {
      updateTime = false;
    }

    this.stop();
    this._loading = false;

    this._each(function (anim) {
      anim.reset(updateTime);
    });

    _super.prototype.reset.call(this, updateTime);
  };
  /**
   * Returns whether internal animations are currently loading data required for playback.
   *
   * @returns {boolean}
   * @memberof Timeline
   */


  Timeline.prototype.isLoading = function () {
    return this._loading;
  };
  /**
   * Advances the animation to the specified time.
   *
   * @param {*} time
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.goToTime = function (time) {
    this._each(function (anim) {
      anim.goToTime(time);
    });

    return _super.prototype.goToTime.call(this, time);
  };
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.setStartDate = function (date) {
    this._each(function (anim) {
      anim.setStartDate(date);
    });

    return _super.prototype.setStartDate.call(this, date);
  };
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.setStartOffset = function (offset) {
    this._each(function (anim) {
      anim.setStartOffset(offset);
    });

    return _super.prototype.setStartOffset.call(this, offset);
  };
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.setEndDate = function (date) {
    this._each(function (anim) {
      anim.setEndDate(date);
    });

    return _super.prototype.setEndDate.call(this, date);
  };
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  Timeline.prototype.setEndOffset = function (offset) {
    this._each(function (anim) {
      anim.setEndOffset(offset);
    });

    return _super.prototype.setEndOffset.call(this, offset);
  };
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Timeline
   */


  Timeline.prototype.refresh = function () {
    var _this = this;

    _super.prototype.refresh.call(this);

    this._each(function (anim) {
      anim.now = _this.now;
    });
  };
  /**
   * @ignore
   * Performs a function on each internal animation instance.
   *
   * @private
   * @param {(anim: Animation) => void} fn
   * @memberof Timeline
   */


  Timeline.prototype._each = function (fn) {
    var _this = this;

    Object.keys(this.animations).forEach(function (key) {
      var anim = _this._animations[key];
      fn(anim);
    });
  };
  /**
   * @ignore
   * Called when the animation time range has changed.
   *
   * @protected
   * @memberof Timeline
   */


  Timeline.prototype._onTimingChange = function () {
    var _this = this;

    _super.prototype._onTimingChange.call(this);

    this._each(function (anim) {
      anim.from = _this.from;
      anim.to = _this.to;
    });
  };

  return Timeline;
}(_Animation.default);

var _default = Timeline;
exports.default = _default;
module.exports = exports.default;