"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `TileAnimation` object is a subclass of `Animation` that is responsible for loading and
 * managing a series of tile layers required for animation playback.
 */
var TileAnimation =
/** @class */
function (_super) {
  __extends(TileAnimation, _super);
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {TileAnimationOptions} [opts=null]
   * @memberof TileAnimation
   */


  function TileAnimation(opts) {
    if (opts === void 0) {
      opts = null;
    }

    var _this = this;

    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenLoading: true
    }, opts);
    _this = _super.call(this, opts) || this;
    _this._layersByTime = null;
    _this._isReset = false;
    _this._loading = false;
    _this._visible = true;

    _this._startup();

    return _this;
  }

  Object.defineProperty(TileAnimation.prototype, "showWhenLoading", {
    get: function () {
      return this.opts.showWhenLoading;
    },
    set: function (value) {
      this.opts.showWhenLoading = value;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof TileAnimation
   */

  TileAnimation.prototype.dataByTime = function () {
    return this._layersByTime || {};
  };
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof TileAnimation
   */


  TileAnimation.prototype.play = function () {
    if (this.isAnimating()) return; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    }

    if (!this._hasImages() || this._totalImages() < this.totalIntervals) {
      this._load();

      return;
    }

    _super.prototype.play.call(this);
  };
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof TileAnimation
   */


  TileAnimation.prototype.stop = function () {
    _super.prototype.stop.call(this);

    if (this._loading) {
      this.reset();
    }
  };
  /**
   * Resets the animation to its original state.
   *
   * All images that were cached during animation playback will be removed and new images will
   * have to be requested again when playback begins.
   *
   * @memberof TileAnimation
   */


  TileAnimation.prototype.reset = function (updateTime) {
    var _this = this;

    if (updateTime === void 0) {
      updateTime = false;
    }

    _super.prototype.reset.call(this, updateTime);

    this.hide();

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    } // trigger removal of all layers associated with the animation


    if (this._layersByTime) {
      Object.keys(this._layersByTime).forEach(function (key) {
        var time = parseInt(key, 10);

        _this._layersByTime[time].remove();
      });
    }

    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;
    this._layersByTime = null;
    this._currentLayer = null;
  };
  /**
   * Returns whether the animation is ready for playback.
   *
   * A tile animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  TileAnimation.prototype.isReady = function () {
    var needed = this.totalIntervals;

    var loaded = this._totalImages();

    return !this.isLoading() && (this._hasImages() && loaded === needed || needed === 0);
  };
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  TileAnimation.prototype.canAnimate = function () {
    var can = _super.prototype.canAnimate.call(this);

    if (can && this._hasLoaded && !this._hasImages()) {
      can = false;
    } else if (can && !this.isFuture() && !this.containsPast() || this.isFuture() && !this.containsFuture()) {
      can = false;
    }

    return can;
  };
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  TileAnimation.prototype.isLoading = function () {
    return this._loading;
  };
  /**
   * Shows the animation content.
   *
   * @memberof TileAnimation
   */


  TileAnimation.prototype.show = function () {
    this._visible = true;

    if (this._currentLayer) {
      this._currentLayer.show();
    }
  };
  /**
   * Hides the animation content.
   *
   * @memberof TileAnimation
   */


  TileAnimation.prototype.hide = function () {
    this._visible = false;

    if (this._currentLayer) {
      this._currentLayer.hide();
    }
  };
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  TileAnimation.prototype.isVisible = function () {
    if (this._currentLayer) {
      return this._currentLayer.isVisible();
    }

    return true;
  };
  /**
   * @ignore
   * Updates the animation by showing the appropriate tile layer for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof TileAnimation
   */


  TileAnimation.prototype._updateForTime = function (time) {
    var layer = this._frameClosestToTime(time);

    if (layer) {
      if (layer !== this._currentLayer) {
        layer.show();

        if (this._currentLayer) {
          this._currentLayer.hide();
        }

        this._currentLayer = layer;
      }
    }

    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    }
  };
  /**
   * @ignore
   * Returns the tile layer closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {ITileLayer}
   * @memberof TileAnimation
   */


  TileAnimation.prototype._frameClosestToTime = function (time) {
    if (Object.keys(this.dataByTime()).length === 0) {
      return null;
    }

    var times = Object.keys(this._layersByTime).sort().reverse().map(function (o) {
      return parseInt(o, 10);
    }); // eslint-disable-line max-len

    var image = null;
    var closest = this.from;
    var diff = Math.abs(time - closest);
    times.forEach(function (t) {
      var checkDiff = Math.abs(time - t);

      if (checkDiff < diff) {
        diff = checkDiff;
        closest = t;
      }
    });

    if (closest !== this._lastImageTime && this._layersByTime[closest]) {
      image = this._layersByTime[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger(_Animation.default.Event.ADVANCE_IMAGE, {
        time: closest,
        layer: image
      });
    }

    return image;
  };
  /**
   * @ignore
   * Returns whether animation layers are available.
   *
   * @private
   * @returns {boolean}
   * @memberof TileAnimation
   */


  TileAnimation.prototype._hasImages = function () {
    return this._totalImages() > 0;
  };
  /**
   * @ignore
   * Returns the total number of animation layers.
   *
   * @private
   * @returns {number}
   * @memberof TileAnimation
   */


  TileAnimation.prototype._totalImages = function () {
    return Object.keys(this.dataByTime()).length;
  };
  /**
   * @ignore
   * Loads all tile layers based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof TileAnimation
   */


  TileAnimation.prototype._load = function () {
    var _this = this;

    this._isReset = false;
    this._loading = true;
    var times = this.neededIntervals();

    if (!times || times.length === 0) {
      this._hasLoaded = true;
      this.trigger(_Animation.default.Event.LOAD_DONE);
      return;
    }

    if (this._layersByTime) {
      // reduce times by interval images we may already have cached
      Object.keys(this._layersByTime).forEach(function (key) {
        var time = parseInt(key, 10);
        var index = times.indexOf(time);

        if (index !== -1) {
          times.splice(index, 1);
        }
      });
    }

    var onLoadComplete = function () {
      _this._loading = false;
      _this._hasLoaded = true;

      _this.trigger(_Animation.default.Event.LOAD_DONE);

      if (!_this.timeline) {
        _this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    }

    this.trigger(_Animation.default.Event.LOAD_START, {
      times: times
    });
    var loadingInterval = 0;

    var loadNextInterval = function () {
      _this._loadInterval(times[loadingInterval], true, function () {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!_this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (_this.opts.refresh > 0) {
              if (_this._reloadTimer) {
                window.clearTimeout(_this._reloadTimer);
              }

              _this._reloadTimer = setTimeout(function () {
                _this.reset();

                _this._load();
              }, _this.opts.refresh * 1000);
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    loadNextInterval();
  };
  /**
   * @ignore
   * Loads a single tile layer for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof TileAnimation
   */


  TileAnimation.prototype._loadInterval = function (time, cache, callback) {
    var _this = this;

    time = Math.round(time);

    if (!this._layersByTime) {
      this._layersByTime = {};
    } else if (this._layersByTime[time]) {
      // skip the request if we already have a cached image for this interval
      if (callback) {
        callback();
      }

      return;
    }

    var date = new Date(time);

    if (this.provider) {
      this.provider.animationLayerForDate(this, date).then(function (layer) {
        // if animation was reset while loading the interval, then immediately remove it
        if (_this._isReset) {
          layer.remove();
          return;
        }

        if (_this._currentLayer) {
          _this._currentLayer.hide();
        }

        if (_this.showWhenLoading) {
          layer.show();
        }

        _this._currentLayer = layer;
        _this._layersByTime[time] = layer;

        _this.trigger(_Animation.default.Event.LOAD_IMAGE, {
          date: new Date(time),
          layer: layer
        });

        _this.trigger(_Animation.default.Event.LOAD_PROGRESS, {
          time: time,
          loaded: Object.keys(_this._layersByTime).length,
          total: _this.totalIntervals
        });

        if (callback) {
          callback();
        }
      }).catch(function (e) {
        console.error('Failed to load tile animation interval', e); // eslint-disable-line no-console
      });
    }
  };

  return TileAnimation;
}(_Animation.default);

var _default = TileAnimation;
exports.default = _default;
module.exports = exports.default;