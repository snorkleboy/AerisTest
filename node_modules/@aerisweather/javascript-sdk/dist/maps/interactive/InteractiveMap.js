"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _ApiRequest = _interopRequireWildcard(require("../../network/api/ApiRequest"));

var _Timeline = _interopRequireDefault(require("../anim/Timeline"));

var _CoordinateBounds = require("../../geo/CoordinateBounds");

var _strategies = require("./strategies");

var _sources = require("./sources");

var _MapLayerConfig = _interopRequireDefault(require("./MapLayerConfig"));

var _ActivityIndicator = _interopRequireDefault(require("../../ui/ActivityIndicator"));

var _Layers = _interopRequireWildcard(require("../Layers"));

var _MapRequest = _interopRequireWildcard(require("../../network/maps/MapRequest"));

var _utils = require("../utils");

var _utils2 = require("../../utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * An `InteractiveMap` object provides an abstract interface for displaying weather-related data on an interactive map view using
 * one of the supported third-party mapping libraries.
 *
 * @export
 * @class InteractiveMap
 * @extends {EventDispatcher}
 * @implements {IMapStrategyDataSource}
 */
var InteractiveMap =
/** @class */
function (_super) {
  __extends(InteractiveMap, _super);
  /**
   * Initializes a map instance with the specified target and configuration object.
   *
   * @param {*} target Either the `HTMLElement` where you want your map view to be rendered, or
   * an existing map object instance that pertains to one of the supported third-party mapping
   * libraries. If a map object instance if provided, then that instance will be used for
   * rendering weather data instead of the library creating a new instance.
   * @param {InteractiveMapOptions} [opts] Map configuration
   * @param {(map: InteractiveMap) => void} [onInit] Optional callback to be called when the map
   * view has been fully initialized
   * @memberof InteractiveMap
   */


  function InteractiveMap(target, opts, onInit) {
    var _this = _super.call(this) || this;

    _this._ready = false;
    _this._dblClickTimer = null;

    if (!target) {
      throw new Error('[Aeris] Invalid target specified for InteractiveMap, which must be a DOM element or map instance');
    }

    opts = opts || {}; // if a map object was passed instead of an HTMLElement, set the appropriate strategy type

    if (target instanceof HTMLElement === false) {
      if ((0, _utils.isLeaflet)(target)) {
        opts.strategy = 'leaflet';
      } else if ((0, _utils.isMapbox)(target)) {
        opts.strategy = 'mapbox';
      } else if ((0, _utils.isGoogle)(target)) {
        opts.strategy = 'google';
      } else if ((0, _utils.isOpenLayers)(target)) {
        opts.strategy = 'openlayers';
      }
    }

    opts = (0, _utils2.extend)({
      strategy: 'leaflet',
      center: undefined,
      zoom: 7,
      timeline: {
        from: -2 * 3600,
        to: 0,
        intervals: 10
      },
      refresh: 0,
      onInit: undefined,
      reloadOnBoundsChange: true
    }, opts);
    _this._opts = opts;

    if (opts.account) {
      _this.account = opts.account;
    }

    if (opts.strategy === 'mapbox') {
      _this._strategy = new _strategies.MapboxMapStrategy(target, opts);
    } else if (opts.strategy === 'google') {
      _this._strategy = new _strategies.GoogleMapStrategy(target, opts);
    } else if (opts.strategy === 'openlayers') {
      _this._strategy = new _strategies.OpenLayersMapStrategy(target, opts);
    } else {
      _this._strategy = new _strategies.LeafletMapStrategy(target, opts);
    }

    _this._strategy.dataSource = _this;
    _this._timeline = new _Timeline.default((0, _utils2.extend)(opts.timeline, {
      key: 'map-timeline'
    }));
    _this._sources = {};
    _this._layersById = {};
    _this._sourceOrder = {
      tile: []
    };
    _this._layers = new _Layers.default();
    _this._config = new _MapLayerConfig.default(opts.styles);

    var onReady = function () {
      _this._indicator = new _ActivityIndicator.default();

      _this._indicator.appendTo(_this.strategy.$el);

      _this.strategy.$el.addClass('awxjs__ia-map');

      _this._setupEvents();

      _this._ready = true; // add layers if defined in config options

      if (opts.layers) {
        var layers = opts.layers;

        if (!(0, _utils2.isArray)(layers)) {
          layers = layers.split(',');
        }

        layers.forEach(function (layer) {
          if ((0, _utils2.isString)(layer)) {
            _this.addLayer(layer);
          } else if ((0, _utils2.isPlainObject)(layer)) {
            var code = layer.layer,
                options = layer.options;

            _this.addLayer(code, options);
          }
        });
      }

      if (opts.refresh > 0) {
        _this.enableAutoUpdate(opts.refresh);
      }

      if (onInit) onInit(_this);

      _this.trigger(InteractiveMap.Event.LOAD);

      _this.trigger(InteractiveMap.Event.READY);
    };

    _this._layers.fetch().then(function () {
      // strategy may not be ready if it requires loading additional assets at runtime
      if (!_this.strategy.isReady()) {
        _this.strategy.on('ready', function (e) {
          onReady();
        });
      } else {
        onReady();
      }
    });

    return _this;
  }

  Object.defineProperty(InteractiveMap.prototype, "map", {
    /**
     * Returns the underlying third-party map object instance associated with the current map strategy.
     *
     * @readonly
     * @memberof InteractiveMap
     */
    get: function () {
      return this.strategy.map;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMap.prototype, "strategy", {
    /**
     * Returns the current map strategy being used.
     *
     * @readonly
     * @type {IMapStrategy}
     * @memberof InteractiveMap
     */
    get: function () {
      return this._strategy;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMap.prototype, "config", {
    /**
     * Configuration and style manager for the map content sources and associated layers.
     *
     * @readonly
     * @type {MapLayerConfig}
     * @memberof InteractiveMap
     */
    get: function () {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMap.prototype, "timeline", {
    /**
     * Returns the map's animation timeline.
     *
     * @readonly
     * @type {Timeline}
     * @memberof InteractiveMap
     */
    get: function () {
      return this._timeline;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMap.prototype, "account", {
    /**
     * The Aeris account to use when requesting data for the map.
     *
     * @type {Account}
     * @memberof InteractiveMap
     */
    get: function () {
      return this._account;
    },
    set: function (value) {
      this._account = value;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns whether the map is ready, meaning the underlying map view and events have been fully
   * setup and initialized.
   *
   * @returns {boolean}
   * @memberof InteractiveMap
   */

  InteractiveMap.prototype.isReady = function () {
    return this.strategy.isReady();
  };
  /**
   * Returns the map's center coordinate.
   *
   * @returns {ICoordinate}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getCenter = function () {
    return this.strategy.getCenter();
  };
  /**
   * Sets the map's center coordinate.
   *
   * @param {ICoordinate} coord
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.setCenter = function (coord) {
    this.strategy.setCenter(coord);
  };
  /**
   * Returns the current map zoom level.
   *
   * @returns {number}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getZoom = function () {
    return this.strategy.getZoom();
  };
  /**
   * Sets the map zoom level.
   *
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.setZoom = function (zoom) {
    this.strategy.setZoom(zoom);
  };
  /**
   * Sets the map's center coordinate and zoom level.
   *
   * @param {ICoordinate} center
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.setView = function (center, zoom) {
    this.strategy.setView(center, zoom);
  };
  /**
   * Returns the geographical bounds for the visible map region.
   *
   * @returns {ICoordinateBounds}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getBounds = function () {
    return this.strategy.getBounds();
  };
  /**
   * Sets the map bounds to contain the specified geographical bounds.
   *
   * @param {ICoordinateBounds} bounds
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.setBounds = function (bounds) {
    this.strategy.setBounds(bounds);
  };
  /**
   * Sets the map bounds to contain the specified geographical bounds with optional padding insets.
   *
   * @param {ICoordinateBounds} bounds
   * @param {number[]} [padding]
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.fitBounds = function (bounds, padding) {
    padding = padding || [10, 10];
    this.strategy.fitBounds(bounds, padding);
  };
  /**
   * AMP Layers
   */

  /**
   * Adds an AMP layer to the map for the specified layer code.
   *
   * @param {string} layer
   * @param {LayerOptions} [opts]
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.addLayer = function (layer, opts) {
    var _this = this;

    this._checkReady();

    opts = (0, _utils2.cloneDeep)(opts) || {};
    var layerKey = layer.replace(/\:[^,]+/g, '');
    var identifier = (0, _utils2.get)(opts, 'id') || layerKey;
    var source = this.getSourceForId(identifier);

    if (!source && identifier === layerKey) {
      source = this.getSourceForLayer(layerKey);
    }

    if (source) {
      var style = opts.style;

      if (source instanceof _sources.TileSource && style && (0, _utils2.isset)(style.zIndex)) {
        source.setOrder(style.zIndex);
      }

      return this;
    }

    if (opts.style) {
      this.config.setStyle(layer, opts.style);
    }

    if ((0, _Layers.isTile)(layerKey) || opts.type === 'tile') {
      if (!this._layers.exists(layer)) {
        console.warn("[Aeris] Cannot add layer " + layer + ", not a valid AMP layer.");
        return this;
      }

      var isFutureLayer = this._layers.isFuture(layer);

      var isBase = this._layers.isBase(layer);

      var isOverlay = this._layers.isOverlay(layer);

      var offset = (0, _utils2.get)(opts, 'data.offset');
      delete opts.data;
      delete opts.request;
      var tileSource = this.strategy.factory.tileLayer(layer, this.requestForMap(layer), (0, _utils2.extend)(opts, {
        pane: isOverlay ? 'admin' : null,
        time: this.timeline.currentDate(),
        offset: isOverlay || isBase ? 0 : offset,
        future: isFutureLayer,
        alwaysShow: (isFutureLayer ? (0, _utils2.get)(this._opts, 'timeline.alwaysShowFuture') : (0, _utils2.get)(this._opts, 'timeline.alwaysShowPast')) || isOverlay || isBase,
        animation: {
          enabled: !isOverlay && !isBase
        }
      }));
      tileSource.updateVisibility();
      source = tileSource;

      this._sourceOrder.tile.push(layer);
    } else {
      layer = layer.replace(/\:[^,]+/g, '');
      var layerConfig = this.config.getConfig(layer) || {};

      if (layerConfig) {
        opts = (0, _utils2.extend)({}, layerConfig, opts);
      } // setup request for this layer


      var request = void 0;

      if (opts.request && opts.request instanceof _ApiRequest.default) {
        request = opts.request;
        var action = (0, _utils2.get)(opts, 'request.action');
        var params = (0, _utils2.get)(opts, 'request.parameters');

        if (action) {
          request.action(action);
        }

        if (params) {
          request.setParams(params);
        }
      } else {
        request = this.requestForConfig(opts.request);
      }

      if (!request) {
        console.error("No request configured for layer '" + layer + "'. Check the layer configuration and make sure an ApiRequest instance is defined for 'request'.");
      }

      if ((0, _Layers.isText)(layer) || opts.type === 'text') {
        var props = (0, _utils2.get)(opts, 'data.properties');

        if (!props) {
          throw new Error('Value for `data.properties` option is required for text layers');
        } else {
          var timestamp = props.timestamp,
              value = props.value;

          if (!timestamp || !value) {
            throw new Error('Value for `data.properties.timestamp` and `data.properties.value` options are required for text layers');
          }

          if ((0, _utils2.isString)(value)) {
            // add the time and value properties to the list of fields to return from the request
            request.fields("id,loc," + timestamp + "," + value);
          }
        }

        request.plimit(1);
        source = new _sources.TextSource(layer, (0, _utils2.extend)({}, opts, {
          style: {
            marker: this.config.getTextStyle()
          },
          data: {
            service: request,
            properties: props,
            coordinate: function (item) {
              return (0, _utils2.get)(item, 'loc');
            }
          },
          requiresBounds: true,
          animatable: true
        }));
        source.on('data:load', function (e) {
          _this.trigger(InteractiveMap.Event.VECTOR_LOAD, e.data);
        });
      } else if ((0, _Layers.isVector)(layer) || opts.type === 'vector' || opts.type === 'geojson') {
        var klass = opts.type === 'geojson' ? _sources.GeoJsonSource : _sources.VectorSource;
        source = new klass(layer, (0, _utils2.extend)({}, opts, {
          data: {
            service: request,
            coordinate: function (item) {
              return (0, _utils2.get)(item, 'loc');
            }
          },
          requiresBounds: request.getAction() !== _ApiRequest.ApiAction.SEARCH,
          animatable: true
        }));
        source.on('data:load', function (e) {
          _this.trigger(InteractiveMap.Event.VECTOR_LOAD, e.data);
        });
      }
    }

    if (source) {
      this.addSource(source, identifier);
      this._layersById[identifier] = layerKey;
      this.trigger(InteractiveMap.Event.LAYER_ADD, {
        id: identifier,
        layer: layerKey,
        source: source
      });
      var zIndex = (0, _utils2.get)(opts, 'style.zIndex');

      if (source instanceof _sources.TileSource && (0, _utils2.isset)(zIndex)) {
        this.setLayerOrder(layer, zIndex);
      }
    }

    return this;
  };
  /**
   * Adds a series of AMP layers for the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.addLayers = function (layers) {
    var _this = this;

    this._checkReady();

    layers.forEach(function (layer) {
      return _this.addLayer(layer);
    });
    return this;
  };
  /**
   * Removes an AMP layer from the map for the specified layer code.
   *
   * @param {string} layer
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.removeLayer = function (layer) {
    layer = layer.replace(/\:.+$/, '');
    var source = this.getSourceForLayer(layer);

    if (!source) {
      return this;
    }

    this.removeSource(source);
    this.trigger(InteractiveMap.Event.LAYER_REMOVE, {
      layer: layer.replace(/\:[^,]+/g, ''),
      source: source
    });
    return this;
  };
  /**
   * Removes an AMP layer from the map for the specified identifier.
   *
   * @param {string} id
   * @returns
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.removeLayerForId = function (id) {
    var source = this.getSourceForId(id);

    if (!source) {
      return this;
    }

    ;
    var layer = this._layersById[id];
    this.removeSource(source);
    this.trigger(InteractiveMap.Event.LAYER_REMOVE, {
      id: id,
      layer: layer.replace(/\:[^,]+/g, ''),
      source: source
    });
    return this;
  };
  /**
   * Removes a series of AMP layers associated with the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.removeLayers = function (layers) {
    var _this = this;

    layers.forEach(function (layer) {
      return _this.removeLayer(layer);
    });
    return this;
  };
  /**
   * Updates the layer's zIndex order by bringing it to the top of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.bringLayerToFront = function (layer) {
    var _this = this;

    var source = this.getSourceForLayer(layer);
    var index = Object.keys(this._sources).length;

    if (source && source instanceof _sources.TileSource) {
      var order_1 = this._sourceOrder.tile;
      var previous = order_1.indexOf(layer);

      if (previous !== -1) {
        order_1.splice(previous, 1);
        order_1.push(layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this._sources).forEach(function (key) {
        var keySource = _this._sources[key];

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order_1.indexOf(key) + 1);
        }
      });
    }
  };
  /**
   * Updates the layer's zIndex order by sending it to the bottom of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.sendLayerToBack = function (layer) {
    var _this = this;

    var source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource) {
      var order_2 = this._sourceOrder.tile;
      var previous = order_2.indexOf(layer);

      if (previous !== -1) {
        order_2.splice(previous, 1);
        order_2.splice(0, 0, layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this._sources).forEach(function (key) {
        var keySource = _this._sources[key];

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order_2.indexOf(key) + 1);
        }
      });
    }
  };
  /**
   * Updates the layer's zIndex order. This only affects tile and image layers.
   *
   * @param {string} layer
   * @param {number} zIndex
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.setLayerOrder = function (layer, zIndex) {
    var source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource && (0, _utils2.isset)(zIndex)) {
      source.setOrder(zIndex);
    }
  };
  /**
   * Returns the map content source associated with the specified layer code, if any.
   *
   * @param {string} layer
   * @returns {*}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getSourceForLayer = function (layer) {
    return this.getSource(layer);
  };
  /**
   * Returns the map content source associated with the specified identifier, if any.
   *
   * @param {string} id
   * @returns {*}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getSourceForId = function (id) {
    return this.getSource(id);
  };
  /**
   * Instantiates and returns a new map content source instance based on the specified type and
   * configuration options.
   *
   * @param {string} key
   * @param {string} type
   * @param {any} config
   * @returns {any}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.createSource = function (key, type, config) {
    if (type === 'vector') {
      return new _sources.VectorSource(key, config);
    } else if (type === 'geojson') {
      return new _sources.GeoJsonSource(key, config);
    }

    if (type === 'text') {
      return new _sources.TextSource(key, config);
    }

    return null;
  };
  /**
   * Content Sources
   */

  /**
   * Adds a new map content source for the specified layer code.
   *
   * @param {*} source
   * @param {string} key
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.addSource = function (source, key) {
    this._checkReady();

    this._sources[key] = source;
    source.strategy = this.strategy;
    source.enabled = true;
    source.identifier = key;
    this.strategy.addSource(source);

    if ((0, _utils2.has)(source, 'animation') && (0, _utils2.isset)(source.animation)) {
      this.timeline.add(key, source.animation);
    }

    var bounds = this.getBounds();

    if (source instanceof _sources.VectorSource) {
      source.load({
        bounds: bounds,
        from: this.timeline.startDate(),
        to: this.timeline.endDate()
      });
    }

    this.trigger(InteractiveMap.Event.SOURCE_ADD, {
      source: source,
      id: key
    });
    return this;
  };
  /**
   * Removes the map content source associated with the specified layer code.
   *
   * @param {*} source
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.removeSource = function (source) {
    var _this = this;

    source.enabled = false;

    if ((0, _utils2.has)(source, 'animation')) {
      source.animation.reset();
      this.timeline.remove(source.animation);
    }

    this.strategy.removeSource(source);

    if ((0, _utils2.has)(source, 'reset')) {
      source.reset();
    }

    Object.keys(this._sources).forEach(function (key) {
      var item = _this._sources[key];

      if (item === source) {
        delete _this._sources[key];
      }
    });
    this.trigger(InteractiveMap.Event.SOURCE_REMOVE, {
      source: source,
      id: source.key
    });
    return this;
  };
  /**
   * Returns the map content source associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.getSource = function (key) {
    return this._sources[key];
  };
  /**
   * Presents a callout bubble on the map from the specified target. The target can either be an
   * `ICoordinate` object or a native marker object for the current mapping strategy.
   *
   * @param {*} target
   * @param {*} content
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.showCallout = function (target, content) {
    this.strategy.showCallout(target, content);
  };
  /**
   * Updates the map timeline and all active map content sources on the map.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.update = function () {
    this._loadForBounds(true);
  };
  /**
   * Enables auto-updating of map data on regular intervals based on the specified number of
   * seconds.
   *
   * @param {number} interval
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.enableAutoUpdate = function (seconds) {
    var _this = this;

    if (!this._refreshInterval && seconds > 0) {
      seconds = Math.max(seconds, 10);

      if (this._refreshInterval) {
        window.clearInterval(this._refreshInterval);
      }

      this._refreshInterval = setInterval(function () {
        _this._updateTimeline();
      }, seconds * 1000);
    }
  };
  /**
   * Disables auto-updating of map data.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.disableAutoUpdate = function () {
    if (this._refreshInterval) {
      clearInterval(this._refreshInterval);
    }

    this._refreshInterval = null;
  };
  /**
   * @ignore
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._updateTimeline = function () {
    var tl = this.timeline;
    var restartAnimation = false;

    if (tl.isAnimating() || tl.isLoading()) {
      tl.stop();
      tl.reset();
      restartAnimation = true;
    }

    tl.refresh();
    tl.goToInit(); // if animation was previously active/playing before updating, we need to restart it

    if (restartAnimation) {
      tl.play();
    }
  };
  /**
   * @ignore
   * Updates point and shape map content sources by loading new data for the current map bounds.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._loadForBounds = function (force) {
    var _this = this;

    if (force === void 0) {
      force = false;
    }

    var bounds = this.getBounds();
    Object.keys(this._sources).forEach(function (layer) {
      var source = _this.getSource(layer);

      if (source && source instanceof _sources.VectorSource) {
        var vectorSource = source;

        if (vectorSource.requiresBounds || vectorSource.hasData() === false || force) {
          vectorSource.load({
            bounds: bounds,
            from: _this.timeline.startDate(),
            to: _this.timeline.endDate()
          });
        }
      }
    });
  };
  /**
   * @ignore
   * Updates existing map content sources for the specified date and time.
   *
   * @param {(number | Date)} date
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._updateSourcesForDate = function (date) {
    var _this = this;

    if (!(0, _utils2.isDate)(date)) {
      date = new Date(date);
    }

    Object.keys(this._sources).forEach(function (key) {
      var source = _this.getSource(key);

      if (source instanceof _sources.TileSource) {
        source.timestamp = date;
      }
    });
  };
  /**
   * @ignore
   * Called before the map's visible region changes, either from a center or zoom change.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._beforeBoundsChange = function () {
    this.timeline.stop();
  };
  /**
   * @ignore
   * Called after the map's visible region changes, either from a center or zoom change. This method will also request an update
   * for all point and shape layers that are active on the map and require new data for the visible region change.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._afterBoundsChange = function () {
    var reload = this._opts.reloadOnBoundsChange;

    if (reload && this._stateForData) {
      var prev = this._stateForData;
      var prevCenter = this.strategy.coordToPoint(prev.center);
      var newCenter = this.strategy.coordToPoint(this.getCenter());
      var delta = Math.max(Math.abs(prevCenter.x - newCenter.x), Math.abs(prevCenter.y - newCenter.y));
      reload = delta >= 50;

      if (this.getZoom() !== prev.zoom) {
        reload = true;
      }
    } // only reload data for new bounds if change was large enough to prevent reloading
    // with minor adjustments to map panning


    if (reload) {
      this.timeline.reset();

      this._loadForBounds();

      this._stateForData = {
        center: this.getCenter(),
        bounds: this.getBounds(),
        zoom: this.getZoom()
      };
    }
  };
  /**
   * @ignore
   * Sets up the event mappings between the internal strategy and Map instance.
   *
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._setupEvents = function () {
    var _this = this; // need to use a timeout to better handle click vs double-click for mapping strategies
    // that trigger click events for dblclick as well


    this.strategy.on('click', function (e) {
      if (_this._dblClickTimer !== null) {
        return;
      }

      _this._dblClickTimer = setTimeout(function () {
        e.data.coord = (0, _CoordinateBounds.normalize)(e.data.coord);

        _this.trigger(InteractiveMap.Event.CLICK, e.data);

        _this._dblClickTimer = null;
      }, 200);
    });
    this.strategy.on('dblclick', function (e) {
      clearTimeout(_this._dblClickTimer);
      _this._dblClickTimer = null;

      _this.trigger(InteractiveMap.Event.DBL_CLICK, e.data);
    });
    this.strategy.on('resize', function (e) {
      return _this.trigger(InteractiveMap.Event.RESIZE, e.data);
    });
    this.strategy.on('mousedown', function (e) {
      return _this.trigger(InteractiveMap.Event.MOUSE_DOWN, e.data);
    });
    this.strategy.on('mouseup', function (e) {
      return _this.trigger(InteractiveMap.Event.MOUSE_UP, e.data);
    });
    this.strategy.on('mouseover', function (e) {
      return _this.trigger(InteractiveMap.Event.MOUSE_OVER, e.data);
    });
    this.strategy.on('mouseout', function (e) {
      return _this.trigger(InteractiveMap.Event.MOUSE_OUT, e.data);
    });
    this.strategy.on('mousemove', function (e) {
      return _this.trigger(InteractiveMap.Event.MOUSE_MOVE, e.data);
    }); // bounds/zoom events

    this.strategy.on('change:bounds', function (e) {
      _this.trigger(InteractiveMap.Event.CHANGE_BOUNDS, {
        bounds: _this.getBounds()
      });

      _this._afterBoundsChange();
    });
    this.strategy.on('change:center', function (e) {
      return _this.trigger(InteractiveMap.Event.CHANGE_CENTER, {
        center: _this.getCenter()
      });
    });
    this.strategy.on('change:zoom', function (e) {
      return _this.trigger(InteractiveMap.Event.CHANGE_ZOOM, {
        zoom: _this.getZoom()
      });
    });
    this.strategy.on('move', function (e) {
      return _this.trigger(InteractiveMap.Event.MOVE);
    });
    this.strategy.on('move:start', function (e) {
      _this.timeline.pause();

      _this.trigger(InteractiveMap.Event.MOVE_START);

      _this.trigger(InteractiveMap.Event.BEFORE_CHANGE_BOUNDS, {
        bounds: _this.getBounds()
      });
    });
    this.strategy.on('move:end', function (e) {
      _this.timeline.resume();

      _this.trigger(InteractiveMap.Event.MOVE_END);

      _this.trigger(InteractiveMap.Event.AFTER_CHANGE_BOUNDS, {
        bounds: _this.getBounds()
      });
    });
    this.strategy.on('zoom', function (e) {
      return _this.trigger(InteractiveMap.Event.ZOOM);
    });
    this.strategy.on('zoom:start', function (e) {
      _this.timeline.pause();

      _this.trigger(InteractiveMap.Event.ZOOM_START);

      _this.trigger(InteractiveMap.Event.BEFORE_CHANGE_BOUNDS, {
        bounds: _this.getBounds()
      });
    });
    this.strategy.on('zoom:end', function (e) {
      _this.timeline.resume();

      _this.trigger(InteractiveMap.Event.ZOOM_END);

      _this.trigger(InteractiveMap.Event.AFTER_CHANGE_BOUNDS, {
        bounds: _this.getBounds()
      });
    });
    this.strategy.on('idle', function (e) {
      return _this.trigger('idle');
    }); // marker events

    this.strategy.on('marker:click', function (e) {
      return _this.trigger(InteractiveMap.Event.MARKER_CLICK, e.data);
    });
    this.strategy.on('marker:drag', function (e) {
      return _this.trigger(InteractiveMap.Event.MARKER_DRAG, e.data);
    });
    this.strategy.on('marker:dragstart', function (e) {
      return _this.trigger(InteractiveMap.Event.MARKER_DRAG_START, e.data);
    });
    this.strategy.on('marker:dragend', function (e) {
      return _this.trigger(InteractiveMap.Event.MARKER_DRAG_END, e.data);
    });
    this.strategy.on('shape:click', function (e) {
      return _this.trigger(InteractiveMap.Event.SHAPE_CLICK, e.data);
    }); // events

    this.on('before:change:bounds', function () {
      _this._beforeBoundsChange();
    }); // timeline events

    this.timeline.on('play load:start', function () {
      _this.trigger(InteractiveMap.Event.TIMELINE_PLAY, {
        timeline: _this.timeline
      });
    });
    this.timeline.on('stop', function (e) {
      _this.trigger(InteractiveMap.Event.TIMELINE_STOP, {
        timeline: _this.timeline
      });
    });
    this.timeline.on('advance', function (e) {
      if (!_this.timeline.isAnimating()) {
        _this._updateSourcesForDate(e.data.time);
      }

      _this.trigger(InteractiveMap.Event.TIMELINE_CHANGE, (0, _utils2.extend)({
        timeline: _this.timeline
      }, e.data));
    });
    this.timeline.on('start:change end:change', function () {
      _this.timeline.reset();

      _this.update();
    });
    this.timeline.on('load:start', function () {
      _this._indicator.startAnimating();
    });
    this.timeline.on('load:done', function () {
      _this._indicator.stopAnimating();
    });
  };
  /**
   * @ignore
   * @private
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype._checkReady = function () {
    if (!this._ready) {
      var message = "[Aeris] Must wait for an instance of InteractiveMap to be fully\n\t\t\t\tinitialized before calling methods on it. Observe the `load` or `ready` events\n\t\t\t\tthat are triggered when an InteractiveMap instance is fully initialized.";
      throw new Error(message.replace(/\n\s+/g, ' '));
    }
  };
  /**
   * Data Sources
   */

  /**
   * @ignore
   * @param {string} layer
   * @returns {MapRequest}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.requestForMap = function (layer) {
    var request = new _MapRequest.default({
      server: (0, _utils2.get)(this._opts, 'servers.maps'),
      client: {
        id: this.account.id,
        secret: this.account.secret
      }
    }, {
      type: _MapRequest.MapRequestType.TILE
    });
    request.layers(layer);
    return request;
  };
  /**
   * @ignore
   * @param config
   * @returns {ApiRequest}
   * @memberof InteractiveMap
   */


  InteractiveMap.prototype.requestForConfig = function (config) {
    config = config || {};

    if (config.endpoint) {
      var request = new _ApiRequest.default({
        server: (0, _utils2.get)(this._opts, 'servers.api'),
        client: {
          id: this.account.id,
          secret: this.account.secret
        }
      });
      request.endpoint(config.endpoint);

      if (config.action) {
        request.action(config.action);
      }

      if (config.parameters) {
        request.setParams(config.parameters);
      }

      return request;
    }

    return null;
  };
  /**
   * Events that can be triggered by a `Map` instance.
   *
   * @static
   * @memberof InteractiveMap
   */


  InteractiveMap.Event = {
    READY: 'ready',

    /** Fired when the map is initialized once its center and zoom have been set for the first time. */
    LOAD: 'load',

    /** Fired when the user clicks (or taps) the map. */
    CLICK: 'click',

    /** Fired when the user double-clicks (or double-taps) the map. */
    DBL_CLICK: 'dblclick',

    /** Fired when the user pushes the mouse button on the map. */
    MOUSE_DOWN: 'mousedown',

    /** Fired when the user releases the mouse button on the map. */
    MOUSE_UP: 'mouseup',

    /** Fired when the mouse enters the map. */
    MOUSE_OVER: 'mouseover',

    /** Fired when the mouse leaves the map. */
    MOUSE_OUT: 'mouseout',

    /** Fired while the mouse moves over the map. */
    MOUSE_MOVE: 'mousemove',

    /** Fired when the map is resized. */
    RESIZE: 'resize',

    /** Fired when the map viewport changes, either after a bounds/center or zoom change. */
    CHANGE_BOUNDS: 'change:bounds',

    /** Fired when the visible map bounds is about to change, either before a center change, pan or zoom. */
    BEFORE_CHANGE_BOUNDS: 'before:change:bounds',

    /** Fired after the visible map bounds has changed as a result of a center change, pan or zoom. */
    AFTER_CHANGE_BOUNDS: 'after:change:bounds',

    /** Fired when the center of the map viewport has changed. */
    CHANGE_CENTER: 'change:center',

    /** Fired when the zoom level has changed. */
    CHANGE_ZOOM: 'change:zoom',

    /** Fired repeatedly during any movement of the pan, including pan and fly animations. */
    MOVE: 'move',

    /** Fired when the map starts changing (e.g. user starts dragging the map). */
    MOVE_START: 'move:start',

    /** Fired when the center of the map stops changning (e.g. user stopped dragging the map). */
    MOVE_END: 'move:end',

    /** Fired repeatedly during any change in zoom level, including zoom and fly animations. */
    ZOOM: 'zoom',

    /** Fired when the map zoom is about to change (e.g. before zoom animation). */
    ZOOM_START: 'zoom:start',

    /** Fired when the map has changed, after any animations. */
    ZOOM_END: 'zoom:end',

    /** Fired when the user clicks (or taps) a marker on the map. */
    MARKER_CLICK: 'marker:click',

    /** Fired repeatedly while the user drags a marker. */
    MARKER_DRAG: 'marker:drag',

    /** Fired when the user starts dragging a marker. */
    MARKER_DRAG_START: 'marker:dragstart',

    /** Fired when the user stops dragging a marker. */
    MARKER_DRAG_END: 'marker:dragend',

    /** Fired when the user clicks (or taps) a shape on the map. */
    SHAPE_CLICK: 'shape:click',

    /** Fired when the map timeline begins playback. */
    TIMELINE_PLAY: 'timeline:play',

    /** Fired when the map timeline stops playback. */
    TIMELINE_STOP: 'timeline:stop',

    /** Fired when the current time/date for the map timeline changes. */
    TIMELINE_CHANGE: 'timeline:change',

    /** Fired when a layer is added to the map. */
    LAYER_ADD: 'layer:add',

    /** Fired when a layer is removed from the map. */
    LAYER_REMOVE: 'layer:remove',
    LAYER_UPDATE: 'layer:update',

    /** Fired when a content source is added to the map. */
    SOURCE_ADD: 'source:add',

    /** Fired when a content source is removed from the map. */
    SOURCE_REMOVE: 'source:remove',

    /** Fired when a vector content source has loaded new data. */
    VECTOR_LOAD: 'vector:load'
  };
  return InteractiveMap;
}(_EventDispatcher.default);

var _default = InteractiveMap;
exports.default = _default;
module.exports = exports.default;