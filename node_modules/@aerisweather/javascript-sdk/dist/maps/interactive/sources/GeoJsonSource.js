"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _VectorSource = _interopRequireDefault(require("./VectorSource"));

var _FeatureCollection = _interopRequireDefault(require("../../geo/FeatureCollection"));

var Geo = _interopRequireWildcard(require("../../geo"));

var _utils = require("../../../utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

/**
 * `GeoJsonSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view from GeoJSON data.
 */
var GeoJsonSource =
/** @class */
function (_super) {
  __extends(GeoJsonSource, _super);

  function GeoJsonSource() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GeoJsonSource.prototype._process = function (data, parentId) {
    var _this = this;

    data = data || {};
    var markers = {};
    var polygons = {};
    var polylines = {};

    if ((0, _utils.isArray)(data)) {
      if (data[0] && data[0].type === 'FeatureCollection') {
        data = data[0];
      } else {
        data = {
          type: 'FeatureCollection',
          features: data
        };
      }
    } // make sure final data is in the format of FeatureCollection for parsing


    if (data.type === 'Feature') {
      data = {
        type: 'FeatureCollection',
        features: [data]
      };
    } else if (data.type === 'GeometryCollection') {
      data = {
        type: 'FeatureCollection',
        features: (data.geometries || []).map(function (geometry) {
          return {
            type: 'Feature',
            geometry: geometry
          };
        })
      };
    }

    if (!(0, _utils.isset)(data.type)) {
      console.warn("Invalid data provided for GeoJsonSource with key " + this.key + ", not a valid GeoJSON format");
      return;
    }

    var collection = new _FeatureCollection.default(data);
    var _a = this.style,
        markerStyle = _a.marker,
        polygonStyle = _a.polygon,
        polylineStyle = _a.polyline; // convert features to map elements

    var features = collection.features || [];
    features.forEach(function (feature) {
      var geometry = feature.geometry;
      var record = feature.properties || {};
      var group;
      var idKey = (0, _utils.get)(_this._opts, 'data.properties.id');
      var groupKey = (0, _utils.get)(_this._opts, 'data.properties.category'); // update id based on property if defined

      if ((0, _utils.isset)(idKey)) {
        feature.id = (0, _utils.get)(record, idKey);
      } // determine group the feature belongs in if defined


      if ((0, _utils.isset)(groupKey)) {
        group = (0, _utils.get)(record, groupKey);
        var groupData = (0, _utils.set)({}, groupKey, group);

        if (!polygons[group]) {
          polygons[group] = {
            data: __assign({}, groupData, {
              awxjs_source: _this.key
            }),
            polygons: []
          };
        }

        if (!polylines[group]) {
          polylines[group] = {
            data: __assign({}, groupData, {
              awxjs_source: _this.key
            }),
            polylines: []
          };
        }
      }

      record.id = "" + _this.key;

      if (feature.id) {
        record.id = record.id + "-" + feature.id;
      }

      if (geometry instanceof Geo.Point) {
        var style = (0, _utils.isFunction)(markerStyle) ? markerStyle(record) : markerStyle;

        var result = _this._generateMarker(record, geometry.coordinates, style);

        markers[result.id] = result;
      } else if (geometry instanceof Geo.MultiPoint) {
        geometry.coordinates.forEach(function (coord, index) {
          var markerRecord = __assign({}, record, {
            id: record.id + "-" + index
          });

          var style = (0, _utils.isFunction)(markerStyle) ? markerStyle(markerRecord) : markerStyle;

          var result = _this._generateMarker(markerRecord, coord, style);

          markers[result.id] = result;
        });
      } else if (geometry instanceof Geo.LineString) {
        var result = _this._generatePolyline(record, geometry.coordinates, polylineStyle);

        if (group) {
          polylines[group].polylines.push(result);
        } else {
          polylines[result.id] = result;
        }
      } else if (geometry instanceof Geo.MultiLineString) {
        geometry.coordinates.forEach(function (lineCoord, index) {
          var elementRecord = __assign({}, record, {
            id: record.id + "-" + index
          });

          var result = _this._generatePolyline(elementRecord, lineCoord, polylineStyle);

          if (group) {
            polylines[group].polylines.push(result);
          } else {
            polylines[result.id] = result;
          }
        });
      } else if (geometry instanceof Geo.Polygon) {
        var result = _this._generatePolygon(record, geometry, polygonStyle);

        if (group) {
          polygons[group].polygons.push(result);
        } else {
          polygons[result.id] = result;
        }
      } else if (geometry instanceof Geo.MultiPolygon) {
        // geometry.polygons.forEach((polygon, index) => {
        // 	const elementRecord = {...record, id: `${record.id}-${index}`};
        // 	const result = this._generatePolygon(elementRecord, polygon, polygonStyle);
        // 	if (group) {
        // 		polygons[group].polygons.push(result);
        // 	} else {
        // 		polygons[result.id] = result;
        // 	}
        // });
        // const elementRecord = {...record, id: `${record.id}-${index}`};
        var result = _this._generatePolygon(record, geometry, polygonStyle);

        if (group) {
          polygons[group].polygons.push(result);
        } else {
          polygons[result.id] = result;
        }
      }
    });
    return {
      markers: Object.keys(markers).map(function (key) {
        return markers[key];
      }),
      polygons: Object.keys(polygons).map(function (key) {
        return polygons[key];
      }),
      polylines: Object.keys(polylines).map(function (key) {
        return polylines[key];
      })
    };
  };

  return GeoJsonSource;
}(_VectorSource.default);

var _default = GeoJsonSource;
exports.default = _default;
module.exports = exports.default;