import EventDispatcher from '../../../event/EventDispatcher';
import ApiRequest from '../../../network/api/ApiRequest';
import DataAnimation, { IDataAnimationProvider, ITimeRepresentable } from '../../anim/DataAnimation';
import IMapStrategy from '../../interfaces/IMapStrategy';
import { ICoordinate, ICoordinateBounds } from '../../../interfaces/ICoordinate';
import CoordinateBounds from '../../../geo/CoordinateBounds';
import MapElement from '../MapElement';
import { Point, LineString, Polygon, MultiPolygon } from '../../geo';
import VectorStyle from '../style/VectorStyle';
import { MarkerStyle } from '../style/MarkerStyle';
import ShapeStyle, { ShapeStyleProvider } from '../style/ShapeStyle';
import { LayerDataType } from '../types';
import IAnimatableSource from '../../interfaces/IAnimatableSource';
import Geometry from '../../geo/Geometry';
export declare type VectorElement = {
    data?: any;
    renderable: any;
    style: any;
    coord?: ICoordinate;
    bounds?: CoordinateBounds;
    geo?: any;
};
export declare type MarkerData = {
    [key: string]: VectorElement;
};
/**
 * A data type that provides the configuration options for a combined source instance.
 */
export declare type VectorSourceOptions = {
    /**
     * Style associated with the source.
     *
     * @type {VectorStyle}
     */
    style?: VectorStyle;
    /**
     * Provides data configuration options for the data source.
     *
     * @type {{
     *         service?: ApiRequest;
     *         url?: string | ((params: any) => string);
     *         items?: any[];
     *         coordinate?: ((data: any) => ICoordinate);
     *         geometry?: ((data: any) => any);
     *     }}
     */
    data?: {
        /**
         * The ApiRequest instance to use when loading API data for the data source.
         *
         * @type {ApiRequest}
         */
        service?: ApiRequest;
        /**
         * The URL string to request data from for the data source. Value may be a function that
         * receives information about the map, such as current coordinate bounds, to format a URL
         * string before returning.
         *
         * @type {string | (params: any) => string}
         */
        url?: string | ((params: any) => string);
        /**
         * An array of objects to display on the map. If this value is provided, then data will not
         * be requested from a remote source.
         *
         * @type {any[]}
         */
        items?: any[];
        /**
         * Data property key associations.
         *
         * @type {{
         *         root?: string;
         *         id: string;
         *         category?: string;
         *         timestamp?: string | { from: string; to: string; };
         *         path?: string;
         *     }}
         */
        properties?: {
            /**
             * Key path to the root of the node containing the array of data elements (e.g. `features`).
             * If not provided, then the root node is assumed to contain the array of data elements.
             *
             * @type {string}
             */
            root?: string;
            /**
             * Property key path to use for an object's identifier.
             */
            id?: string;
            /**
             * Property key path to use for an object's category or grouping, if any.
             */
            category?: string;
            /**
             * Property key path to use for the object's date/time. Can be a single value or an object
             * providing a range as `from` and `to` property key paths.
             */
            timestamp?: string | {
                from: string;
                to: string;
            };
            points?: string | string[];
            /**
             * Property key path to use for the object's coordinate path that defines the shape.
             */
            path?: string;
        };
        formatter?: ((data: any) => any);
        /**
         * A function that returns the geographical coordinate based on the model object.
         *
         * @type {(data: any) => ICoordinate}
         */
        coordinate?: ((data: any) => ICoordinate);
        /**
         * A function that returns the shape's GeoJSON geometry based on the model object.
         *
         * @type {(data: any) => any}
         */
        geometry?: ((data: any) => any);
        /**
         * A Boolean indicating whether the data's coordinate arrays are reversed from the GeoJSON
         * standard (e.g. `[lat, lon]` instead of the default of `[lon, lat]`).
         */
        reversedCoord?: boolean;
    };
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes. Default value is `false`.
     *
     * @type {boolean}
     */
    requiresBounds?: boolean;
    /**
     * Whether the data source supported animating its data. Default is `false`.
     *
     * @type {boolean}
     */
    animatable?: boolean;
    /**
     * Data auto-update interval, in seconds. Default value is `0`, which disables auto-updating.
     *
     * @type {number}
     */
    refresh?: number;
};
declare type LineSegment = {
    coords: ICoordinate[];
    bounds: ICoordinateBounds;
    data?: any;
};
/**
 * `VectorSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view.
 */
export default class VectorSource extends EventDispatcher implements IAnimatableSource, IDataAnimationProvider {
    /**
     * Identifier associated with the data source.
     *
     * @type {string}
     * @memberof VectorSource
     */
    key: string;
    /**
     * Current markers being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    readonly markers: any;
    /**
     * Returns an object containing all active markers keyed by their unique identifiers.
     *
     * @readonly
     * @type {{ [id: string]: any }}
     * @memberof VectorSource
     */
    readonly markersById: {
        [id: string]: any;
    };
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    readonly polygons: VectorElement[];
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    readonly polylines: VectorElement[];
    /**
     * Current polygons and polylines being managed by the data source.
     *
     * @readonly
     * @type {ShapeDef[]}
     * @memberof VectorSource
     */
    readonly shapes: VectorElement[];
    /**
     * Style configuration provider.
     *
     * @type {VectorStyle}
     * @memberof VectorSource
     */
    style?: VectorStyle;
    /**
     * Map strategy the source is associated with.
     *
     * @type {IMapStrategy}
     * @memberof VectorSource
     */
    strategy: IMapStrategy;
    private _strategy;
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes.
     *
     * Default value is `false`.
     *
     * @type {boolean}
     * @memberof VectorSource
     */
    requiresBounds: boolean;
    /**
     * API service used to request data for the data source.
     *
     * @readonly
     * @type {ApiRequest}
     * @memberof VectorSource
     */
    readonly service: ApiRequest;
    /**
     * Returns the animation associated with the static layer.
     *
     * @readonly
     * @type {DataAnimation}
     * @memberof VectorSource
     */
    readonly animation: DataAnimation;
    /**
     * Whether the data source is enabled.
     *
     * @type {boolean}
     * @memberof VectorSource
     */
    enabled: boolean;
    readonly isLoading: boolean;
    protected _opts: any;
    protected _animation: DataAnimation;
    private _service;
    private _request;
    private _enabled;
    private _loading;
    protected _result: LayerDataType;
    private _markersById;
    protected _polygons: any;
    protected _polylines: any;
    private _refreshTimer;
    private _lastLoadParams;
    private _animatableData;
    private _nonAnimatableData;
    private _visibleBounds;
    private _lastVisibleMapObjects;
    constructor(key: string, opts?: VectorSourceOptions);
    /**
     * Returns whether the source currently has data cached from a previous request.
     *
     * @returns {boolean}
     * @memberof VectorSource
     */
    hasData(): boolean;
    /**
     * Requests data for the layer based on the provided geographical map bounds and date range.
     *
     * @param bounds
     * @param from
     * @param to
     * @returns A Promise containing the resulting marker data objects.
     */
    load(params: {
        [key: string]: any;
    }): Promise<LayerDataType>;
    /**
     * Reloads the data source using the last request parameters.
     *
     * @memberof VectorSource
     */
    reload(params?: any): void;
    /**
     * Resets the data source by removing all map elements and clearing cached data.
     *
     * @memberof VectorSource
     */
    reset(): void;
    /**
     * Reloads the data source by updating the data configuration.
     *
     * @param {*} [data]
     * @memberof VectorSource
     * @see VectorSourceOptions
     */
    update(data?: any): void;
    protected _visibleMapObjects(): {
        markers: any[];
        shapes: any[];
    };
    protected _mapObjects(): any[];
    /**
     * Generates and returns map vector objects from the specified data.
     * @param data
     */
    protected _process(data: any, parentId?: string): LayerDataType;
    protected _processRecord(record: any): any;
    protected _generateMarker(record: any, coord: ICoordinate, style: MarkerStyle): MapElement<Point, MarkerStyle>;
    protected _generatePolygon(record: any, geometry: Polygon | MultiPolygon, style: ShapeStyleProvider): MapElement<Geometry, ShapeStyle>;
    protected _generatePolyline(record: any, points: ICoordinate[], style: ShapeStyleProvider): MapElement<LineString, ShapeStyle>;
    protected _generateLineSegments(points: any): LineSegment[];
    protected _startAutoUpdateIfNeeded(): void;
    protected _stopAutoUpdate(): void;
    /**
     * Animation Provider
     */
    animationData(animation: DataAnimation): Promise<ITimeRepresentable[]>;
}
export {};
