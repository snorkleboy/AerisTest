"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _ApiRequest = require("../../../network/api/ApiRequest");

var _DataAnimation = _interopRequireDefault(require("../../anim/DataAnimation"));

var _CoordinateBounds = _interopRequireDefault(require("../../../geo/CoordinateBounds"));

var _MapElement = _interopRequireDefault(require("../MapElement"));

var _Feature = _interopRequireDefault(require("../../geo/Feature"));

var _geo = require("../../geo");

var _Http = _interopRequireDefault(require("../../../network/Http"));

var _utils = require("../../../utils");

var _strings = require("../../../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

/**
 * `VectorSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view.
 */
var VectorSource =
/** @class */
function (_super) {
  __extends(VectorSource, _super);

  function VectorSource(key, opts) {
    var _this = _super.call(this) || this;
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes.
     *
     * Default value is `false`.
     *
     * @type {boolean}
     * @memberof VectorSource
     */


    _this.requiresBounds = false;
    _this._animatableData = [];
    _this._nonAnimatableData = [];
    _this.key = key;
    _this.enabled = true;
    _this._opts = (0, _utils.extend)({
      data: null,
      requiresBounds: false,
      animatable: false,
      refresh: 0
    }, opts);
    var style = _this._opts.style;

    if (style) {
      _this.style = style;
    } else {
      _this.style = {
        marker: null,
        polygon: null,
        polyline: null
      };
    }

    if (_this._opts.animatable) {
      var groupElements_1 = function (elements) {
        var markers = elements.filter(function (item) {
          return _this.strategy.isMarker(item);
        });
        var shapes = elements.filter(function (item) {
          return _this.strategy.isPolygon(item) || _this.strategy.isPolyline(item);
        });
        return {
          markers: markers,
          shapes: shapes
        };
      };

      var anim_1 = new _DataAnimation.default();
      anim_1.provider = _this;
      anim_1.on('play', function () {
        var _a = groupElements_1(_this._nonAnimatableData),
            markers = _a.markers,
            shapes = _a.shapes;

        if (markers.length > 0) {
          _this.trigger('markers:remove', {
            markers: markers,
            animation: anim_1
          });
        }

        if (shapes.length > 0) {
          _this.trigger('shapes:remove', {
            shapes: shapes,
            animation: anim_1
          });
        }
      });
      anim_1.on('stop', function () {
        var _a = groupElements_1(_this._nonAnimatableData),
            markers = _a.markers,
            shapes = _a.shapes;

        if (markers.length > 0) {
          _this.trigger('markers:add', {
            markers: markers,
            animation: anim_1
          });
        }

        if (shapes.length > 0) {
          _this.trigger('shapes:add', {
            shapes: shapes,
            animation: anim_1
          });
        }
      });
      anim_1.on('reset', function () {
        if (_this.enabled) {
          if (_this.markers) {
            _this.trigger('markers:add', {
              markers: _this.markers,
              animation: anim_1
            });
          }

          if (_this.shapes) {
            _this.trigger('shapes:add', {
              shapes: _this.shapes,
              animation: anim_1
            });
          }
        }

        _this._animatableData = [];
        _this._nonAnimatableData = [];
      });
      anim_1.on('data:add', function (e) {
        var _a = groupElements_1(e.data.items),
            markers = _a.markers,
            shapes = _a.shapes;

        if (markers.length > 0) {
          _this.trigger('markers:add', {
            markers: markers,
            animation: anim_1
          });
        }

        if (shapes.length > 0) {
          _this.trigger('shapes:add', {
            shapes: shapes,
            animation: anim_1
          });
        }
      });
      anim_1.on('data:remove', function (e) {
        var _a = groupElements_1(e.data.items),
            markers = _a.markers,
            shapes = _a.shapes;

        if (markers.length > 0) {
          _this.trigger('markers:remove', {
            markers: markers,
            animation: anim_1
          });
        }

        if (shapes.length > 0) {
          _this.trigger('shapes:remove', {
            shapes: shapes,
            animation: anim_1
          });
        }
      });
      _this._animation = anim_1;
    }

    _this.requiresBounds = (0, _utils.get)(_this._opts, 'requiresBounds');
    _this._service = (0, _utils.get)(_this._opts, 'data.service');
    return _this;
  }

  Object.defineProperty(VectorSource.prototype, "markers", {
    /**
     * Current markers being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get: function () {
      return (0, _utils.get)(this._result, 'markers');
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "markersById", {
    /**
     * Returns an object containing all active markers keyed by their unique identifiers.
     *
     * @readonly
     * @type {{ [id: string]: any }}
     * @memberof VectorSource
     */
    get: function () {
      return this._markersById;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "polygons", {
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get: function () {
      return (0, _utils.get)(this._result, 'polygons');
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "polylines", {
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get: function () {
      return (0, _utils.get)(this._result, 'polylines');
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "shapes", {
    /**
     * Current polygons and polylines being managed by the data source.
     *
     * @readonly
     * @type {ShapeDef[]}
     * @memberof VectorSource
     */
    get: function () {
      var elements = [];

      if (this.polygons) {
        elements = elements.concat(this.polygons);
      }

      if (this.polylines) {
        elements = elements.concat(this.polylines);
      }

      return elements;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "strategy", {
    /**
     * Map strategy the source is associated with.
     *
     * @type {IMapStrategy}
     * @memberof VectorSource
     */
    get: function () {
      return this._strategy;
    },
    set: function (value) {
      var _this = this;

      if (value) {
        this._strategy = value;
        value.on('move:end', function (e) {
          _this._visibleBounds = _CoordinateBounds.default.fromBounds(value.getBounds()); // this._updateVisibleMapObjects();
        });
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "service", {
    /**
     * API service used to request data for the data source.
     *
     * @readonly
     * @type {ApiRequest}
     * @memberof VectorSource
     */
    get: function () {
      return this._service;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "animation", {
    /**
     * Returns the animation associated with the static layer.
     *
     * @readonly
     * @type {DataAnimation}
     * @memberof VectorSource
     */
    get: function () {
      return this._animation;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "enabled", {
    /**
     * Whether the data source is enabled.
     *
     * @type {boolean}
     * @memberof VectorSource
     */
    get: function () {
      return this._enabled;
    },
    set: function (value) {
      this._enabled = value;

      if (value === false) {
        this._stopAutoUpdate();
      } else {
        this._startAutoUpdateIfNeeded();
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(VectorSource.prototype, "isLoading", {
    get: function () {
      return this._loading;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns whether the source currently has data cached from a previous request.
   *
   * @returns {boolean}
   * @memberof VectorSource
   */

  VectorSource.prototype.hasData = function () {
    return !(0, _utils.isEmpty)(this.markers) || !(0, _utils.isEmpty)(this.polygons) || !(0, _utils.isEmpty)(this.polylines);
  };
  /**
   * Requests data for the layer based on the provided geographical map bounds and date range.
   *
   * @param bounds
   * @param from
   * @param to
   * @returns A Promise containing the resulting marker data objects.
   */


  VectorSource.prototype.load = function (params) {
    var _this = this;

    var dataConfig = (0, _utils.get)(this._opts, 'data');

    if (!dataConfig) {
      return new Promise(function (resolve, reject) {
        reject(new Error('Invalid configuration for VectorSource'));
      });
    }

    params = (0, _utils.extend)({}, this._lastLoadParams, params);
    this._lastLoadParams = params;

    if (this._opts.requiresBounds && !(0, _utils.isset)(params.bounds)) {
      throw new Error("[Aeris] Vector source " + this.key + " requires coordinate bounds when loading but bounds were not provided.");
    }

    var bounds = params.bounds,
        from = params.from,
        to = params.to;

    if (bounds) {
      this._visibleBounds = _CoordinateBounds.default.fromBounds(bounds);
    }

    var onLoad = function (data, callback) {
      if (_this.enabled === false) {
        return;
      }

      if (data) {
        // trigger event so existing map objects are removed from map
        var markers = _this.markers;
        var shapes = _this.shapes;

        if (!(0, _utils.isEmpty)(markers)) {
          _this.trigger('markers:remove', {
            markers: markers
          });
        }

        if (!(0, _utils.isEmpty)(shapes)) {
          _this.trigger('shapes:remove', {
            shapes: shapes
          });
        }

        _this._result = _this._process(data); // now add new map objects

        markers = _this.markers;
        shapes = _this.shapes;

        if (!(0, _utils.isEmpty)(markers)) {
          _this.trigger('markers:add', {
            markers: markers
          });
        }

        if (!(0, _utils.isEmpty)(shapes)) {
          _this.trigger('shapes:add', {
            shapes: shapes
          });
        }
      }

      _this._loading = false;

      _this.trigger('data:load', {
        layer: _this.key,
        results: data
      });

      if ((0, _utils.isFunction)(callback)) {
        callback(_this._result, null);
      }
    };

    var onError = function (e, callback) {
      console.error('Vector source request failed', e);

      if (e.stack) {
        console.log(e.stack);
      }

      _this._loading = false;

      _this.trigger('data:error', {
        error: e
      });

      if (callback) {
        callback(null, e);
      }
    };

    var service = dataConfig.service,
        url = dataConfig.url,
        items = dataConfig.items;

    if (items) {
      return new Promise(function (resolve, reject) {
        onLoad(items, function (result, error) {
          if (result) {
            resolve(result);
          } else {
            reject(error);
          }
        });
      });
    }

    var keypath = (0, _utils.get)(this._opts, 'data.properties.root');
    var fetcher;

    if (service) {
      this._service = service;

      fetcher = function (b, from, to, params, callback) {
        var limit = _this.service.param('limit') || 300;
        var sort = _this.service.param('sort') || 'dt:-1'; // set action if not defined already on the service

        var action = _this.service.getAction();

        if (!action) {
          _this.service.action(_ApiRequest.ApiAction.WITHIN);
        } // only set place using bounds if a `within` action


        if (_this.service.getAction() === _ApiRequest.ApiAction.WITHIN) {
          if (b) {
            _this.service.place((0, _strings.toBounds)(b));
          } else {
            return;
          }
        }

        _this.service.from(from).to(to).limit(limit).sort(sort).get().then(function (result) {
          onLoad((0, _utils.isset)(keypath) ? (0, _utils.get)(result.data, keypath) : result.data, callback);
        }).catch(function (e) {
          return onError(e, callback);
        });
      };
    } else if (url) {
      fetcher = function (b, from, to, params, callback) {
        var requestUrl = (0, _utils.isFunction)(url) ? url(params) : url;

        _Http.default.request(requestUrl).then(function (res) {
          onLoad((0, _utils.isset)(keypath) ? (0, _utils.get)(res.data, keypath) : res.data, callback);
        }).catch(function (e) {
          return onError(e, callback);
        });
      };
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)(function (b, from, to, params, callback) {
        fetcher(b, from, to, params, callback);
      }, 1500);
    }

    return new Promise(function (resolve, reject) {
      if (_this._request) {
        _this._loading = true;

        _this._request(bounds, from, to, _this._lastLoadParams, function (results, error) {
          if (error) {
            reject(error);
          } else {
            resolve(results);
          }

          _this._startAutoUpdateIfNeeded();
        });
      } else {
        reject(new Error('Invalid configuration for VectorSource'));
      }
    });
  };
  /**
   * Reloads the data source using the last request parameters.
   *
   * @memberof VectorSource
   */


  VectorSource.prototype.reload = function (params) {
    this.load(params);
  };
  /**
   * Resets the data source by removing all map elements and clearing cached data.
   *
   * @memberof VectorSource
   */


  VectorSource.prototype.reset = function () {
    var markers = this.markers;
    var shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:remove', {
        markers: markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:remove', {
        shapes: shapes
      });
    }

    if (this.animation) {
      this.animation.reset();
    }

    this._loading = false;
    this._result = {};
    this._animatableData = [];
    this._nonAnimatableData = [];
    this.trigger('reset');
  };
  /**
   * Reloads the data source by updating the data configuration.
   *
   * @param {*} [data]
   * @memberof VectorSource
   * @see VectorSourceOptions
   */


  VectorSource.prototype.update = function (data) {
    if (data) {
      this._opts.data = (0, _utils.extend)(this._opts.data, data);
      this._request = null;
    }

    this.reload();
  }; // protected _updateVisibleMapObjects() {
  // 	const { markers: visibleMarkers, shapes: visibleShapes } = this._lastVisibleMapObjects;
  // 	const { markers, shapes } = this._visibleMapObjects();
  // 	console.log('VECTOR', this._visibleBounds, 'VISIBLE', markers, shapes);
  // 	let markersToRemove = visibleMarkers.filter((marker) => markers.indexOf(marker) === -1);
  // 	let shapesToRemove = visibleShapes.filter((shape) => shapes.indexOf(shape) === -1);
  // 	if (!isEmpty(markersToRemove)) {
  // 		this.trigger('markers:remove', { markersToRemove });
  // 	}
  // 	if (!isEmpty(shapesToRemove)) {
  // 		this.trigger('shapes:remove', { shapesToRemove });
  // 	}
  // 	if (!isEmpty(markers)) {
  // 		this.trigger('markers:add', { markers });
  // 	}
  // 	if (!isEmpty(shapes)) {
  // 		this.trigger('shapes:add', { shapes });
  // 	}
  // 	console.log(markersToRemove, shapesToRemove);
  // 	this._lastVisibleMapObjects = { markers, shapes };
  // }


  VectorSource.prototype._visibleMapObjects = function () {
    var _this = this;

    var markers = this.markers;
    var shapes = this.shapes;
    markers = markers.filter(function (marker) {
      var coord = marker.coord;

      if (coord) {
        return _this._visibleBounds.contains(coord);
      }

      return true;
    });
    shapes = shapes.filter(function (shape) {
      var bounds = shape.bounds;

      if (bounds) {
        return _this._visibleBounds.contains(bounds);
      }

      return true;
    });
    return {
      markers: markers,
      shapes: shapes
    };
  };

  VectorSource.prototype._mapObjects = function () {
    var existing = [];

    if (this.polygons) {
      existing = existing.concat(this.polygons);
    }

    if (this.polylines) {
      existing = existing.concat(this.polylines);
    }

    if (existing.length === 0) {
      return null;
    }

    var results = Object.keys(existing).reduce(function (prev, key) {
      return prev.concat(existing.map(function (item) {
        if (item.polygons) {
          return item.polygons.map(function (p) {
            return p.polygon;
          });
        } else if (item.polylines) {
          return item.polylines.map(function (p) {
            return p.polyline;
          });
        } else if (item.polygon) {
          return item.polygon;
        } else if (item.polyline) {
          return item.polyline;
        }

        return item;
      }));
    }, []);
    return (0, _utils.flatten)(results);
  };
  /**
   * Generates and returns map vector objects from the specified data.
   * @param data
   */


  VectorSource.prototype._process = function (data, parentId) {
    var _this = this;

    if (!this.strategy) throw new Error('No map strategy defined for VectorSource but one is required.');
    var dataFormatter = (0, _utils.get)(this._opts, 'data.formatter');

    if (dataFormatter) {
      data = dataFormatter(data);
    }

    var markers = {};
    var polygons = {};
    var polylines = {};

    if ((0, _utils.isPlainObject)(data) && data.type === 'FeatureCollection') {
      console.warn("[Aeris] Data for layer {" + this.key + "} is in GeoJSON format. Use GeoJsonSource (or \"geojson\" type) for this layer instead.");
      return;
    }

    if ((0, _utils.isArray)(data)) {
      var _a = this.style,
          markerStyle_1 = _a.marker,
          polygonStyle_1 = _a.polygon,
          polylineStyle_1 = _a.polyline;
      var coords_1 = [];
      var props_1 = (0, _utils.get)(this._opts, 'data.properties') || {};
      var geomFn_1 = (0, _utils.get)(this._opts, 'data.geometry');
      data.forEach(function (item, index) {
        var id = "awxjs-shape-" + _this.key + "-" + index;
        var category;
        var path;
        var points;

        if (props_1) {
          if (props_1.id) id = (0, _utils.get)(item, props_1.id);

          if (props_1.category && /^\[path\]/.test(props_1.category) === false) {
            category = (0, _utils.get)(item, props_1.category);
          }

          if (props_1.path) path = (0, _utils.get)(item, props_1.path);

          if (markerStyle_1) {
            if (props_1.points) {
              var key = props_1.points;

              if (!parentId && (0, _utils.isArray)(key)) {
                points = [];
                key.forEach(function (k) {
                  var result = (0, _utils.get)(item, k);

                  if (result && (0, _utils.isArray)(result)) {
                    points = points.concat(result);
                  }
                });
              } else {
                points = (0, _utils.get)(item, key);
              }
            } else {
              points = [item];
            }
          }
        } // process markers


        if (points && markerStyle_1) {
          var coordFn_1 = (0, _utils.get)(_this._opts, 'data.coordinate');
          points.forEach(function (item) {
            var record = _this._processRecord(item);

            var loc = record.loc || (coordFn_1 && (0, _utils.isFunction)(coordFn_1) ? coordFn_1(record) : {});

            if (loc) {
              var coord = {
                lat: loc.lat,
                lon: loc.long || loc.lon
              };
              var style_1 = (0, _utils.isFunction)(markerStyle_1) ? markerStyle_1(record) : markerStyle_1;
              record.id = record.id || _this.key + "-" + id + "-" + coord.lat + "_" + coord.lon; // determine if we should add this marker based on the spacing configuration from the style

              var allow_1 = true;

              if (style_1 && style_1.spacing > 0) {
                var point_1 = _this.strategy.coordToPoint(coord);

                coords_1.forEach(function (c) {
                  var p = _this.strategy.coordToPoint(c);

                  var dist = Math.sqrt(Math.pow(point_1.x - p.x, 2) + Math.pow(point_1.y - p.y, 2));

                  if (dist < style_1.spacing) {
                    allow_1 = false;
                  }
                });
              }

              if (allow_1) {
                // convert record to Feature
                var feature = new _Feature.default({
                  type: 'Point',
                  coordinates: [coord.lon, coord.lat]
                });
                feature.properties = record;
                var geometry = feature.geometry;

                if (geometry instanceof _geo.Point) {
                  var result = _this._generateMarker(feature.properties, geometry.coordinates, style_1);

                  markers[record.id] = result;
                  coords_1.push(coord);
                }
              }
            }
          });
        } // process polygons


        if (path && (polygonStyle_1 || polylineStyle_1)) {
          var reversedCoord_1 = (0, _utils.get)(_this._opts, 'data.reversedCoord') || false;
          var paths = path;

          if (!(0, _utils.isArray)(paths)) {
            paths = [paths];
          } else if (paths.length > 0 && (0, _utils.isArray)(paths[0]) && paths[0].length === 2 && (0, _utils.isNumber)(paths[0][0])) {
            // handle case where a path definition is provided as an array of
            // LatLon arrays, in which case we need to wrap it into another array
            // e.g. [[lat, lon], [lat, lon]]
            paths = [paths];
          } // if a geometry function is defined, update the path definition
          // this is used to handle cases where the actual geometry is provided on a subproperty
          // under the layer's primary `path` property key


          if (geomFn_1 && (0, _utils.isFunction)(geomFn_1)) {
            paths = paths.map(function (item) {
              return {
                type: 'Feature',
                properties: item,
                geometry: geomFn_1(item)
              };
            });
          }

          var features = paths.map(function (path, index) {
            // convert an array of coordinates to a Polygon geometry instance
            if ((0, _utils.isArray)(path) && path[0].length === 2) {
              var coords_2 = reversedCoord_1 ? path.map(function (p) {
                return [p[1], p[0]];
              }) : path;
              path = {
                type: 'Polygon',
                coordinates: [coords_2]
              };
            }

            var feature = new _Feature.default(path);
            feature.properties = (0, _utils.extend)({}, item, feature.properties);
            return feature;
          });
          features.forEach(function (feature) {
            var geometry = feature.geometry;
            var groupKeyPath = props_1.category;
            var group = category; // if no parent category, check if the individual path definitions have the category defined

            if (!group && groupKeyPath) {
              groupKeyPath = groupKeyPath.replace(/^\[path\]\./, '');
              group = (0, _utils.get)(feature.properties, groupKeyPath);
            } // convert single geometries to arrays


            if (geometry instanceof _geo.Polygon) {
              geometry = new _geo.MultiPolygon([geometry.toArray(true)]);
            } else if (geometry instanceof _geo.LineString) {
              geometry = new _geo.MultiLineString([geometry.toArray(true)]);
            } // create map elements for each geometry


            if (geometry instanceof _geo.MultiPolygon) {
              var record = __assign({}, feature.properties, {
                id: "" + (feature.properties.id || id)
              });

              var element = _this._generatePolygon(record, geometry, polygonStyle_1);

              if (group) {
                if (!polygons[group]) {
                  var groupData = (0, _utils.set)({}, groupKeyPath, group);
                  polygons[group] = {
                    data: __assign({}, groupData, record, {
                      awxjs_source: _this.key
                    }),
                    polygons: []
                  };
                }

                polygons[group].polygons.push(element);
              } else if (id) {
                polygons[id] = element;
              }
            } else if (geometry instanceof _geo.MultiLineString) {
              geometry.lines.forEach(function (line, idx) {
                var record = __assign({}, feature.properties, {
                  id: (feature.properties.id || id) + "-" + idx
                });

                var element = _this._generatePolyline(record, line.coordinates, polylineStyle_1);

                if (group) {
                  if (!polylines[group]) {
                    var groupData = (0, _utils.set)({}, groupKeyPath, group);
                    polylines[group] = {
                      data: __assign({}, groupData, {
                        awxjs_source: _this.key
                      }),
                      polylines: []
                    };
                  }

                  polylines[group].polylines.push(element);
                } else if (id) {
                  polylines[id] = element;
                }
              });
            }
          });
        } // process polylines


        if (points && polylineStyle_1) {
          var segments = _this._generateLineSegments(points);

          segments.forEach(function (segment) {
            var result = _this._generatePolyline(segment.data, segment.coords, polylineStyle_1);

            polylines[result.id] = result;
          });
        }
      });
    }

    this._markersById = markers;
    this._polygons = polygons;
    this._polylines = polylines;
    return {
      markers: Object.keys(markers).map(function (key) {
        return markers[key];
      }),
      polygons: Object.keys(polygons).map(function (key) {
        return polygons[key];
      }),
      polylines: Object.keys(polylines).map(function (key) {
        return polylines[key];
      })
    };
  };

  VectorSource.prototype._processRecord = function (record) {
    return record;
  };

  VectorSource.prototype._generateMarker = function (record, coord, style) {
    var marker = this.strategy.factory.marker(this.key, {
      lat: coord.lat,
      lon: coord.lon
    }, style);

    var data = __assign({}, record, {
      awxjs_source: this.key
    });

    var element = new _MapElement.default(data, style, marker);
    element.geometry = new _geo.Point([coord.lon, coord.lat]);
    return element;
  };

  VectorSource.prototype._generatePolygon = function (record, geometry, style) {
    var generateDef = function (geometries) {
      return geometries.map(function (geometry) {
        return {
          id: record.id,
          outer: geometry.outer.coordinates,
          inner: geometry.inner.map(function (inner) {
            return inner.coordinates;
          })
        };
      });
    };

    var shapes = [];

    if (geometry instanceof _geo.MultiPolygon) {
      shapes = generateDef(geometry.polygons);
    } else if (geometry instanceof _geo.Polygon) {
      shapes = generateDef([geometry]);
    } // const shape: PolygonDef = {
    // 	id: record.id,
    // 	outer: geometry.outer.coordinates,
    // 	inner: geometry.inner.map((inner) => inner.coordinates)
    // };


    var polygonStyle = (0, _utils.isFunction)(style) ? style(record) : style;
    var polygon = this.strategy.factory.polygon(this.key, shapes, polygonStyle);

    var data = __assign({}, record, {
      awxjs_source: this.key
    });

    var element = new _MapElement.default(data, polygonStyle, polygon);
    element.geometry = geometry;
    return element;
  };

  VectorSource.prototype._generatePolyline = function (record, points, style) {
    var polylineStyle = (0, _utils.isFunction)(style) ? style(record) : style;
    var polyline = this.strategy.factory.polyline(record.id, points, polylineStyle);

    var data = __assign({}, record, {
      awxjs_source: this.key
    });

    var element = new _MapElement.default(data, polylineStyle, polyline); // element.geometry = geometry;

    return element;
  };

  VectorSource.prototype._generateLineSegments = function (points) {
    var coordFn = (0, _utils.get)(this._opts, 'data.coordinate');
    var groupKeyPath = (0, _utils.get)(this._opts, 'data.properties.category'); // determines if segments in the same category should be joined into a single line

    var joinLines = false;
    var segments = [];
    var segmentBounds;
    var segmentCoords = [];
    var segmentData;
    var lastGroup;
    points.forEach(function (point, index) {
      var loc = point.loc || (coordFn && (0, _utils.isFunction)(coordFn) ? coordFn(point) : {});
      var coord = (0, _utils.isEmpty)(loc) && point.lat && point.lon ? point : {
        lat: loc.lat,
        lon: loc.long || loc.lon
      };
      var group = groupKeyPath ? (0, _utils.get)(point, groupKeyPath) : 'none';
      segmentCoords.push(coord);

      if (index === 0) {
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      } else {
        segmentBounds.north = Math.max(segmentBounds.north, coord.lat);
        segmentBounds.south = Math.min(segmentBounds.south, coord.lat);
        segmentBounds.west = Math.min(segmentBounds.west, coord.lon);
        segmentBounds.east = Math.max(segmentBounds.east, coord.lon);
      }

      var resetSegment = true;

      if (joinLines) {
        if (index === 0) {
          segmentData = point;
          resetSegment = true;
        } else if (index === points.length - 1) {
          segments.push({
            coords: segmentCoords,
            data: point,
            bounds: segmentBounds
          });
        } else if (group !== lastGroup) {
          segments.push({
            coords: segmentCoords,
            data: segmentData,
            bounds: segmentBounds
          });
          segmentData = point;
          resetSegment = true;
        }
      } else {
        segments.push({
          coords: segmentCoords,
          data: point,
          bounds: segmentBounds
        });
        resetSegment = true;
      }

      if (resetSegment) {
        segmentCoords = [];
        segmentCoords.push(coord);
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      }

      lastGroup = group;
    });
    return segments;
  };

  VectorSource.prototype._startAutoUpdateIfNeeded = function () {
    var _this = this;

    this._stopAutoUpdate(); // setup update timer if auto-refresh is enabled


    var refresh = (0, _utils.get)(this._opts, 'refresh');

    if (this.enabled && refresh > 0) {
      this._refreshTimer = setTimeout(function () {
        _this.reload();
      }, refresh * 1000);
    }
  };

  VectorSource.prototype._stopAutoUpdate = function () {
    if (this._refreshTimer) {
      clearTimeout(this._refreshTimer);
      this._refreshTimer = null;
    }
  };
  /**
   * Animation Provider
   */


  VectorSource.prototype.animationData = function (animation) {
    var _this = this;

    var processAnimationData = function () {
      // const { markers, shapes } = this._visibleMapObjects();
      var markers = Object.keys(_this.markers).map(function (key) {
        return _this.markers[key];
      });
      var shapes = _this.shapes;
      var result = [];

      if (markers) {
        var elements = markers.map(function (item) {
          var data = item.data,
              renderable = item.renderable,
              style = item.style;

          if (!data || !renderable) {
            return null;
          }

          var timestamp;
          var tsKey = (0, _utils.get)(_this._opts, 'data.properties.timestamp') || 'timestamp';

          if ((0, _utils.has)(data, tsKey)) {
            timestamp = (0, _utils.get)(data, tsKey) * 1000;
          } else {
            _this._nonAnimatableData.push(renderable);
          }

          return {
            timestamp: timestamp,
            renderable: renderable,
            style: style
          };
        }).filter(function (item) {
          return item && Number.isNaN(item.timestamp) === false;
        });

        if (elements) {
          result = result.concat(elements);
        }
      }

      if (shapes) {
        var processShapes_1 = function (shapes) {
          return shapes.map(function (item) {
            var data = item.data,
                renderable = item.renderable,
                style = item.style;

            if (!data) {
              return null;
            }

            var timestamp;
            var tsKey = (0, _utils.get)(_this._opts, 'data.properties.timestamp') || 'timestamp';

            if ((0, _utils.isPlainObject)(tsKey) && tsKey.from) {
              tsKey = tsKey.from;
            }

            if ((0, _utils.has)(data, tsKey)) {
              timestamp = (0, _utils.get)(data, tsKey) * 1000;
            } else {
              _this._nonAnimatableData.push(renderable);
            }

            return {
              timestamp: timestamp,
              renderable: renderable,
              style: style
            };
          }).filter(function (item) {
            return item && Number.isNaN(item.timestamp) === false;
          });
        };

        shapes.forEach(function (shape) {
          var _shapes = shape.polygons;

          if ((0, _utils.isset)(_shapes)) {
            var elements = processShapes_1(_shapes);

            if (elements) {
              result = result.concat(elements);
            }
          } else {
            var elements = processShapes_1([shape]);

            if (elements) {
              result = result.concat(elements);
            }
          }
        });
      }

      _this._animatableData = result;
      return result;
    };

    return new Promise(function (resolve, reject) {
      if (_this.isLoading) {
        _this.on('data:load', function () {
          var result = processAnimationData();
          resolve(result);
        });
      } else if (_this._animatableData && _this._animatableData.length > 0) {
        resolve(_this._animatableData);
      } else if (!_this.markers) {
        resolve(null);
      } else {
        var result = processAnimationData();
        resolve(result);
      }
    });
  };

  return VectorSource;
}(_EventDispatcher.default);

var _default = VectorSource;
exports.default = _default;
module.exports = exports.default;