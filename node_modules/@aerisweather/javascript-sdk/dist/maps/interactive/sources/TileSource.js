"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dateFns = require("date-fns");

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _TileAnimation = _interopRequireDefault(require("../../anim/TileAnimation"));

var _ImageAnimation = _interopRequireDefault(require("../../anim/ImageAnimation"));

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * `TileSource` is an abstract object that is responsible for managing a single tile layer on a map view and providing
 * additional functionality for the layer, such as controlling a layer's opacity and loading and running animations.
 *
 * This class is intended to be subclassed by each supported mapping strategy in order to configure the appropriate underlying
 * layer instance that is added to the strategy's map view.
 */
var TileSource =
/** @class */
function (_super) {
  __extends(TileSource, _super);
  /**
   * Initializes a new tile source instance configured with the specified AMP layer code and tile url template string.
   *
   * @param {string} layer
   * @param {string} url
   * @param {TileSourceOptions} [opts]
   * @memberof TileSource
   */


  function TileSource(key, service, opts) {
    var _this = _super.call(this) || this;

    _this._hidden = false;
    _this.key = key;
    _this.enabled = true;
    opts = (0, _utils.extend)({
      id: undefined,
      type: 'tile',
      subdomains: ['1', '2', '3', '4'],
      time: 0,
      offset: undefined,
      opacity: 1.0,
      future: false,
      alwaysShow: false,
      animation: {
        enabled: true,
        type: 'tile'
      }
    }, opts);

    if (opts.time) {
      if (!(0, _utils.isDate)(opts.time) && (0, _utils.isNumber)(opts.time)) {
        opts.time = new Date(new Date().getTime() + opts.time);
      }
    } // disable animation if a static offset is defined


    if ((0, _utils.isset)(opts.offset)) {
      opts.animation.enabled = false;
    }

    _this.key = key;
    _this._service = service;
    _this._opts = opts;
    var style = opts.style || {};
    _this._opacity = style.opacity || 1;
    var _a = opts.animation,
        animType = _a.type,
        animEnabled = _a.enabled;
    var anim = animType === 'image' ? new _ImageAnimation.default(null, {
      enabled: animEnabled,
      key: key,
      future: opts.future,
      alwaysShow: opts.alwaysShow,
      showWhenStopped: false
    }) : new _TileAnimation.default({
      enabled: animEnabled,
      key: key,
      future: opts.future,
      alwaysShow: opts.alwaysShow
    });
    anim.provider = _this;
    anim.on('reset', function (e) {
      anim.hide();

      _this.updateVisibility();
    });

    if (animType === 'tile') {
      anim.on('load:progress play', function (e) {
        _this.hide();
      });
    }

    _this._animation = anim;
    return _this;
  }

  Object.defineProperty(TileSource.prototype, "identifier", {
    /**
     * Identifier associated with the data source.
     *
     * @type {string}
     * @memberof TileSource
     */
    get: function () {
      return this._opts.id || this.key;
    },
    set: function (value) {
      this._opts.id = value;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TileSource.prototype, "url", {
    /** Tile template URL */
    get: function () {
      return this.service.url();
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TileSource.prototype, "overlay", {
    /** Underlying map layer instance that is added to a map view */
    get: function () {
      return this._overlay;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TileSource.prototype, "timestamp", {
    /** Current timestamp to use when requesting tile data */
    get: function () {
      return this._timestamp;
    },
    set: function (value) {
      this._timestamp = value;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TileSource.prototype, "service", {
    get: function () {
      return this._service;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(TileSource.prototype, "animation", {
    /**
     * Returns the animation associated with the static layer.
     */
    get: function () {
      return this._animation;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the url template string to use for tile requests based on the current timestamp.
   */

  TileSource.prototype.urlTemplate = function () {
    if ((0, _utils.isset)(this._opts.offset)) {
      this.service.offset(("" + this._opts.offset).replace(/\s/g, ''));
    } else {
      // convert date to GMT for timestamp
      var date = new Date(this._timestamp);
      date = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
      this.service.offset((0, _dateFns.format)(date, 'YYYYMMDDHHmm00'));
    }

    return this.service.url();
  };

  TileSource.prototype.isFuture = function () {
    return this._opts.future;
  };

  TileSource.prototype.updateVisibility = function () {
    if (this.canShow()) {
      this.show();
    } else {
      this.hide();
    }
  };

  TileSource.prototype.canShow = function () {
    var now = new Date().getTime();

    var time = this._timestamp.getTime();

    return this._opts.alwaysShow || this.isFuture() && time > now || !this.isFuture() && time <= now;
  };

  TileSource.prototype.isAnimationActive = function () {
    return this.animation && (this.animation.canAnimate() || this.animation.isAnimating());
  };

  TileSource.prototype.isAnimating = function () {
    return this.animation && this.animation.isAnimating();
  };
  /**
   * Shows the tile layer.
   */


  TileSource.prototype.show = function () {
    throw new Error('Implementation must override abstract `show`');
  };
  /**
   * Hides the tile layer.
   */


  TileSource.prototype.hide = function () {
    throw new Error('Implementation must override abstract `hide`');
  };

  TileSource.prototype.remove = function () {
    throw new Error('Implementation must override abstract `remove`');
  };
  /**
   * Returns whether the source is currently visible.
   *
   * @returns {boolean}
   * @memberof TileSource
   */


  TileSource.prototype.isVisible = function () {
    return this._hidden === false;
  };
  /**
   * Updates the opacity of the tile layer.
   * @param value
   */


  TileSource.prototype.setOpacity = function (value) {
    throw new Error('Implementation must override abstract `setOpacity:`');
  };
  /**
   * Updates the z-index order of the tile layer on the parent map view.
   * @param value
   */


  TileSource.prototype.setOrder = function (value) {
    throw new Error('Implementation must override abstract `setOrder:`');
  };

  TileSource.prototype.destroy = function () {
    this._overlay = null;
    this._service = null;
  };
  /** Animation Provider */


  TileSource.prototype.animationLayerForDate = function (animation, date) {
    // throw new Error('Implementation must override abstract `animationLayerForDate:`');
    return null;
  };

  return TileSource;
}(_EventDispatcher.default);

var _default = TileSource;
exports.default = _default;
module.exports = exports.default;