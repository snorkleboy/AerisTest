"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _LeafletTileSource = _interopRequireDefault(require("./sources/LeafletTileSource"));

var _SVG = require("../../../../display/SVG");

var _utils = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class LeafletOverlayFactory
 * @implements {IOverlayFactory}
 * @implements {IPointDataSource}
 */
var LeafletOverlayFactory =
/** @class */
function () {
  function LeafletOverlayFactory() {}
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */


  LeafletOverlayFactory.prototype.tileLayer = function (layer, service, opts) {
    return new _LeafletTileSource.default(layer, service, opts);
  };
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {ICoordinate} coord
   * @param {IMarker} config
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  LeafletOverlayFactory.prototype.marker = function (layer, coord, style) {
    var opts = {};

    if (style) {
      opts.icon = this.markerIcon(style);

      if (style.zIndex) {
        opts.zIndexOffset = style.zIndex;
      }
    }

    var marker = L.marker([coord.lat, coord.lon], opts);

    if (style && style.callout) {
      var content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        var fn = style.callout;
        content = fn();
      }

      var popup = L.popup().setContent(content);
      marker.bindPopup(popup);
    }

    return marker;
  };
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {IMarker} config
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  LeafletOverlayFactory.prototype.markerIcon = function (style) {
    if (style.html) {
      return L.divIcon({
        html: style.html,
        iconSize: style.size,
        className: style.className || ''
      });
    }

    if (style.svg) {
      var _a = style.size || [12, 12],
          width = _a[0],
          height = _a[1];

      return L.divIcon({
        html: _SVG.SVG.draw(width, height, style.svg),
        iconSize: style.size,
        className: style.className || ''
      });
    }

    if (style.icon) {
      var icon = style.icon;
      return L.icon({
        iconUrl: icon.url,
        iconRetinaUrl: icon.retinaUrl,
        iconSize: style.size,
        iconAnchor: icon.anchor,
        className: style.className || ''
      });
    }

    return null;
  };
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  LeafletOverlayFactory.prototype.polygon = function (layer, shapes, style) {
    // generate Leaflet options from config
    var opts;

    if (style) {
      opts = {
        stroke: false,
        fill: false
      };

      if (style.stroke) {
        opts.stroke = true;
        opts.color = style.stroke.color;
        opts.opacity = style.stroke.opacity;
        opts.weight = style.stroke.width;
        opts.lineCap = style.stroke.lineCap;
        opts.lineJoin = style.stroke.lineJoin;
        opts.dashArray = style.stroke.dashArray;
        opts.dashOffset = style.stroke.dashOffset;
      }

      if (style.fill) {
        opts.fill = true;
        opts.fillColor = style.fill.color;
        opts.fillOpacity = style.fill.opacity;
        opts.fillRule = style.fill.rule || 'nonzero';
      }
    }

    var groups = []; // need to combine all polygon coordinate paths into a single grouped array for the multi
    // polygon layer

    shapes.forEach(function (shape) {
      var outer = shape.outer;
      var inner = shape.inner ? shape.inner : [];
      groups.push([outer].concat(inner));
    });
    return L.polygon(groups, opts);
  };

  LeafletOverlayFactory.prototype.polyline = function (layer, points, style) {
    var p = points.map(function (point) {
      return [point.lat, point.lon];
    });
    var opts;

    if (style) {
      opts = {
        stroke: false,
        fill: false
      };

      if (style.stroke) {
        opts = (0, _utils.extend)(opts, {
          stroke: true
        }, style.stroke);
        opts.weight = opts.width;
        delete opts.width;
      }
    }

    return L.polyline(p, opts);
  };

  return LeafletOverlayFactory;
}();

var _default = LeafletOverlayFactory;
exports.default = _default;
module.exports = exports.default;