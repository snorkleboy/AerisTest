"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _utils = require("../../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */


/**
 * `LeafletTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `LeafletMapStrategy`.
 *
 * @export
 * @class LeafletTileSource
 * @extends {TileSource}
 */
var LeafletTileSource =
/** @class */
function (_super) {
  __extends(LeafletTileSource, _super);

  function LeafletTileSource(key, service, opts) {
    var _this = _super.call(this, key, service, opts) || this;

    _this._visible = true;
    _this._exists = false;
    service.offset(0);
    _this._overlay = L.tileLayer(service.url(), _this._opts);
    _this.timestamp = _this._opts.time;
    _this.animation.provider = _this;

    _this._overlay.on('add', function () {
      _this._exists = true;
    }).on('remove', function () {
      _this._exists = false;
    });

    return _this;
  }

  Object.defineProperty(LeafletTileSource.prototype, "overlay", {
    get: function () {
      return this._overlay;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(LeafletTileSource.prototype, "timestamp", {
    set: function (value) {
      value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

      if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
        this._timestamp = value;

        if (this.isAnimating() === false) {
          this.updateVisibility();
        }

        if (this.overlay && this.canShow()) {
          this.overlay.setUrl(this.urlTemplate());
        }
      }
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Shows the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */

  LeafletTileSource.prototype.show = function () {
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
    }
  };
  /**
   * Hides the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */


  LeafletTileSource.prototype.hide = function () {
    console.log(this.key, 'hide');
    this._hidden = true;

    if (this.overlay) {
      this.overlay.setOpacity(0);
    }
  };
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof LeafletTileSource
   */


  LeafletTileSource.prototype.remove = function () {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  };
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  LeafletTileSource.prototype.setOpacity = function (value) {
    this._opacity = value;

    if (this.overlay) {
      this.overlay.setOpacity(value);
    }
  };
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  LeafletTileSource.prototype.setOrder = function (value) {
    this.overlay.setZIndex(value);
  };
  /**
   * Animation Providers
   */


  LeafletTileSource.prototype.animationLayerForDate = function (animation, date) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (_this.dataSource) {
        var source_1 = _this.dataSource.tileLayer(_this.key, date, (0, _utils.extend)({}, _this._opts, {
          animation: {
            enabled: false
          }
        }));

        source_1.setOpacity(_this._opacity);
        source_1.hide();
        source_1.overlay.on('load', function () {
          resolve(source_1);
        });
        source_1.on('layer:remove', function () {
          _this.trigger('layer:remove', {
            layer: source_1.overlay
          });
        });

        _this.trigger('layer:add', {
          layer: source_1.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  };

  return LeafletTileSource;
}(_TileSource.default);

var _default = LeafletTileSource;
exports.default = _default;
module.exports = exports.default;