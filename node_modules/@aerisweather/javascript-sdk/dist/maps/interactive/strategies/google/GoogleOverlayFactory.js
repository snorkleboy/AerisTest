"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GoogleTileSource = _interopRequireDefault(require("./sources/GoogleTileSource"));

var _SVG = require("../../../../display/SVG");

var _utils = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class LeafletOverlayFactory
 * @implements {IOverlayFactory}
 * @implements {IPointDataSource}
 */
var GoogleOverlayFactory =
/** @class */
function () {
  function GoogleOverlayFactory() {}
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */


  GoogleOverlayFactory.prototype.tileLayer = function (layer, service, opts) {
    return new _GoogleTileSource.default(layer, service, opts);
  };
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {ICoordinate} coord
   * @param {MarkerStyle} style
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  GoogleOverlayFactory.prototype.marker = function (layer, coord, style) {
    var opts = {};

    if (style) {
      opts = this.markerIcon(style);

      if (style.zIndex) {
        opts.zIndex = style.zIndex;
      }
    }

    var marker = new google.maps.Marker((0, _utils.extend)({
      position: new google.maps.LatLng(coord.lat, coord.lon),
      optimized: false
    }, opts));

    if (style && style.callout) {
      var content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        var fn = style.callout;
        content = fn();
      } // const popup = L.popup().setContent(content);
      // marker.bindPopup(popup);

    }

    return marker;
  };
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  GoogleOverlayFactory.prototype.markerIcon = function (style) {
    var _a; // html marker not supported, would require custom overlay
    // re: https://humaan.com/blog/custom-html-markers-google-maps/


    if (style.html) {
      console.warn('awxjs - HTML markers are not currently supported with Google Maps');
    }

    if (style.svg) {
      var _b = style.size || [12, 12],
          width_1 = _b[0],
          height_1 = _b[1];

      if (style.svg.text) {
        var textStyle = style.svg.text;

        if ((0, _utils.isArray)(textStyle)) {
          textStyle.forEach(function (styleDef) {
            var _a;

            if (styleDef.autosize) {
              _a = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size), width_1 = _a[0], height_1 = _a[1];
            }
          });
        } else {
          var styleDef = textStyle;

          if (styleDef.autosize) {
            _a = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size), width_1 = _a[0], height_1 = _a[1];
          }
        }
      }

      height_1 += 3;

      var image = _SVG.SVG.draw(width_1, height_1, style.svg);

      return {
        icon: {
          url: "data:image/svg+xml;base64," + btoa(image),
          size: new google.maps.Size(width_1, height_1),
          scaledSize: new google.maps.Size(width_1, height_1),
          anchor: new google.maps.Point(width_1 / 2, height_1 / 2)
        }
      };
    }

    if (style.icon) {
      var icon = style.icon;
      var options = {
        icon: {
          url: icon.url,
          size: new google.maps.Size(style.size[0], style.size[1]),
          scaledSize: new google.maps.Size(style.size[0], style.size[1])
        }
      };

      if (icon.anchor && icon.anchor.length === 2) {
        options.icon.anchor = new google.maps.Point(icon.anchor[0], icon.anchor[1]);
      }

      return options;
    }

    return null;
  };
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  GoogleOverlayFactory.prototype.polygon = function (layer, shapes, style) {
    var opts;

    if (style) {
      opts = {
        stroke: false,
        fill: false
      };

      if (style.stroke) {
        opts.strokeColor = style.stroke.color;
        opts.strokeOpacity = style.stroke.opacity;
        opts.strokeWeight = style.stroke.width; // opts.lineCap = style.stroke.lineCap;
        // opts.lineJoin = style.stroke.lineJoin;
        // opts.dashArray = style.stroke.dashArray;
        // opts.dashOffset = style.stroke.dashOffset;
      } else {
        opts.strokeOpacity = 0;
      }

      if (style.fill) {
        opts.fillColor = style.fill.color;
        opts.fillOpacity = style.fill.opacity; // opts.fillRule = style.fill.rule || 'evenodd';
      } else {
        opts.fillOpacity = 0;
      }
    } // need to combine all polygon coordinate paths into a single grouped array for the multi
    // polygon layer


    var polygons = [];
    shapes.forEach(function (shape) {
      var outer = shape.outer.map(function (coord) {
        return {
          lat: coord.lat,
          lng: coord.lon
        };
      });
      var inner = shape.inner.map(function (polygon) {
        return polygon.map(function (coord) {
          return {
            lat: coord.lat,
            lng: coord.lon
          };
        });
      });
      opts.paths = [outer].concat(inner);
      var p = new google.maps.Polygon(opts);
      polygons.push(p);
    });
    return polygons;
  };

  GoogleOverlayFactory.prototype.polyline = function (layer, points, style) {
    var opts;

    if (style) {
      opts = {
        stroke: false,
        fill: false
      };

      if (style.stroke) {
        opts.strokeColor = style.stroke.color;
        opts.strokeOpacity = style.stroke.opacity;
        opts.strokeWeight = style.stroke.width;
      } else {
        opts.strokeOpacity = 0;
      }
    }

    return new google.maps.Polyline((0, _utils.extend)({}, opts, {
      path: points.map(function (point) {
        return new google.maps.LatLng(point.lat, point.lon);
      })
    }));
  };

  return GoogleOverlayFactory;
}();

var _default = GoogleOverlayFactory;
exports.default = _default;
module.exports = exports.default;