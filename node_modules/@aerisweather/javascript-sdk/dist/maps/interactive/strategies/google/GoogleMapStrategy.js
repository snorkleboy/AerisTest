"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var _GoogleOverlayFactory = _interopRequireDefault(require("./GoogleOverlayFactory"));

var _GoogleTileSource = _interopRequireDefault(require("./sources/GoogleTileSource"));

var _layers = require("./layers");

var _utils = require("../../../../utils");

var _utils2 = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}(); // / <reference path="../../../../../node_modules/@types/googlemaps/index.d.ts" />


// declare global {
// 	const google: any
// }
var mapPanes;
/**
 * A map strategy for working with the third-party Google mapping library.
 *
 * @export
 * @class GoogleMapStrategy
 * @extends {EventDispatcher}
 * @implements {IMapStrategy}
 */

var GoogleMapStrategy =
/** @class */
function (_super) {
  __extends(GoogleMapStrategy, _super);

  function GoogleMapStrategy(target, opts) {
    return _super.call(this, target, (0, _utils.extend)({
      accessToken: null
    }, opts)) || this;
  }

  Object.defineProperty(GoogleMapStrategy.prototype, "$el", {
    get: function () {
      return (0, _DOM.default)(this.map.getDiv());
    },
    enumerable: true,
    configurable: true
  });

  GoogleMapStrategy.prototype.loadDependencies = function () {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        var version = '1.3.1';
        Promise.all([(0, _utils.loadScript)("https://maps.googleapis.com/maps/api/js?key=" + _this.opts.accessToken)]).then(function () {
          resolve();
        });
      } else {
        resolve();
      }
    });
  };

  GoogleMapStrategy.prototype.setupMap = function (target) {
    var _this = this;

    this._factory = new _GoogleOverlayFactory.default();
    this._callout = new google.maps.InfoWindow();
    this._eventMapping = {
      click: 'click',
      dblclick: 'dblclick',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom_changed: 'zoom',
      drag: 'move',
      dragstart: 'move:start',
      dragend: 'move:end'
    }; // set view properties from native map options if defined

    var mapOpts = this.opts.map;

    if (mapOpts) {
      var center = mapOpts.center,
          zoom = mapOpts.zoom;

      if ((0, _utils.isPlainObject)(center) && (0, _utils.isset)(center.lat) && (0, _utils.isset)(center.lng)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: center.lat,
          lon: center.lng
        });
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of google.maps.Map
    // if an google.maps.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isGoogle)(target)) {
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        var obj = target;
        target = obj[0];
      }

      this._map = new google.maps.Map(target, this.opts.map);

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    } // class _DummyOverlayView extends google.maps.OverlayView {
    // 	draw() {
    // 		mapPanes = this.getPanes();
    // 	}
    // }
    // const dummy = new _DummyOverlayView();
    // dummy.setMap(this._map);


    setTimeout(function () {
      _this.trigger('map:ready');
    }, 250);
  };

  GoogleMapStrategy.prototype.setView = function (center, zoom) {
    this.map.setOptions({
      center: {
        lat: center.lat,
        lng: center.lon
      },
      zoom: zoom
    });
  };

  GoogleMapStrategy.prototype.getCenter = function () {
    var coord = this.map.getCenter();
    return {
      lat: coord.lat(),
      lon: coord.lng()
    };
  };

  GoogleMapStrategy.prototype.setCenter = function (coord) {
    this.map.setCenter({
      lat: coord.lat,
      lng: coord.lon
    });
  };

  GoogleMapStrategy.prototype.getZoom = function () {
    return this.map.getZoom();
  };

  GoogleMapStrategy.prototype.setZoom = function (zoom) {
    this.map.setZoom(zoom);
  };

  GoogleMapStrategy.prototype.getBounds = function () {
    var b = this.map.getBounds();

    if (b) {
      var ne = b.getNorthEast();
      var sw = b.getSouthWest();
      return {
        north: ne.lat(),
        west: sw.lng(),
        south: sw.lat(),
        east: ne.lng()
      };
    }

    return null;
  };

  GoogleMapStrategy.prototype.setBounds = function (bounds) {
    var sw = new google.maps.LatLng(bounds.south, bounds.west);
    var ne = new google.maps.LatLng(bounds.north, bounds.east);
    this.map.fitBounds(new google.maps.LatLngBounds(sw, ne), 0);
  };

  GoogleMapStrategy.prototype.fitBounds = function (bounds, padding) {
    if (padding === void 0) {
      padding = [10, 10];
    }

    var sw = new google.maps.LatLng(bounds.south, bounds.west);
    var ne = new google.maps.LatLng(bounds.north, bounds.east);
    var b = new google.maps.LatLngBounds(sw, ne);
    this.map.fitBounds(b, {
      top: padding[1],
      right: padding[0],
      bottom: padding[1],
      left: padding[0]
    });
  };
  /** Sources */


  GoogleMapStrategy.prototype.isTile = function (source) {
    return source instanceof _GoogleTileSource.default;
  };

  GoogleMapStrategy.prototype.isMarker = function (el) {
    return el instanceof google.maps.Marker;
  };

  GoogleMapStrategy.prototype.isPolygon = function (el) {
    return el instanceof google.maps.Polygon;
  };

  GoogleMapStrategy.prototype.isPolyline = function (el) {
    return el instanceof google.maps.Polyline;
  };

  GoogleMapStrategy.prototype.addSource = function (source) {
    _super.prototype.addSource.call(this, source);

    if (source instanceof _GoogleTileSource.default && mapPanes) {
      source.node = mapPanes.mapPane.lastElementChild;
      source.node.id = "awxjs-layer-" + source.identifier;
    }
  };
  /** Overlays */


  GoogleMapStrategy.prototype.addOverlay = function (overlay) {
    if (overlay instanceof _layers.Tile) {
      overlay.addTo(this.map);
    } else if (overlay instanceof google.maps.ImageMapType) {
      this.map.overlayMapTypes.push(overlay);
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(this.map);
    }
  };

  GoogleMapStrategy.prototype.removeOverlay = function (overlay) {
    if (overlay instanceof _layers.Tile) {
      overlay.remove();
    } else if (overlay instanceof google.maps.ImageMapType) {
      var overlayIndex = this.map.overlayMapTypes.getArray().indexOf(overlay);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
      }
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(null);
    }
  };
  /** Markers */


  GoogleMapStrategy.prototype.addMarker = function (marker, data) {
    var _this = this;

    if (this.isMarker(marker)) {
      marker.setMap(this.map);
      marker.addListener('click', function () {
        return _this.trigger('marker:click', {
          data: data,
          marker: marker
        });
      });
    }

    _super.prototype.addMarker.call(this, marker, data);
  };

  GoogleMapStrategy.prototype.removeMarker = function (marker) {
    if (this.isMarker(marker)) {
      // marker.removeListener('click');
      marker.setMap(null);
    }

    _super.prototype.removeMarker.call(this, marker);
  };

  GoogleMapStrategy.prototype.updateMarker = function (marker, options, layer) {
    if (layer === void 0) {
      layer = null;
    }

    if (!options) return;

    if (this.isMarker(marker)) {
      var value = (0, _utils.get)(options, 'data.value');
      var style = (0, _utils.get)(options, 'style') || {};

      if ((0, _utils.isFunction)(style)) {
        style = style({
          value: value
        });
      }

      var opts = this.factory.markerIcon(style);

      if (opts && opts.icon) {
        marker.setIcon(opts.icon);
      }
    }
  };

  GoogleMapStrategy.prototype.bindCalloutToMarker = function (marker, content) {
    var _this = this;

    if (this.isMarker(marker)) {
      marker.addListener('click', function () {
        _this._callout.setContent(content);

        _this._callout.open(_this.map, marker);
      });
    }
  };
  /** Polygons & Polylines */


  GoogleMapStrategy.prototype.addShape = function (shape, data) {
    var _this = this;

    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.setMap(this.map);
      shape.addListener('click', function () {
        return _this.trigger('shape:click', {
          data: data,
          shape: shape
        });
      });
      return;
    }

    _super.prototype.addShape.call(this, shape, data);
  };

  GoogleMapStrategy.prototype.removeShape = function (shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      // shape.off('click');
      shape.setMap(null);
      return;
    }

    _super.prototype.removeShape.call(this, shape);
  };

  GoogleMapStrategy.prototype.showShape = function (shape) {
    this.addShape(shape);
  };

  GoogleMapStrategy.prototype.hideShape = function (shape) {
    this.removeShape(shape);
  };
  /** Conversions */


  GoogleMapStrategy.prototype.coordToPoint = function (coord) {
    // GoogleMaps doesn't account for current zoom level when calling `fromLatLngToPoint`, so
    // we need to calculate the point based on the current zoom ourselves
    var proj = this.map.getProjection();
    var bounds = this.map.getBounds();
    var tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    var bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    var scale = Math.pow(this.map.getZoom(), 2);
    var p = proj.fromLatLngToPoint(new google.maps.LatLng(coord.lat, coord.lon));
    return {
      x: (p.x - bl.x) * scale,
      y: (p.y - tr.y) * scale
    };
  };

  GoogleMapStrategy.prototype.pointToCoord = function (point) {
    // GoogleMaps doesn't account for current zoom level when calling `fromPointToLatLng`, so
    // we need to calculate the coordinate based on the current zoom ourselves
    var proj = this.map.getProjection();
    var bounds = this.map.getBounds();
    var tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    var bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    var scale = Math.pow(this.map.getZoom(), 2);
    var c = proj.fromPointToLatLng(new google.maps.Point(point.x / scale * bl.x, point.y / scale + tr.y));
    return {
      lat: c.lat(),
      lon: c.lng()
    };
  };
  /** Callout */


  GoogleMapStrategy.prototype.showCallout = function (target, content) {
    if ((0, _utils2.isCoordObject)(target)) {
      var popup = new google.maps.InfoWindow({
        position: new google.maps.LatLng(target.lat, target.lon),
        content: content
      });
      popup.open(this.map);
    } else if (this.isMarker(target)) {
      var popup = new google.maps.InfoWindow({
        content: content
      });
      popup.open(this.map, target);
    }
  };

  GoogleMapStrategy.prototype._setupEvents = function () {
    var _this = this;

    _super.prototype._setupEvents.call(this);

    var handleBoundsChange = function () {
      _this.trigger('change:bounds');

      _this.trigger('change:center');
    };

    this.map.addListener('dragend', function (e) {
      handleBoundsChange();
    });
    this.map.addListener('zoom_changed', function (e) {
      handleBoundsChange();

      _this.trigger('change:zoom');
    });
  };

  GoogleMapStrategy.prototype._dataForMapEvent = function (name, event) {
    if (!event) return null;
    var pixel = event.pixel || {
      x: undefined,
      y: undefined
    };
    var data = null;

    switch (name) {
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.latLng.lat(),
            lon: event.latLng.lng()
          },
          point: {
            x: pixel.x,
            y: pixel.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  };

  return GoogleMapStrategy;
}(_MapStrategy.default);

var _default = GoogleMapStrategy;
exports.default = _default;
module.exports = exports.default;