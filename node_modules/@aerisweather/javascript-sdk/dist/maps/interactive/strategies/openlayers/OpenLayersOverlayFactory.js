"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _layers = require("./layers");

var _OpenLayersTileSource = _interopRequireDefault(require("./sources/OpenLayersTileSource"));

var _SVG = require("../../../../display/SVG");

var _Popup = _interopRequireDefault(require("./Popup"));

var _utils = require("../../../../utils");

var _color = require("../../../../utils/color");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class OpenLayersOverlayFactory
 * @implements {IOverlayFactory}
 * @implements {IPointDataSource}
 */
var OpenLayersOverlayFactory =
/** @class */
function () {
  function OpenLayersOverlayFactory() {}
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */


  OpenLayersOverlayFactory.prototype.tileLayer = function (layer, service, opts) {
    return new _OpenLayersTileSource.default(layer, service, opts);
  };
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {ICoordinate} coord
   * @param {MarkerStyle} style
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  OpenLayersOverlayFactory.prototype.marker = function (layer, coord, style) {
    var opts = {};
    var marker = new _layers.Marker(coord, null, style);

    if (style) {
      var icon = this.markerIcon(style);

      if (icon) {
        marker.setStyle(new ol.style.Style({
          image: icon
        }));
      }

      if (style.callout) {
        var content = style.callout;

        if ((0, _utils.isFunction)(style.callout)) {
          var fn = style.callout;
          content = fn();
        } // marker.setPopupContent(content);


        var popup = new _Popup.default(coord);
        popup.setHTML(content);
        marker.setPopup(popup);
      }
    }

    return marker;
  };
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  OpenLayersOverlayFactory.prototype.markerIcon = function (style) {
    var _a;

    if (style.html) {
      console.warn('awxjs - HTML markers are not currently supported with OpenLayers');
    }

    if (style.svg) {
      var _b = style.size || [12, 12],
          width_1 = _b[0],
          height_1 = _b[1];

      if (style.svg.text) {
        var textStyle = style.svg.text;

        if ((0, _utils.isArray)(textStyle)) {
          textStyle.forEach(function (styleDef) {
            var _a;

            if (styleDef.autosize) {
              _a = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size), width_1 = _a[0], height_1 = _a[1];
            }
          });
        } else {
          var styleDef = textStyle;

          if (styleDef.autosize) {
            _a = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size), width_1 = _a[0], height_1 = _a[1];
          }
        }
      }

      height_1 += 3;

      var image = _SVG.SVG.draw(width_1, height_1, style.svg);

      return new ol.style.Icon({
        src: "data:image/svg+xml;base64," + btoa(image),
        size: [width_1, height_1],
        imgSize: [width_1, height_1],
        crossOrigin: 'anonymous'
      });
    }

    if (style.icon) {
      var icon = style.icon;
      return new ol.style.Icon({
        src: icon.url,
        size: style.size,
        imgSize: style.size,
        anchor: icon.anchor,
        crossOrigin: 'anonymous'
      });
    }

    return null;
  };
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  OpenLayersOverlayFactory.prototype.polygon = function (layer, shapes, style) {
    // generate OpenLayers options from config
    var opts;

    if (style) {
      opts = {
        stroke: null,
        fill: null
      };
      opts.id = style.id;

      if (style.stroke) {
        var _a = (0, _color.toRGB)(style.stroke.color),
            r = _a.r,
            g = _a.g,
            b = _a.b;

        opts.stroke = {
          color: "rgba(" + r + ", " + g + ", " + b + ", " + (style.stroke.opacity || 1.0) + ")",
          width: style.stroke.width,
          lineCap: style.stroke.lineCap,
          lineJoin: style.stroke.lineJoin,
          lineDash: style.stroke.dashArray,
          lineDashOffset: style.stroke.dashOffset
        };
      }

      if (style.fill) {
        var _b = (0, _color.toRGB)(style.fill.color),
            r = _b.r,
            g = _b.g,
            b = _b.b;

        opts.fill = {
          color: "rgba(" + r + ", " + g + ", " + b + ", " + (style.fill.opacity || 1.0) + ")"
        };
      }
    }

    shapes.forEach(function (shape) {
      if (!opts.id) {
        opts.id = shape.id;
      }
    });
    return new _layers.Polygon(layer, shapes, opts);
  };

  OpenLayersOverlayFactory.prototype.polyline = function (layer, points, style) {
    var opts;

    if (style) {
      opts = {
        stroke: null,
        fill: null
      };
      opts.id = style.id;

      if (style.stroke) {
        var _a = (0, _color.toRGB)(style.stroke.color),
            r = _a.r,
            g = _a.g,
            b = _a.b;

        opts.stroke = {
          color: "rgba(" + r + ", " + g + ", " + b + ", " + (style.stroke.opacity || 1.0) + ")",
          width: style.stroke.width,
          lineCap: style.stroke.lineCap,
          lineJoin: style.stroke.lineJoin,
          lineDash: style.stroke.dashArray,
          lineDashOffset: style.stroke.dashOffset
        };
      }
    }

    return new _layers.Polyline(layer, points, opts);
  };

  return OpenLayersOverlayFactory;
}();

var _default = OpenLayersOverlayFactory;
exports.default = _default;
module.exports = exports.default;