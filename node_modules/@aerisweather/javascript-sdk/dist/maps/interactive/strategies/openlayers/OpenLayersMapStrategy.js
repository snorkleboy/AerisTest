"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var _Event = _interopRequireDefault(require("../../../../event/Event"));

var _OpenLayersOverlayFactory = _interopRequireDefault(require("./OpenLayersOverlayFactory"));

var _OpenLayersTileSource = _interopRequireDefault(require("./sources/OpenLayersTileSource"));

var _layers = require("./layers");

var _Popup = _interopRequireDefault(require("./Popup"));

var _utils = require("../../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

var _utils2 = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */


/**
 * A map strategy for working with the third-party OpenLayers mapping library.
 *
 * @export
 * @class OpenLayersMapStrategy
 * @extends {MapStrategy}
 * @implements {IMapStrategy}
 */
var OpenLayersMapStrategy =
/** @class */
function (_super) {
  __extends(OpenLayersMapStrategy, _super);

  function OpenLayersMapStrategy() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this._hasLoaded = false;
    _this._clickedMapLayer = false;
    _this._shapeDataById = {};
    return _this;
  }

  Object.defineProperty(OpenLayersMapStrategy.prototype, "$el", {
    get: function () {
      return (0, _DOM.default)(this.map.getTarget());
    },
    enumerable: true,
    configurable: true
  });

  OpenLayersMapStrategy.prototype.loadDependencies = function () {
    return new Promise(function (resolve, reject) {
      if (typeof ol === 'undefined' || typeof ol.Map === 'undefined') {
        var version = '5.3.0';
        Promise.all([(0, _utils.loadStyles)("https://openlayers.org/en/v" + version + "/css/ol.css"), (0, _utils.loadScript)("https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v" + version + "/build/ol.js")]).then(function () {
          resolve();
        });
      } else {
        resolve();
      }
    });
  };

  OpenLayersMapStrategy.prototype.setupMap = function (target) {
    var _this = this;

    this._factory = new _OpenLayersOverlayFactory.default();
    this._eventMapping = {
      // rendercomplete: 'load',
      unload: 'unload',
      resize: 'resize',
      // click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      movestart: 'move:start',
      moveend: 'move:end',
      popupopen: 'popupopen',
      popupclose: 'popupclose'
    };

    _Popup.default.injectStyles(); // set view properties from native map options if defined


    var initView = (0, _utils.get)(this.opts, 'map.view');

    if (initView && initView instanceof ol.View) {
      var _a = ol.proj.toLonLat(initView.getCenter()),
          lon = _a[0],
          lat = _a[1];

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: lat,
          lon: lon
        });
      }

      (0, _utils.set)(this.opts, 'zoom', initView.getZoom());
    } // constructor allows passing either an HTMLElement or instance of ol.Map
    // if ol.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isOpenLayers)(target)) {
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        var obj = target;
        target = obj[0];
      }

      this._map = new ol.Map((0, _utils.extend)({}, this.opts.map, {
        target: target,
        layers: [new ol.layer.Tile({
          source: new ol.source.OSM()
        })]
      }));

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    }

    setTimeout(function () {
      _this.trigger('map:ready');
    }, 250);
  };

  OpenLayersMapStrategy.prototype.setView = function (center, zoom) {
    this.map.setView(new ol.View({
      center: ol.proj.fromLonLat([center.lon, center.lat]),
      zoom: zoom
    }));
  };

  OpenLayersMapStrategy.prototype.getCenter = function () {
    var _a = ol.proj.toLonLat(this.map.getView().getCenter()),
        lon = _a[0],
        lat = _a[1];

    return {
      lat: lat,
      lon: lon
    };
  };

  OpenLayersMapStrategy.prototype.setCenter = function (coord) {
    this.map.getView().setCenter(ol.proj.fromLonLat([coord.lon, coord.lat]));
  };

  OpenLayersMapStrategy.prototype.getZoom = function () {
    return this.map.getView().getZoom();
  };

  OpenLayersMapStrategy.prototype.setZoom = function (zoom) {
    this.map.getView().setZoom(zoom);
  };

  OpenLayersMapStrategy.prototype.getBounds = function () {
    var _a = this.map.getView().calculateExtent(this.map.getSize()),
        minx = _a[0],
        miny = _a[1],
        maxx = _a[2],
        maxy = _a[3];

    var _b = ol.proj.toLonLat([minx, miny]),
        west = _b[0],
        south = _b[1];

    var _c = ol.proj.toLonLat([maxx, maxy]),
        east = _c[0],
        north = _c[1];

    return {
      north: north,
      west: west,
      south: south,
      east: east
    };
  };

  OpenLayersMapStrategy.prototype.setBounds = function (bounds) {
    var _a = ol.proj.fromLonLat([bounds.west, bounds.south]),
        minx = _a[0],
        miny = _a[1];

    var _b = ol.proj.fromLonLat([bounds.east, bounds.north]),
        maxx = _b[0],
        maxy = _b[1];

    var extent = [minx, miny, maxx, maxy];
    this.map.getView().fit(extent);
  };

  OpenLayersMapStrategy.prototype.fitBounds = function (bounds, padding) {
    if (padding === void 0) {
      padding = [10, 10];
    }

    this.setBounds(bounds);
  };
  /** Sources */


  OpenLayersMapStrategy.prototype.isTile = function (source) {
    return source instanceof _OpenLayersTileSource.default;
  };

  OpenLayersMapStrategy.prototype.isMarker = function (el) {
    return el instanceof _layers.Marker;
  };

  OpenLayersMapStrategy.prototype.isPolygon = function (el) {
    return el instanceof _layers.Polygon;
  };

  OpenLayersMapStrategy.prototype.isPolyline = function (el) {
    return el instanceof _layers.Polyline;
  };
  /** Overlays */


  OpenLayersMapStrategy.prototype.addOverlay = function (overlay, index) {
    if (overlay instanceof _layers.Tile) {
      overlay.addTo(this.map, index);
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      if (index) {
        this.map.getLayers().insertAt(index, overlay);
      } else {
        this.map.addLayer(overlay);
      }
    }
  };

  OpenLayersMapStrategy.prototype.removeOverlay = function (overlay) {
    if (overlay instanceof _layers.Tile) {
      overlay.remove();
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      this.map.removeLayer(overlay);
    }
  };
  /** Markers */


  OpenLayersMapStrategy.prototype.addMarker = function (marker, data) {
    var _this = this;

    var popup;

    if (this.isMarker(marker)) {
      popup = marker.popup;
      marker = marker.layer;
    }

    if (marker instanceof ol.layer.Vector) {
      if (!this.containsLayer(marker)) {
        this.map.addLayer(marker);
        marker.on('marker:click', function () {
          _this.trigger('marker:click', {
            data: data,
            marker: marker
          });

          if (popup) {
            if (_this._activePopup) {
              _this._activePopup.remove();
            }

            popup.addTo(_this.map);
            _this._activePopup = popup;
          }
        });
      }

      return;
    }

    _super.prototype.addMarker.call(this, marker, data);
  };

  OpenLayersMapStrategy.prototype.removeMarker = function (marker) {
    if (this.isMarker(marker)) {
      marker = marker.layer;
    }

    if (marker instanceof ol.layer.Vector) {
      marker.un('click');
      this.map.removeLayer(marker);
    }

    _super.prototype.removeMarker.call(this, marker);
  };

  OpenLayersMapStrategy.prototype.updateMarker = function (marker, options, layer) {
    if (layer === void 0) {
      layer = null;
    }

    if (!options) return;

    if (this.isMarker(marker)) {
      var value = (0, _utils.get)(options, 'data.value');
      var style = (0, _utils.get)(options, 'style') || {};

      if ((0, _utils.isFunction)(style)) {
        style = style({
          value: value
        });
      }

      var icon = this.factory.markerIcon(style);

      if (icon) {
        marker.setStyle(new ol.style.Style({
          image: icon
        }));
      }
    }

    _super.prototype.updateMarker.call(this, marker, options, layer);
  };

  OpenLayersMapStrategy.prototype.showMarkers = function (markers, show) {
    var _this = this;

    markers.forEach(function (marker) {
      if (_this.isMarker(marker)) {
        marker = marker.layer;
      }

      if (marker instanceof ol.layer.Vector) {
        marker.setVisible(show);
      }
    });
  };
  /** Polygons & Polylines */


  OpenLayersMapStrategy.prototype.addShape = function (shape, data) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      if (!this.containsLayer(shape.layer)) {
        // need to insert shapes below markers which use Point geometries
        // so grab the index of the first Point layer on the map to use for inserting the shape
        var index = this.getIndexBoundForGeom('point', true);
        shape.addTo(this.map, index);
        this._shapeDataById[shape.id] = data;
      }

      return;
    }

    _super.prototype.addShape.call(this, shape, data);
  };

  OpenLayersMapStrategy.prototype.removeShape = function (shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.off('click');
      shape.remove();
      return;
    }

    _super.prototype.removeShape.call(this, shape);
  };

  OpenLayersMapStrategy.prototype.showShape = function (shape) {
    this.addShape(shape);
  };

  OpenLayersMapStrategy.prototype.hideShape = function (shape) {
    this.removeShape(shape);
  };

  OpenLayersMapStrategy.prototype.containsLayer = function (layer) {
    var existing = this.map.getLayers().getArray();
    return existing.indexOf(layer) !== -1;
  };
  /** Conversions */


  OpenLayersMapStrategy.prototype.coordToPoint = function (coord) {
    var point = this.map.getPixelFromCoordinate(ol.proj.fromLonLat([coord.lon, coord.lat]));

    if (point) {
      var x = point[0],
          y = point[1];
      return {
        x: x,
        y: y
      };
    }

    return null;
  };

  OpenLayersMapStrategy.prototype.pointToCoord = function (point) {
    var coord = this.map.getCoordinateFromPixel(ol.proj.toLonLat([point.x, point.y]));

    if (coord) {
      var lon = coord[0],
          lat = coord[1];
      return {
        lat: lat,
        lon: lon
      };
    }

    return null;
  };

  OpenLayersMapStrategy.prototype.getInsertIndex = function (layer, positionOffset) {
    var existing = this.map.getLayers().getArray();
    var index = existing.indexOf(layer);

    if (index !== -1) {
      return Math.max(0, index + positionOffset);
    }

    return existing.length;
  };

  OpenLayersMapStrategy.prototype.getIndexBoundForGeom = function (type, min) {
    if (min === void 0) {
      min = false;
    }

    var index = 0;
    var existing = this.map.getLayers().getArray();
    existing.forEach(function (layer, i) {
      if (layer instanceof ol.layer.Vector) {
        var source = layer.getSource();
        var features = source.getFeatures();

        if (features && features.length > 0) {
          var geom = features[0].getGeometry();

          if (geom.getType().toLowerCase() === type.toLowerCase()) {
            index = min ? Math.min(index, i) : Math.max(index, i);
          }
        }
      }
    });
    return Math.max(1, index);
  };
  /** Callout */


  OpenLayersMapStrategy.prototype.showCallout = function (target, content) {
    var popup = new _Popup.default();
    popup.setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setCoordinate(target);
    } else if (this.isMarker(target)) {
      popup.setCoordinate(target.coordinate);
    } else if (target instanceof ol.Feature) {
      var geom = target.getGeometry();

      if (geom instanceof ol.geom.Point) {
        var _a = geom.getCoordinates(),
            lon = _a[0],
            lat = _a[1];

        popup.setCoordinate({
          lat: lat,
          lon: lon
        });
      }
    }

    if (this._activePopup) {
      this._activePopup.remove();
    }

    this._activePopup = popup;
    popup.addTo(this.map);
  };

  OpenLayersMapStrategy.prototype._setupEvents = function () {
    var _this = this;

    _super.prototype._setupEvents.call(this);

    this.map.on('rendercomplete', function () {
      if (_this._hasLoaded === false) {
        _this._hasLoaded = true;

        _this.trigger('load');
      }
    });
    this.map.on('click', function (e) {
      // let selectedLayer: ol.layer.Layer;
      // trigger custom events for markers and shape selections in order to properly handle popup
      var selectedMarker = false; // const selected = this.map.getFeaturesAtPixel(e.pixel, {
      // 	layerFilter: (layer) => {
      // 		return (layer instanceof ol.layer.Vector);
      // 	}
      // });
      // if (selected && selected.length > 0) {
      // 	const feature = selected[0];
      // 	const geom = feature.getGeometry();
      // 	if (geom instanceof ol.geom.Point) {
      // 		selectedMarker = true;
      // 		layer.dispatchEvent(new Event('marker:click'));
      // 	} else if (geom instanceof ol.geom.Polygon) {
      // 		this.trigger('shape:click', { shape: feature });
      // 	}
      // }

      var triggered = false;

      _this.map.forEachFeatureAtPixel(e.pixel, function (feature, layer) {
        if (!triggered) {
          var geom = feature.getGeometry();
          var props = feature.getProperties();
          var id = (0, _utils.get)(props, 'id') || (0, _utils.get)(props, 'properties.id');
          var dataKey = (id || '').replace(/^aeris-layer-/, '');

          if (geom instanceof ol.geom.Point) {
            selectedMarker = true;
            layer.dispatchEvent(new _Event.default('marker:click'));
            triggered = true;
          } else if (geom instanceof ol.geom.SimpleGeometry) {
            var data = _this._shapeDataById[dataKey];

            _this.trigger('shape:click', {
              shape: feature,
              data: data
            });

            triggered = true;
          }
        }
      }, {
        hitTolerance: 10
      });

      if (triggered) {
        _this._clickedMapLayer = true;
        setTimeout(function () {
          _this._clickedMapLayer = false;
        }, 100);
      } else {
        _this.trigger('click', _this._dataForMapEvent('click', e));
      } // no marker nor shape was selected, hide any active popup


      if (!selectedMarker && _this._activePopup) {
        _this._activePopup.remove();
      }
    });
    this.map.on('moveend', function (e) {
      _this.trigger('change:bounds');

      _this.trigger('change:center');
    });
    this.map.on('zoomend', function (e) {
      _this.trigger('change:zoom');
    }); // this.map.on('idle', e => this.trigger('idle'));
  };

  OpenLayersMapStrategy.prototype._shouldTriggerEvent = function (name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  };

  OpenLayersMapStrategy.prototype._dataForMapEvent = function (name, event) {
    if (!event) return null;
    var data = null;
    var coord;

    switch (name) {
      case 'click':
      case 'dblclick':
        coord = ol.proj.toLonLat(event.coordinate);
        data = {
          coord: {
            lat: coord[1],
            lon: coord[0]
          },
          point: {
            x: event.pixel[0],
            y: event.pixel[1]
          }
        };
        break;

      default:
        break;
    }

    return data;
  };

  return OpenLayersMapStrategy;
}(_MapStrategy.default);

var _default = OpenLayersMapStrategy;
exports.default = _default;
module.exports = exports.default;