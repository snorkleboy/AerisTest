"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _TileLayer = _interopRequireDefault(require("../layers/TileLayer"));

var _utils = require("../../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */


/**
 * `OpenLayersTileSource` is a subclass of `TileSource` that creates and manages a single tile
 * layer to be used with an `OpenLayersMapStrategy`.
 *
 * @export
 * @class OpenLayersTileSource
 * @extends {TileSource}
 */
var OpenLayersTileSource =
/** @class */
function (_super) {
  __extends(OpenLayersTileSource, _super);

  function OpenLayersTileSource(key, service, opts) {
    var _this = _super.call(this, key, service, opts) || this;

    service.offset(0); // console.log([1,2,3,4].map(index => service.url()));

    _this._overlay = new _TileLayer.default(key, 'tile', _this.identifier);
    _this.timestamp = _this._opts.time;
    _this.animation.provider = _this;
    return _this;
  }

  Object.defineProperty(OpenLayersTileSource.prototype, "overlay", {
    get: function () {
      return this._overlay;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(OpenLayersTileSource.prototype, "timestamp", {
    set: function (value) {
      value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

      if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
        this._timestamp = value;

        if (this.isAnimating() === false) {
          this.updateVisibility();
        }

        if (this.overlay && this.overlay.isHidden === false && this.canShow()) {
          this.overlay.setUrl(this.urlTemplate());
        }
      }
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Shows the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */

  OpenLayersTileSource.prototype.show = function () {
    this._hidden = false;

    if (this.overlay) {
      this.overlay.show();
    }
  };
  /**
   * Hides the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */


  OpenLayersTileSource.prototype.hide = function () {
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }
  };
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof OpenLayersTileSource
   */


  OpenLayersTileSource.prototype.remove = function () {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  };
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  OpenLayersTileSource.prototype.setOpacity = function (value) {
    this._opacity = value;

    if (this.overlay) {
      this.overlay.setOpacity(value);
    }
  };
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  OpenLayersTileSource.prototype.setOrder = function (value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }
  };
  /**
   * Animation Providers
   */


  OpenLayersTileSource.prototype.animationLayerForDate = function (animation, date) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (_this.dataSource) {
        var source_1 = _this.dataSource.tileLayer(_this.key, date, (0, _utils.extend)((0, _utils.cloneDeep)(_this._opts), {
          id: "anim"
        }));

        source_1.overlay.on('load', function () {
          resolve(source_1);
          source_1.hide();
          source_1.setOpacity(_this._opacity);
        }); // forward source layer remove event up to the parent source

        source_1.on('layer:remove', function () {
          _this.trigger('layer:remove', {
            layer: source_1.overlay
          });
        });

        _this.trigger('layer:add', {
          layer: source_1.overlay,
          relativeTo: _this.overlay.layer,
          offset: 1
        }); // must set opacity and hidden after added to map so the internal layer is setup;
        // tiles won't load if layer is hidden, so just set opacity to 0 and then reset when
        // loading has completed


        source_1.setOpacity(0); // source.hide();
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  };

  return OpenLayersTileSource;
}(_TileSource.default);

var _default = OpenLayersTileSource;
exports.default = _default;
module.exports = exports.default;