"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapboxTileSource = _interopRequireDefault(require("./sources/MapboxTileSource"));

var _layers = require("./layers");

var _SVG = require("../../../../display/SVG");

var _utils = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class MapboxOverlayFactory
 * @implements {IOverlayFactory}
 * @implements {IPointDataSource}
 */
var MapboxOverlayFactory =
/** @class */
function () {
  function MapboxOverlayFactory() {}
  /**
   * Returns a tile layer instance configured with the specified url template string and options.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {TileSource}
   * @memberof IOverlayFactory
   */


  MapboxOverlayFactory.prototype.tileLayer = function (layer, service, opts) {
    return new _MapboxTileSource.default(layer, service, opts);
  };
  /**
   * Returns an annotation, or marker, instance with the specified coordinate and configuration
   * options.
   *
   * @param {string} layer
   * @param {ICoordinate} coord
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof IOverlayFactory
   */


  MapboxOverlayFactory.prototype.marker = function (layer, coord, style) {
    var opts = {};

    if (style) {
      opts.icon = this.markerIcon(style);
    }

    var marker = new mapboxgl.Marker({
      element: opts.icon
    });
    marker.setLngLat([coord.lon, coord.lat]);

    if (style && style.callout) {
      var content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        var fn = style.callout;
        content = fn();
      }

      var popup = new mapboxgl.Popup();
      popup.setHTML(content);
      marker.setPopup(popup);
    }

    return marker;
  };
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof IOverlayFactory
   */


  MapboxOverlayFactory.prototype.markerIcon = function (style) {
    if (!style) {
      return null;
    }

    if (style.html) {
      console.warn('awxjs - HTML markers are not currently supported with Mapbox GL');
    }

    if (style.svg) {
      var _a = style.size || [12, 12],
          width = _a[0],
          height = _a[1];

      if (document) {
        var div = document.createElement('div');
        div.innerHTML = _SVG.SVG.draw(width, height, style.svg);

        if (style.zIndex) {
          div.style.zIndex = "" + style.zIndex;
        }

        return div;
      }
    }

    if (style.icon) {
      var image = new Image();
      image.src = style.icon.url;
      image.width = style.size[0];
      image.height = style.size[1];
      return image;
    }

    return null;
  };
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof IOverlayFactory
   */


  MapboxOverlayFactory.prototype.polygon = function (layer, shapes, style) {
    // generate Mapbox paint options from config
    var opts;

    if (style) {
      opts = {
        stroke: false,
        fill: false
      };
      opts.id = style.id;

      if (style.stroke) {
        opts.lineColor = style.stroke.color;
        opts.lineOpacity = style.stroke.opacity;
        opts.lineWidth = style.stroke.width;
        opts.lineCap = style.stroke.lineCap;
        opts.lineJoin = style.stroke.lineJoin;
        opts.lineDasharray = style.stroke.dashArray;
        opts.dashOffset = style.stroke.dashOffset;
      }

      if (style.fill) {
        opts.fillColor = style.fill.color;
        opts.fillOpacity = style.fill.opacity;
      }
    }

    shapes.forEach(function (shape) {
      if (!opts.id) {
        opts.id = shape.id;
      }
    });
    return new _layers.Polygon(layer, shapes, opts);
  };

  MapboxOverlayFactory.prototype.polyline = function (layer, points, style) {
    var mapping = {
      stroke: {
        color: 'lineColor',
        opacity: 'lineOpacity',
        width: 'lineWidth',
        dashArray: 'lineDashArray'
      }
    };
    var opts;

    if (style) {
      opts = {
        style: {}
      };
      opts.id = style.id;

      if (style.stroke) {
        Object.keys(style.stroke).forEach(function (key) {
          var target = mapping.stroke[key] || key;
          opts.style[target] = style.stroke[key];
        }); // opts = Object.keys(style.stroke).reduce((prev: any, key: string) => {
        // 	return prev;
        // }, opts);
        // opts.lineColor = style.stroke.color;
        // opts.lineOpacity = style.stroke.opacity;
        // opts.lineWidth = style.stroke.width;
        // opts.lineCap = style.stroke.lineCap;
        // opts.lineJoin = style.stroke.lineJoin;
        // opts.lineDasharray = style.stroke.dashArray;
        // // opts.dashOffset = style.stroke.dashOffset;
      }
    }

    var p = points.map(function (point) {
      return [point.lat, point.lon];
    });
    return new _layers.Polyline(layer, points, opts);
  };

  return MapboxOverlayFactory;
}();

var _default = MapboxOverlayFactory;
exports.default = _default;
module.exports = exports.default;