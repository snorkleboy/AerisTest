"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */


/**
 * `TileLayer` is a container class that is responsible for creating and managing a Mapbox
 * source and associated layer representation on a Mapbox map.
 */
var MapboxTileLayer =
/** @class */
function (_super) {
  __extends(MapboxTileLayer, _super);

  function MapboxTileLayer(layer, type, id) {
    if (type === void 0) {
      type = 'tile';
    }

    if (id === void 0) {
      id = undefined;
    }

    var _this = _super.call(this, layer, id) || this;

    _this._opts = {};
    _this._type = type;
    return _this;
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  MapboxTileLayer.prototype.setUrl = function (url) {
    this._opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  };
  /**
   * Updates the bounds for the layer when rendered as an image.
   *
   * @param {ICoordinateBounds} bounds
   * @memberof TileLayer
   */


  MapboxTileLayer.prototype.setBounds = function (bounds) {
    this._opts.bounds = bounds;
  };
  /**
   * Updates the layer source using the specified image URL and coordinate bounds. Only used
   * for `image` layer types.
   *
   * @param {string} url
   * @param {ICoordinateBounds} [bounds=undefined]
   * @returns
   * @memberof TileLayer
   */


  MapboxTileLayer.prototype.setImage = function (url, bounds) {
    if (bounds === void 0) {
      bounds = undefined;
    }

    this._opts.url = url;
    var map = this.map;
    if (!map) return;
    if (!bounds) bounds = this._opts.bounds;
    var source = map.getSource(this.sourceId);

    if (source) {
      source.updateImage({
        url: url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      });
    } else {
      this.invalidate();
    }
  };
  /**
   * Forces a redraw of the layer on the map.
   *
   * @returns
   * @memberof TileLayer
   */


  MapboxTileLayer.prototype.invalidate = function () {
    var _a = this._opts,
        url = _a.url,
        bounds = _a.bounds;
    if (!url) return;

    if (this._type === 'image') {
      if (!bounds) {
        return;
      }

      this.source = {
        type: 'image',
        url: url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      };
    } else {
      this.source = {
        type: 'raster',
        tiles: [url],
        tileSize: 256
      };
    }

    this.layer = {
      id: this.layerId,
      type: 'raster',
      source: this.sourceId,
      paint: {
        'raster-fade-duration': 0
      }
    };

    if (this.map) {
      var map = this.map;
      this.remove();
      this.addTo(map);
    }
  };

  return MapboxTileLayer;
}(_Layer.default);

var _default = MapboxTileLayer;
exports.default = _default;
module.exports = exports.default;