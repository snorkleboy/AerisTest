"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer"));

var strings = _interopRequireWildcard(require("../../../../../utils/strings"));

var _utils = require("../../../../../utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */


var MapboxPolygonLayer =
/** @class */
function (_super) {
  __extends(MapboxPolygonLayer, _super);

  function MapboxPolygonLayer(layer, polygons, opts) {
    if (opts === void 0) {
      opts = undefined;
    }

    var _this = _super.call(this, layer, opts.id) || this;

    _this._opts = {};
    _this._polygons = polygons; // convert camelcase style keys to hypenated strings

    opts = opts || {};
    Object.keys(opts).forEach(function (key) {
      var k = strings.hyphenate(key);

      if (k !== key) {
        opts[k] = opts[key];
        delete opts[key];
      }
    });
    _this._opts = opts;
    return _this;
  }

  Object.defineProperty(MapboxPolygonLayer.prototype, "strokeLayerId", {
    get: function () {
      return this.layerId + "-stroke";
    },
    enumerable: true,
    configurable: true
  });

  MapboxPolygonLayer.prototype.addTo = function (map) {
    _super.prototype.addTo.call(this, map);

    if (this._strokeLayer) {
      var contains = map.getLayer(this.strokeLayerId) !== undefined;

      if (!contains) {
        map.addLayer(this._strokeLayer, this.layerId);
      }
    }
  };

  MapboxPolygonLayer.prototype.remove = function () {
    if (!this.map) return;

    if (this._strokeLayer) {
      var contains = this.map.getLayer(this.strokeLayerId) !== undefined;

      if (contains) {
        this.map.removeLayer(this._strokeLayer);
      }
    }

    _super.prototype.remove.call(this);
  };

  MapboxPolygonLayer.prototype.invalidate = function () {
    var isMulti = this._polygons.length > 1;
    var polygons = (this._polygons || []).map(function (polygon) {
      var outer = polygon.outer.map(function (c) {
        return [c.lon, c.lat];
      });
      var inner = polygon.inner ? polygon.inner.map(function (p) {
        return p.map(function (c) {
          return [c.lon, c.lat];
        });
      }) : [];
      return [outer].concat(inner);
    });
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: isMulti ? 'MultiPolygon' : 'Polygon',
            coordinates: isMulti ? polygons : polygons[0] || []
          }
        }]
      }
    };
    var style = (0, _utils.cloneDeep)(this._opts);
    var convertedStyle = {
      fill: {},
      stroke: {}
    }; // format the line/fill styles as required for the Mapbox paint style spec

    ['fill', 'line'].forEach(function (type) {
      var dest = type === 'line' ? 'stroke' : 'fill';
      Object.keys(style).filter(function (key) {
        return new RegExp("^" + type + "-").test(key);
      }).map(function (prop) {
        var k = strings.hyphenate(prop);

        if (style[prop]) {
          convertedStyle[dest][k] = style[prop];
        }
      });
    });
    this.layer = {
      id: this.layerId,
      type: 'fill',
      source: this.sourceId,
      layout: {},
      paint: convertedStyle.fill
    }; // need to create a separate layer for the stoke style since Mapbox
    // doesn't allow you to set the apply stroke styling to a fill layer

    if (Object.keys(convertedStyle.stroke).length > 0) {
      this._strokeLayer = {
        id: this.layerId + "-stroke",
        type: 'line',
        source: this.sourceId,
        layout: {},
        paint: convertedStyle.stroke
      };
    }

    if (this.map) {
      var map = this.map;
      this.remove();
      this.addTo(map);
    }
  };

  MapboxPolygonLayer.prototype._style = function (key) {
    return this._opts[key];
  };

  return MapboxPolygonLayer;
}(_Layer.default);

var _default = MapboxPolygonLayer;
exports.default = _default;
module.exports = exports.default;