"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var _MapboxOverlayFactory = _interopRequireDefault(require("./MapboxOverlayFactory"));

var _MapboxTileSource = _interopRequireDefault(require("./sources/MapboxTileSource"));

var _layers = require("./layers");

var _utils = require("../../../../utils");

var _utils2 = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */


/**
 * A map strategy for working with the third-party Mapbox GL mapping library.
 *
 * @export
 * @class MapboxMapStrategy
 * @extends {EventDispatcher}
 * @implements {IMapStrategy}
 */
var MapboxMapStrategy =
/** @class */
function (_super) {
  __extends(MapboxMapStrategy, _super);

  function MapboxMapStrategy(target, opts) {
    var _this = _super.call(this, target, (0, _utils.extend)({
      accessToken: null,
      style: 'mapbox://styles/mapbox/streets-v9'
    }, opts)) || this;

    _this._pointAnimationUpdates = {};
    _this._shapeDataById = {};
    _this._clickedMapLayer = false;
    return _this;
  }

  Object.defineProperty(MapboxMapStrategy.prototype, "$el", {
    get: function () {
      return (0, _DOM.default)(this.map.getContainer());
    },
    enumerable: true,
    configurable: true
  });

  MapboxMapStrategy.prototype.loadDependencies = function () {
    var css = document.createElement("style");
    css.type = "text/css";
    css.innerHTML = '.mapboxgl-marker { line-height: 0; }';
    window.document.body.appendChild(css);
    return new Promise(function (resolve, reject) {
      if (typeof mapboxgl === 'undefined' || typeof mapboxgl.Map === 'undefined') {
        var version = '0.51.0';
        Promise.all([(0, _utils.loadStyles)("https://api.tiles.mapbox.com/mapbox-gl-js/v" + version + "/mapbox-gl.css"), (0, _utils.loadScript)("https://api.tiles.mapbox.com/mapbox-gl-js/v" + version + "/mapbox-gl.js")]).then(function () {
          resolve();
        });
      } else {
        resolve();
      }
    });
  };

  MapboxMapStrategy.prototype.setupMap = function (target) {
    var _this = this;

    this._factory = new _MapboxOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      remove: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end'
    };
    var mbversion = mapboxgl.version;

    if (mbversion) {
      var _a = mbversion.split('.'),
          major = _a[0],
          minor = _a[1];

      major = parseInt(major, 10);
      minor = parseInt(minor, 10);

      if (major === 0 && minor < 50) {
        throw new Error("AerisWeather SDK requires Mapbox GL JS version 0.50.0 or higher. You are using version " + mbversion + ".");
      }
    } // set view properties from native map options if defined


    var mapOpts = this.opts.map;

    if (mapOpts) {
      var center = mapOpts.center,
          zoom = mapOpts.zoom;

      if (center && (0, _utils.isArray)(center)) {
        var lon = center[0],
            lat = center[1];

        if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
          (0, _utils.set)(this.opts, 'center', {
            lat: lat,
            lon: lon
          });
        }
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of mapboxgl.Map
    // if mapboxgl.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isMapbox)(target)) {
      // this._setInitialView = false;
      this._map = target;
      setTimeout(function () {
        _this.trigger('map:ready');
      }, 250);
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        var obj = target;
        target = obj[0];
      }

      mapboxgl.accessToken = this.opts.accessToken;
      this._map = new mapboxgl.Map((0, _utils.extend)({}, this.opts.map, {
        container: target,
        style: this.opts.style
      }));
      this._currentMapStyle = this.opts.style;

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }

      this.map.addControl(new mapboxgl.NavigationControl());
      this.map.on('load', function () {
        setTimeout(function () {
          _this.trigger('map:ready');
        }, 250);
      });
    }
  };
  /**
   * Updates the base map style using a Mapbox style URL.
   *
   * @param {string} style
   * @returns
   * @memberof MapboxMapStrategy
   */


  MapboxMapStrategy.prototype.setStyle = function (style) {
    if (style === this._currentMapStyle) return;
    var map = this.map; // grab the existing style and cache all Aeris-related sources and layers
    // so they can be re-added after changing the map style

    var mapStyle = map.getStyle();
    var aerisLayers = mapStyle.layers.filter(function (layer) {
      return /^aeris-/.test(layer.id);
    });
    var aerisSources = Object.keys(mapStyle.sources).filter(function (key) {
      return /^aeris-/.test(key);
    }).reduce(function (prev, result) {
      prev[result] = mapStyle.sources[result];
      return prev;
    }, {}); // need to wait for the new style to load before re-adding the previous map data

    map.on('style.load', function () {
      Object.keys(aerisSources).forEach(function (key) {
        var existing = map.getSource(key);

        if (!existing) {
          map.addSource(key, aerisSources[key]);
        }
      });
      aerisLayers.forEach(function (layer) {
        var existing = map.getLayer(layer.id);

        if (!existing) {
          map.addLayer(layer);
        }
      });
    }); // update the map style

    map.setStyle(style, {
      diff: true
    });
  };

  MapboxMapStrategy.prototype.setView = function (center, zoom) {
    this.map.jumpTo({
      center: {
        lat: center.lat,
        lon: center.lon
      },
      zoom: Math.max(1, zoom - 1)
    });
  };

  MapboxMapStrategy.prototype.getCenter = function () {
    var coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  };

  MapboxMapStrategy.prototype.setCenter = function (coord) {
    this._map.setCenter({
      lat: coord.lat,
      lon: coord.lon
    });
  };

  MapboxMapStrategy.prototype.getZoom = function () {
    return this._map.getZoom() + 1;
  };

  MapboxMapStrategy.prototype.setZoom = function (zoom) {
    this._map.setZoom(Math.max(0, zoom - 1));
  };

  MapboxMapStrategy.prototype.getBounds = function () {
    var b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  };

  MapboxMapStrategy.prototype.setBounds = function (bounds) {
    var sw = mapboxgl.LngLat(bounds.west, bounds.south);
    var ne = mapboxgl.LngLat(bounds.east, bounds.north);
    this.map.fitBounds(new mapboxgl.LngLatBounds(sw, ne));
  };

  MapboxMapStrategy.prototype.fitBounds = function (bounds, padding) {
    if (padding === void 0) {
      padding = [10, 10];
    }

    var sw = new mapboxgl.LngLat(bounds.west, bounds.south);
    var ne = new mapboxgl.LngLat(bounds.east, bounds.north);
    var b = new mapboxgl.LngLatBounds(sw, ne);
    this.map.fitBounds(b, {
      padding: mapboxgl.Point(padding[0], padding[1])
    });
  };
  /** Sources */


  MapboxMapStrategy.prototype.isTile = function (source) {
    return source instanceof _MapboxTileSource.default;
  };

  MapboxMapStrategy.prototype.isMarker = function (el) {
    return el instanceof mapboxgl.Marker;
  };

  MapboxMapStrategy.prototype.isPolygon = function (el) {
    return el instanceof _layers.Polygon;
  };

  MapboxMapStrategy.prototype.isPolyline = function (el) {
    return el instanceof _layers.Polyline;
  };

  MapboxMapStrategy.prototype.addSource = function (source) {
    _super.prototype.addSource.call(this, source);

    if (this.isTile(source)) {
      source.updateVisibility();
    }
  };
  /** Overlays */


  MapboxMapStrategy.prototype.addOverlay = function (overlay) {
    if (overlay instanceof _layers.Tile) {
      overlay.addTo(this.map);
    }
  };

  MapboxMapStrategy.prototype.removeOverlay = function (overlay) {
    if (overlay instanceof _layers.Tile) {
      overlay.remove();
    }
  };
  /** Markers */


  MapboxMapStrategy.prototype.addMarker = function (marker, data) {
    var _this = this;

    if (this.isMarker(marker)) {
      marker.addTo(this.map);
      var el = marker.getElement();

      if (el) {
        marker.__aw_clickHandler = function (e) {
          _this.trigger('marker:click', {
            data: data,
            marker: marker
          });
        };

        el.addEventListener('click', marker.__aw_clickHandler);
      }

      return;
    }

    _super.prototype.addMarker.call(this, marker, data);
  };

  MapboxMapStrategy.prototype.removeMarker = function (marker) {
    if (this.isMarker(marker)) {
      marker.remove();
      var el = marker.getElement();

      if (el && marker.__aw_clickHandler) {
        el.removeEventListener('click', marker.__aw_clickHandler);
      }
    }

    _super.prototype.removeMarker.call(this, marker);
  };

  MapboxMapStrategy.prototype.updateMarker = function (marker, options, layer) {
    if (layer === void 0) {
      layer = null;
    }

    options.data = options.data || {};
    var style = options.style,
        value = options.data.value;

    if (!this._pointAnimationUpdates[layer]) {
      this._pointAnimationUpdates[layer] = {};
    }

    var updates = this._pointAnimationUpdates[layer]; // Mapbox doesn't support updating an existing marker's element, so we need to create a new marker
    // for each different value associated with a coordinate's data and add/remove it accordingly

    if (marker instanceof mapboxgl.Marker && (0, _utils.isset)(value)) {
      var _a = marker.getLngLat(),
          lon = _a.lng,
          lat = _a.lat;

      var id = lat + "," + lon;

      if (!updates[id]) {
        updates[id] = {
          active: null
        };
      }

      var points = updates[id];
      var active = points.active;

      if (active) {
        active.remove();
      }

      if (!points[value]) {
        var valueMarker = this.factory.marker(null, {
          lat: lat,
          lon: lon
        }, (0, _utils.isFunction)(style) ? style({
          value: value
        }) : style);
        points[value] = valueMarker;
        marker.remove();
      }

      points[value].addTo(this.map);
      points.active = points[value];
    }

    _super.prototype.updateMarker.call(this, marker, options, layer);
  };
  /** Polygons & Polylines */


  MapboxMapStrategy.prototype.addShape = function (shape, data) {
    if (shape instanceof _layers.Polygon || shape instanceof _layers.Polyline) {
      shape.addTo(this.map);
      this._shapeDataById[shape.id] = data;
      return;
    }

    _super.prototype.addShape.call(this, shape, data);
  };

  MapboxMapStrategy.prototype.removeShape = function (shape) {
    if (shape instanceof _layers.Polygon || shape instanceof _layers.Polyline) {
      shape.remove();
      return;
    }

    _super.prototype.removeShape.call(this, shape);
  };

  MapboxMapStrategy.prototype.showShape = function (shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.show();
      return;
    }

    _super.prototype.showShape.call(this, shape);
  };

  MapboxMapStrategy.prototype.hideShape = function (shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.hide();
      return;
    }

    _super.prototype.hideShape.call(this, shape);
  };
  /** Conversions */


  MapboxMapStrategy.prototype.coordToPoint = function (coord) {
    var p = this.map.project({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  };

  MapboxMapStrategy.prototype.pointToCoord = function (point) {
    var c = this.map.unproject([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  };
  /** Callout */


  MapboxMapStrategy.prototype.showCallout = function (target, content) {
    var popup = new mapboxgl.Popup().setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setLngLat({
        lat: target.lat,
        lng: target.lon
      }).addTo(this.map);
    } else if (this.isMarker(target)) {
      target.setPopup(popup);
      target.togglePopup();
    }
  };

  MapboxMapStrategy.prototype._setupEvents = function () {
    var _this = this;

    this.map.on('moveend', function (e) {
      _this.trigger('change:bounds');

      _this.trigger('change:center');
    });
    this.map.on('zoomend', function (e) {
      _this.trigger('change:zoom');
    });
    this.map.on('click', function (e) {
      var features = _this.map.queryRenderedFeatures(e.point);

      if (features.length === 0) {
        return;
      }

      var triggered = false;
      features.forEach(function (feature) {
        var id = feature.layer.id;

        if (triggered === false && /^aeris-layer-/.test(id)) {
          if (feature.layer.type === 'fill' || feature.layer.type === 'line') {
            var dataKey = id.replace(/^aeris-layer-/, '');
            var data = _this._shapeDataById[dataKey];

            _this.trigger('shape:click', {
              shape: feature,
              data: data
            });

            triggered = true;
            _this._clickedMapLayer = true;
            setTimeout(function () {
              _this._clickedMapLayer = false;
            }, 100);
          }
        }
      });
    }); // call super at the bottom so our initial click event handler gets called first to
    // handle layer vs map click triggers

    _super.prototype._setupEvents.call(this);
  };

  MapboxMapStrategy.prototype._shouldTriggerEvent = function (name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  };

  MapboxMapStrategy.prototype._dataForMapEvent = function (name, event) {
    if (!event) return null;
    var data = null;

    switch (name) {
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.lngLat.lat,
            lon: event.lngLat.lng
          },
          point: {
            x: event.point.x,
            y: event.point.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  };

  return MapboxMapStrategy;
}(_MapStrategy.default);

var _default = MapboxMapStrategy;
exports.default = _default;
module.exports = exports.default;