"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _sources = require("../sources");

var _utils = require("../../../utils");

var _MapElement = _interopRequireDefault(require("../MapElement"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * An abstract map strategy class that provides the core functionality required for a specific
 * mapping strategy. This class should be subclassed per each strategy instead of being
 * instantiated directly.
 *
 * @export
 * @class MapStrategy
 * @extends {EventDispatcher}
 */
var MapStrategy =
/** @class */
function (_super) {
  __extends(MapStrategy, _super);

  function MapStrategy(target, opts) {
    var _this = _super.call(this) || this;

    _this._setInitialView = true;
    _this._ready = false;
    opts = (0, _utils.extend)({
      zoom: 7
    }, opts);
    _this._opts = opts;
    _this._sources = {};
    _this._sourceOrder = []; // dynamically inject mapping library dependencies before initializing map

    _this.loadDependencies().then(function () {
      return _this.init(target);
    });

    return _this;
  }

  Object.defineProperty(MapStrategy.prototype, "$el", {
    get: function () {
      return null;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapStrategy.prototype, "map", {
    get: function () {
      return this._map;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapStrategy.prototype, "factory", {
    get: function () {
      return this._factory;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapStrategy.prototype, "opts", {
    get: function () {
      return this._opts;
    },
    enumerable: true,
    configurable: true
  });

  MapStrategy.prototype.isReady = function () {
    return this._ready;
  };

  MapStrategy.prototype.init = function (target) {
    var _this = this;

    this.setupMap(target);
    var config = {};

    if ((0, _utils.isset)(this._opts.zoom)) {
      config.zoom = this._opts.zoom;
    }

    if (this._opts.center) {
      config.center = {
        lat: this._opts.center.lat,
        lon: this._opts.center.lon
      };
    }

    if (!this._factory) {
      throw new Error('Cannot initialize map, overlay factory is undefined.');
    }

    this._setupEvents();

    if (this._setInitialView) {
      var zoom = (0, _utils.isset)(config.zoom) ? Math.max(0, config.zoom) : 8;

      var _a = config.center || {},
          lat = _a.lat,
          lon = _a.lon;

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        this.setView({
          lat: parseFloat(lat),
          lon: parseFloat(lon)
        }, zoom);
      } else if (zoom > 0) {
        this.setZoom(zoom);
      }
    }

    this.on('map:ready', function () {
      _this._ready = true;

      _this.trigger('ready');
    });
  };

  MapStrategy.prototype.loadDependencies = function () {
    return null;
  };

  MapStrategy.prototype.setupMap = function (target) {
    throw new Error('Subclasses of MapStrategy must override setupMap()');
  };

  MapStrategy.prototype.setView = function (center, zoom) {
    throw new Error('Subclasses of MapStrategy must override setView()');
  };

  MapStrategy.prototype.setCenter = function (coord) {
    throw new Error('Subclasses of MapStrategy must override setCenter()');
  };

  MapStrategy.prototype.setZoom = function (zoom) {
    throw new Error('Subclasses of MapStrategy must override setZoom()');
  };
  /** Sources */


  MapStrategy.prototype.addSource = function (source) {
    var _this = this;

    this._sources[source.layer] = source;

    if (this.isTile(source)) {
      this._sourceOrder.push(source.layer);

      source.dataSource = this;
      this.addOverlay(source.overlay);
      source.on('layer:add', function (e) {
        _this.addOverlay(e.data.layer);
      });
      source.on('layer:remove', function (e) {
        _this.removeOverlay(e.data.layer);
      });
    } else if (this.isVector(source)) {
      source.on('markers:add', function (e) {
        var markers = e.data.markers;

        if (markers) {
          _this.addMarkers(markers);
        }
      });
      source.on('markers:remove', function (e) {
        var markers = e.data.markers;

        if (markers) {
          _this.removeMarkers(markers);
        }
      });
      source.on('markers:update', function (e) {
        (e.data.markers || []).forEach(function (item) {
          var id = item.id,
              renderable = item.renderable,
              value = item.value,
              style = item.style;

          if (value) {
            _this.updateMarker(renderable, {
              data: {
                value: value
              },
              style: style.marker || style
            }, source.layer);
          }
        });
      });
      source.on('shapes:add', function (e) {
        var _a = e.data,
            shapes = _a.shapes,
            animation = _a.animation;

        if (shapes) {
          if (animation) {
            _this.showShapes(shapes);
          } else {
            _this.addShapes(shapes);
          }
        }
      });
      source.on('shapes:remove', function (e) {
        var _a = e.data,
            shapes = _a.shapes,
            animation = _a.animation;

        if (shapes) {
          if (animation) {
            _this.hideShapes(shapes);
          } else {
            _this.removeShapes(shapes);
          }
        }
      });
    }
  };

  MapStrategy.prototype.removeSource = function (source) {
    if (this.isTile(source)) {
      // this.removeOverlay(source.overlay);
      source.remove();

      var index = this._sourceOrder.indexOf(source.layer);

      if (index >= 0) {
        this._sourceOrder.splice(index, 1);
      } // (<TileSource>source).destroy();

    } else if (this.isVector(source)) {
      this.removeMarkers(source.markers);
      this.removeShapes(source.shapes);
    }

    source.strategy = null;
    delete this._sources[source.layer];
  };

  MapStrategy.prototype.isTile = function (source) {
    return false;
  };

  MapStrategy.prototype.isVector = function (source) {
    return source instanceof _sources.VectorSource;
  };

  MapStrategy.prototype.isText = function (source) {
    return source instanceof _sources.TextSource;
  };

  MapStrategy.prototype.isMarker = function (el) {
    return false;
  };

  MapStrategy.prototype.isPolygon = function (el) {
    return false;
  };

  MapStrategy.prototype.isPolyline = function (el) {
    return false;
  };
  /** Overlays */


  MapStrategy.prototype.addOverlay = function (overlay) {
    throw new Error('Subclasses of MapStrategy must override addOverlay()');
  };

  MapStrategy.prototype.addOverlays = function (overlays) {
    var _this = this;

    (overlays || []).forEach(function (overlay) {
      return _this.addOverlay(overlay);
    });
  };

  MapStrategy.prototype.removeOverlay = function (overlay) {
    throw new Error('Subclasses of MapStrategy must override removeOverlay()');
  };

  MapStrategy.prototype.removeOverlays = function (overlays) {
    var _this = this;

    (overlays || []).forEach(function (overlay) {
      return _this.removeOverlay(overlay);
    });
  };
  /** Markers */


  MapStrategy.prototype.addMarker = function (marker, data) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        if (marker.style && marker.style.callout) {
          var callout = marker.style.callout;
          var content = (0, _utils.isFunction)(callout) ? callout(marker.data) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(marker.renderable, marker.data);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      marker.style = marker.style || {};
      var renderable = marker.renderable,
          markerData = marker.data,
          callout = marker.style.callout;

      if (renderable) {
        if (callout) {
          var content = (0, _utils.isFunction)(callout) ? callout(markerData) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(renderable, markerData);
      }
    }
  };

  MapStrategy.prototype.addMarkers = function (markers) {
    var _this = this;

    (markers || []).forEach(function (marker) {
      return _this.addMarker(marker);
    });
  };

  MapStrategy.prototype.removeMarker = function (marker) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.removeMarker(marker.renderable);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      var renderable = marker.renderable;

      if (renderable) {
        this.removeMarker(renderable);
      }
    }
  };

  MapStrategy.prototype.removeMarkers = function (markers) {
    var _this = this;

    (markers || []).forEach(function (marker) {
      return _this.removeMarker(marker);
    });
  };

  MapStrategy.prototype.updateMarker = function (marker, options, layer) {
    if (layer === void 0) {
      layer = null;
    }

    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.updateMarker(marker.renderable, options, layer);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      var renderable = marker.renderable;

      if (renderable) {
        this.updateMarker(renderable, options, layer);
      }
    }
  };

  MapStrategy.prototype.bindCalloutToMarker = function (marker, content) {// base implementation doesn't do anything...
  };
  /** Polygons & Polylines */


  MapStrategy.prototype.addShape = function (shape, data) {
    if ((0, _utils.isArray)(shape)) {
      this.addShapes(shape, data);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.addShape(shape.renderable, shape.data || data);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      var renderable = shape.renderable,
          polygons = shape.polygons,
          polylines = shape.polylines,
          shapeData = shape.data;

      if (polygons) {
        this.addShapes(polygons, shapeData);
      }

      if (polylines) {
        this.addShapes(polylines, shapeData);
      }

      if (renderable) {
        this.addShape(renderable, shapeData);
      }
    }
  };

  MapStrategy.prototype.addShapes = function (shapes, data) {
    var _this = this;

    (shapes || []).forEach(function (shape) {
      return _this.addShape(shape, data);
    });
  };

  MapStrategy.prototype.removeShape = function (shape) {
    if ((0, _utils.isArray)(shape)) {
      this.removeShapes(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.removeShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      var renderable = shape.renderable,
          polygons = shape.polygons,
          polylines = shape.polylines;

      if (polygons) {
        this.removeShapes(polygons);
      }

      if (polylines) {
        this.removeShapes(polylines);
      }

      if (renderable) {
        this.removeShape(renderable);
      }
    }
  };

  MapStrategy.prototype.removeShapes = function (shapes) {
    var _this = this;

    (shapes || []).forEach(function (shape) {
      return _this.removeShape(shape);
    });
  };

  MapStrategy.prototype.showShape = function (shape) {
    if ((0, _utils.isArray)(shape)) {
      this.showShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.showShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      var renderable = shape.shape,
          polygons = shape.polygons,
          polylines = shape.polylines;

      if (polygons) {
        this.showShapes(polygons);
      }

      if (polylines) {
        this.showShapes(polylines);
      }

      if (renderable) {
        this.showShape(renderable);
      }
    }
  };

  MapStrategy.prototype.showShapes = function (shapes) {
    var _this = this;

    (shapes || []).forEach(function (shape) {
      return _this.showShape(shape);
    });
  };

  MapStrategy.prototype.hideShape = function (shape) {
    if ((0, _utils.isArray)(shape)) {
      this.hideShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.hideShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      var renderable = shape.shape,
          polygons = shape.polygons,
          polylines = shape.polylines;

      if (polygons) {
        this.hideShapes(polygons);
      }

      if (polylines) {
        this.hideShapes(polylines);
      }

      if (renderable) {
        this.hideShape(renderable);
      }
    }
  };

  MapStrategy.prototype.hideShapes = function (shapes) {
    var _this = this;

    (shapes || []).forEach(function (shape) {
      return _this.hideShape(shape);
    });
  };
  /** Callout */


  MapStrategy.prototype.showCallout = function (marker, content) {};

  MapStrategy.prototype.clear = function () {};

  MapStrategy.prototype._setupEvents = function () {
    var _this = this;

    var mapping = this._eventMapping;

    if (mapping) {
      var method_1 = 'on';

      if (!(0, _utils.has)(this.map, method_1)) {
        if ((0, _utils.has)(this.map, 'addEventListener')) {
          method_1 = 'addEventListener';
        } else if ((0, _utils.has)(this.map, 'addListener')) {
          method_1 = 'addListener';
        }
      }

      if ((0, _utils.has)(this.map, method_1)) {
        Object.keys(mapping).forEach(function (key) {
          _this.map[method_1](key, function (e) {
            var data = _this._dataForMapEvent(key, e);

            var allow = _this._shouldTriggerEvent(key);

            if (allow) {
              _this.trigger(mapping[key], data);
            }
          });
        });
      }
    }
  };

  MapStrategy.prototype._shouldTriggerEvent = function (name) {
    return true;
  };

  MapStrategy.prototype._dataForMapEvent = function (name, event) {
    return null;
  };
  /* Data Sources */


  MapStrategy.prototype.tileLayer = function (layer, date, opts) {
    if (!this.dataSource) return null;
    var index = (0, _utils.isset)(opts.zIndex) ? opts.zIndex : 1;

    var existing = this._sourceOrder.indexOf(layer);

    if (existing >= 0) {
      index = existing + 1;
    }

    var service = this.dataSource.requestForMap(layer);
    var source = this.factory.tileLayer(layer, service, (0, _utils.extend)((0, _utils.cloneDeep)(opts), {
      time: date,
      zIndex: index
    }));
    return source;
  };

  return MapStrategy;
}(_EventDispatcher.default);

var _default = MapStrategy;
exports.default = _default;
module.exports = exports.default;