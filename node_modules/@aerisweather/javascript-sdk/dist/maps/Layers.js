"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isValidLayer = exports.isTile = exports.isText = exports.isVector = exports.isShape = exports.isPoint = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _Http = _interopRequireDefault(require("../network/Http"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @ignore
 */
var _data;

var _modifiers = [];
var pointLayers = ['air-quality', 'earthquakes', 'fires', 'records', 'river-observations', 'stormreports'];

var isPoint = function (layer) {
  return pointLayers.indexOf(layer) !== -1;
};

exports.isPoint = isPoint;
var shapeLayers = ['convective', 'drought-monitor', 'fire-outlook', 'tropical-cyclones-break-points'];

var isShape = function (layer) {
  return shapeLayers.indexOf(layer) !== -1;
};

exports.isShape = isShape;
var vectorLayers = pointLayers.concat(shapeLayers).concat(['stormcells', 'tropical-cyclones']);

var isVector = function (layer) {
  return vectorLayers.indexOf(layer) !== -1;
};

exports.isVector = isVector;
var textLayers = ['observations'];

var isText = function (layer) {
  return textLayers.indexOf(layer) !== -1;
};

exports.isText = isText;

var isTile = function (layer) {
  return !isVector(layer) && !isText(layer);
};

exports.isTile = isTile;

var isValidLayer = function (layer) {
  if (!(0, _utils.isset)(layer) || !(0, _utils.isString)(layer)) return false;
  layer = layer.replace(/\:.+$/, '');

  var ids = (_data || []).map(function (config) {
    return config.id;
  });

  var layers = (layer || '').split(',');
  var codes = []; // iterate through each layer code and check if it exists in the allowed layer ids
  // if not, then strip off each valid modifier to use as the code check

  layers.forEach(function (code) {
    if (ids.indexOf(code) === -1) {
      _modifiers.forEach(function (m) {
        code = code.replace(new RegExp("-" + m), '');
      });
    }

    codes.push(code);
  });
  var valid = true;
  codes.forEach(function (code) {
    code = code.replace(/\:.*$/, '');
    var found = ids.indexOf(code) !== -1 || isVector(code) || isText(code);

    if (!found) {
      valid = false;
    }
  });
  return valid;
};
/**
 * A `Layers` object is responsible for fetching and caching Aeris Maps (AMP) layers metadata as
 * well as providing utility methods for returning and comparing layer information.
 *
 * @export
 * @class Layers
 * @extends {EventDispatcher}
 */


exports.isValidLayer = isValidLayer;

var Layers =
/** @class */
function (_super) {
  __extends(Layers, _super);
  /**
   * Initializes and returns a new Layers instance.
   *
   * Layer metadata will be requested immediate if it has not already been cached by the library.
   *
   * @memberof Layers
   */


  function Layers() {
    var _this = _super.call(this) || this;

    _this._groups = {};
    _this._loading = false;

    if (undefined !== _data) {
      _this._process(_data);
    } else {
      _this.fetch();
    }

    return _this;
  }
  /**
   * Return the layer metadata.
   *
   * If the data has not already been loaded and cached, this method will perform a new
   * request before resolving the Promise with the data.
   *
   * @returns
   * @memberof Layers
   */


  Layers.prototype.fetch = function () {
    var _this = this;

    return new Promise(function (resolve, reject) {
      // always return a copy of our _data object in case callers try to change the data contained within
      if (_data) {
        resolve((0, _utils.cloneDeep)(_data));
      } else if (_this._loading) {
        _this.on('load:done', function (e) {
          resolve((0, _utils.cloneDeep)(_data));
        });
      } else {
        _this._fetchLayerMetadata().then(function (data) {
          resolve((0, _utils.cloneDeep)(_data));
        });
      }
    }).catch(function (e) {
      console.error("Layers: Failed to load layers metadata - " + e);
    });
  };
  /**
   * Returns whether layer metadata is already cached.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.cached = function () {
    return _data !== undefined;
  };
  /**
   * Returns whether layer metadata is currently being requested.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.loading = function () {
    return this._loading;
  };
  /**
   * Returns the layer groups.
   *
   * @returns {*}
   * @memberof Layers
   */


  Layers.prototype.groups = function () {
    return this._groups;
  };
  /**
   * Returns whether the layer for the identifier is part of the specified group.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} id
   * @param {string} group
   * @param {boolean} [strict=false]
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.inGroup = function (id, group, strict) {
    if (strict === void 0) {
      strict = false;
    }

    var groupLayers = this._groups[group];
    id = id.replace(/:.*$/, '');

    if (groupLayers) {
      if (strict) {
        return groupLayers.indexOf(id) !== -1;
      }

      var found_1 = false;
      groupLayers.forEach(function (code) {
        var re = new RegExp("^" + code + "-"); // support for modifiers in values layers array

        if (code === id || re.test(id)) {
          found_1 = true;
        }
      });
      return found_1;
    }

    return false;
  };
  /**
   * Returns whether the specified layer exists within AMP.
   *
   * @param {string} layer
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.exists = function (layer) {
    return isValidLayer(layer);
  };
  /**
   * Returns the layer metadata that matches the query based on the specified property and value.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {*} value
   * @param {boolean} [strict=false]
   * @returns {LayerConfig}
   * @memberof Layers
   */


  Layers.prototype.find = function (prop, value, strict) {
    if (strict === void 0) {
      strict = false;
    }

    var results = this.findAll(prop, [value], strict);

    if (results.length > 0) {
      return results[0];
    }

    return undefined;
  };
  /**
   * Returns an array of layer metadata for all layers that match the query based on the
   * specified property and values.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {string[]} values
   * @param {boolean} [strict=false]
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  Layers.prototype.findAll = function (prop, values, strict) {
    if (strict === void 0) {
      strict = false;
    }

    var data = _data;
    var layers = [];
    values = values || [];

    if (data) {
      values.forEach(function (value) {
        data.forEach(function (layer, i) {
          var layerVal = layer[prop];
          var match = layerVal === value;

          if (!match) {
            var re = new RegExp("^" + layerVal + "-"); // support for modifiers in values layers array

            var modifiers = (layer.modifiers || []).map(function (modifier) {
              return [].concat((modifier.options || []).map(function (opt) {
                return layer.id + "-" + opt.id;
              }));
            });
            modifiers = modifiers.length > 0 ? modifiers[0] : modifiers;

            if (prop === 'id') {
              if (!strict) {
                match = re.test(value);
              } else {
                match = modifiers.indexOf(value) !== -1;
              }
            }
          }

          if (match) {
            if (prop === 'id') {
              layer = (0, _utils.extend)((0, _utils.cloneDeep)(layer), {
                id: value
              });
            }

            layers.push(layer);
          }
        });
      });
    }

    return (0, _utils.cloneDeep)(layers);
  };
  /**
   * Returns an array of future layer metadata.
   *
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  Layers.prototype.future = function () {
    if (!this._future) {
      var futureLayers = this.findAll('category', ['forecasts', 'models', 'outlooks']); // future radar and satellite are in rad/sat category, so add them manually

      futureLayers.push(this.find('id', 'fradar'));
      futureLayers.push(this.find('id', 'fsatellite'));
      this._future = futureLayers;
    }

    return this._future;
  };
  /**
   * Returns an array of future layer identifiers.
   *
   * @returns {string[]}
   * @memberof Layers
   */


  Layers.prototype.futureCodes = function () {
    return this.future().map(function (layer) {
      return layer ? layer.id : undefined;
    });
  };
  /**
   * Returns whether the specified layer identifier is a future layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.isFuture = function (id) {
    var codes = this.futureCodes();
    var stripped = id.replace(/:.*$/, '');
    var match = codes.indexOf(stripped) !== -1;

    if (!match) {
      stripped = stripped.replace(/\-\w+$/, '');
      match = codes.indexOf(stripped) !== -1;
    }

    return match;
  };
  /**
   * Returns whether the specified layer identifier is a base layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.isBase = function (id) {
    var stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'base');
  };
  /**
   * Returns whether the specified layer identifier is an overlay layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.isOverlay = function (id) {
    var stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'overlay') || this.inGroup(stripped, 'masks');
  };
  /**
   * Returns whether the specified layer identifier has metric data, specifically for text
   * layers.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  Layers.prototype.hasMetric = function (id) {
    if (this.inGroup(id, 'text')) {
      return /^f?humidity-/.test(id) === false;
    }

    return false;
  };

  Layers.prototype._process = function (json) {
    if (!json) return;
    var groups = {};
    _modifiers = [];
    json.forEach(function (el) {
      var cat = el.category; // catch to handle new category names in layers.json source that aren't what we expect

      if (cat.match(/^base/)) {
        cat = 'base';
      } else if (cat.match(/overlay/)) {
        cat = 'overlay';
      }

      if (groups[cat] === undefined) {
        groups[cat] = [];
      }

      groups[cat].push(el.id); // also add this layer to 'text' group if it's a text layer

      if (/-text$/.test(el.id)) {
        if (groups.text === undefined) {
          groups.text = [];
        }

        groups.text.push(el.id);
      }

      if (el.modifiers && (0, _utils.isArray)(el.modifiers)) {
        el.modifiers.forEach(function (modifier) {
          if (modifier.options) {
            modifier.options.forEach(function (option) {
              if (_modifiers.indexOf(option.id) === -1) {
                _modifiers.push(option.id);
              }
            });
          }
        });
      }
    });

    _modifiers.push('aeris');

    this._groups = groups;
  };

  Layers.prototype._fetchLayerMetadata = function () {
    var _this = this;

    this._loading = true;
    this.trigger('load:start');
    return new Promise(function (resolve, reject) {
      _Http.default.request('https://cdn.aerisjs.com/layers.json').then(function (res) {
        if (res.data) {
          _data = res.data;

          _this._process(res.data);

          _this._loading = false;

          _this.trigger('load:done');

          resolve(_data);
        }
      }).catch(function (error) {
        reject(error);
      });
    }).catch(function (e) {
      console.error("Layers: Failed to load layers metadata - " + e);
    });
  };

  return Layers;
}(_EventDispatcher.default);

var _default = Layers;
exports.default = _default;