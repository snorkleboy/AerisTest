"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dateFns = require("date-fns");

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _Regions = require("../../Regions");

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var timestampFromDate = function (date) {
  var gmtDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
  return (0, _dateFns.format)(gmtDate, 'YYYYMMDDHHmm00');
};
/**
 * A map configuration object stores and manages various map-related options associated with a
 * `MapView` instance.
 *
 * @export
 * @class MapConfig
 * @extends {EventDispatcher}
 */


var MapConfig =
/** @class */
function (_super) {
  __extends(MapConfig, _super);
  /**
   * Initializes and returns a map configuration instance for the specified map options.
   *
   * @param {MapConfigOptions} [opts=undefined]
   * @memberof MapConfig
   */


  function MapConfig(opts) {
    if (opts === void 0) {
      opts = undefined;
    }

    var _this = _super.call(this) || this;
    /**
     * @ignore
     * Called when any configuration property changes.
     *
     * @private
     * @memberof MapConfig
     */


    _this.onChange = (0, _utils.debounce)(function () {
      // // only trigger change event if we have a valid location, which prevents warning messages to the console if non-data changes
      // // occur before a location is specified for the map
      // if (this.hasLocation()) {
      // 	this.trigger('change');
      // }
      _this.trigger('change');
    }, 500);
    _this._opts = (0, _utils.extend)({}, {
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      center: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: 600,
        height: 400
      },
      offset: '0',
      date: undefined,
      autoFuture: true,
      combined: false,
      metric: false
    }, opts);
    return _this;
  }

  Object.defineProperty(MapConfig.prototype, "layers", {
    /**
     * Aeris Maps (AMP) layers metadata.
     *
     * @type {Layers}
     * @memberof MapConfig
     */
    get: function () {
      return this._layers;
    },
    set: function (layers) {
      this._layers = layers;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns or sets an option by key.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof MapConfig
   */

  MapConfig.prototype.opts = function (key, value) {
    if ((0, _utils.isset)(value)) {
      (0, _utils.set)(this._opts, key, value);
      return null;
    }

    return (0, _utils.get)(this._opts, key);
  };
  /*
   * Layers
   */

  /**
   * Returns the data layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  MapConfig.prototype.data = function () {
    return this.opts('layers.data');
  };
  /**
   * Sets the data layer codes.
   *
   * @param {string[]} data
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setData = function (data) {
    var _this = this;

    if (!this._opts.combined) {
      var text_1 = [];
      var layers_1 = [];
      data.forEach(function (layer) {
        if (/-text-?/.test(layer) && _this.layers.inGroup(layer, 'text')) {
          text_1.push(layer);
        } else {
          layers_1.push(layer);
        }
      });
      this.opts('layers.data', layers_1);
      this.opts('layers.text', text_1);
    } else {
      this.opts('layers.data', data);
    }

    this.trigger('change:data', {
      data: data
    });
    this.onChange();
    return this;
  };
  /**
   * Returns the base layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  MapConfig.prototype.base = function () {
    return this.opts('layers.base');
  };
  /**
   * Sets the base layer codes.
   *
   * @param {string[]} base
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setBase = function (base) {
    this.opts('layers.base', base);
    this.trigger('change:base', {
      base: base
    });
    this.onChange();
    return this;
  };
  /**
   * Returns the overlay layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  MapConfig.prototype.overlays = function () {
    return this.opts('layers.overlays');
  };
  /**
   * Sets the overlay layer codes.
   *
   * @param {string[]} overlays
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setOverlays = function (overlays) {
    this.opts('layers.overlays', overlays);
    this.trigger('change:overlays', {
      overlays: overlays
    });
    this.onChange();
    return this;
  };
  /**
   * Returns whether the layer configuration contains overlay layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  MapConfig.prototype.hasOverlays = function () {
    var overlays = this.overlays();
    return overlays && !(0, _utils.isEmpty)(overlays);
  };
  /**
   * Returns the text layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  MapConfig.prototype.text = function () {
    return this.opts('layers.text');
  };
  /**
   * Sets the text layer codes.
   *
   * @param {string[]} text
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setText = function (text) {
    this.opts('layers.text', text);
    this.trigger('change:text', {
      text: text
    });
    this.onChange();
    return this;
  };
  /**
   * Returns whether the layer configuration contains text layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  MapConfig.prototype.hasText = function () {
    var text = this.text();
    return text && !(0, _utils.isEmpty)(text);
  };
  /**
   * Sets all layer codes grouped by category.
   *
   * @param {MapConfigLayersOptions} layers
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setLayers = function (layers) {
    layers = layers || {};
    if (layers.base) this.setBase(layers.base);
    if (layers.data) this.setData(layers.data);
    if (layers.overlays) this.setOverlays(layers.overlays);
    if (layers.text) this.setText(layers.text);
    return this;
  };
  /**
   * Returns the time offset.
   *
   * @returns {string}
   * @memberof MapConfig
   */


  MapConfig.prototype.offset = function () {
    return this.opts('offset');
  };
  /**
   * Sets the time offset.
   *
   * @param {string} offset
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setOffset = function (offset) {
    this.opts('offset', "" + offset);
    this.trigger('change:offset', {
      offset: offset
    });
    this.onChange();
    return this;
  };

  MapConfig.prototype.setDate = function (date) {
    if (date instanceof Date) {
      this.setOffset(timestampFromDate(date));
    } else {
      this.setOffset("" + date);
    }
  };
  /*
   * Center and Zoom
   */

  /**
   * Returns the center place string or coordinate object.
   *
   * @returns {(string | ICoordinate)}
   * @memberof MapConfig
   */


  MapConfig.prototype.center = function () {
    var center = this.opts('center');

    if (center) {
      if (/^[\d\.-]+,[\d\.-]+$/.test(center)) {
        var coord = center.split(',');

        if (coord && coord.length === 2) {
          return {
            lat: parseFloat(coord[0]),
            lon: parseFloat(coord[1])
          };
        }
      }
    }

    return center;
  };
  /**
   * Sets the center place string or coordinate object.
   *
   * @param {(ICoordinate | string)} center
   * @param {number} [zoom=null]
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setCenter = function (center, zoom) {
    if (zoom === void 0) {
      zoom = null;
    }

    if ((0, _utils.isPlainObject)(center)) {
      var coord = center;
      center = coord.lat + "," + coord.lon;
    }

    this.opts('center', center);
    delete this._opts.bounds;

    if (zoom >= 0) {
      this.opts('zoom', zoom);
    }

    this.trigger('change:center');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  };
  /**
   * Returns the zoom level.
   *
   * @returns {number}
   * @memberof MapConfig
   */


  MapConfig.prototype.zoom = function () {
    return this.opts('zoom');
  };
  /**
   * Sets the zoom level.
   *
   * @param {number} zoom
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setZoom = function (zoom) {
    this.opts('zoom', zoom);
    this.trigger('change:zoom');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  };
  /**
   * Returns the coordinate bounds.
   *
   * @returns {ICoordinateBounds}
   * @memberof MapConfig
   */


  MapConfig.prototype.bounds = function () {
    return this.opts('bounds');
  };
  /**
   * Sets the coordinate bounds.
   *
   * @param {ICoordinateBounds} bounds
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setBounds = function (bounds) {
    this.opts('bounds', bounds);
    delete this._opts.center;
    this.trigger('change:bounds');
    this.onChange();
    return this;
  };
  /**
   * Sets the center or coordinate bounds based on the specified region code.
   *
   * @param {string} key
   * @returns {MapConfig}
   * @memberof MapConfig
   * @see Regions
   */


  MapConfig.prototype.setRegion = function (key) {
    var region = _Regions.Regions.get(key);

    if (region) {
      if (region.center) {
        this.setCenter(region.center.lat + "," + region.center.lon, this.zoom());
      } else if (region.bounds) {
        this.setBounds(region.bounds);
      }
    }

    return this;
  };
  /*
   * Size
   */

  /**
   * Returns the image size.
   *
   * @returns {ISize}
   * @memberof MapConfig
   */


  MapConfig.prototype.size = function () {
    var size = this.opts('size');

    if (size && size.width && size.height) {
      return {
        width: size.width,
        height: size.height
      };
    }

    return null;
  };
  /**
   * Sets the image size.
   *
   * @param {number} width
   * @param {number | 'auto'} height
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setSize = function (width, height) {
    if (height === 'auto') {
      // calculate height if we have a scale factor for the height to retain same image aspect ratio
      var factor = this.opts('size.factor');

      if (factor) {
        height = Math.round(width * factor);
      }
    }

    this._opts.size = {
      width: width,
      height: height
    };
    this.trigger('change:size', this.size());
    this.trigger('change:bounds');
    this.onChange();
    return this;
  };
  /**
   * Returns whether to use Metric units for text layers.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  MapConfig.prototype.metric = function () {
    return this.opts('metric');
  };
  /**
   * Sets whether to use Metric units for text layers.
   *
   * @param {boolean} metric
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  MapConfig.prototype.setMetric = function (metric) {
    this.opts('metric', metric);
    this.trigger('change:metric', {
      metric: metric
    });
    this.onChange();
    return this;
  };
  /**
   * Returns an object of `MapRequest` options to use for the image request from the current
   * configuration.
   *
   * @param {string[]} [groups]
   * @param {boolean} [future=false]
   * @returns {{ [key: string]: any }}
   * @memberof MapConfig
   */


  MapConfig.prototype.toRequestOpts = function (groups, future) {
    var _this = this;

    if (future === void 0) {
      future = false;
    }

    groups = groups || ['base', 'data', 'overlays', 'text']; // let data = groups.indexOf('data') !== -1 ? this.data() : null;

    var layerCodes = [];
    groups.forEach(function (group) {
      var clayers = _this.opts("layers." + group);

      if (!(0, _utils.isEmpty)(clayers)) layerCodes = layerCodes.concat(clayers);
    });

    if (layerCodes) {
      var filtered_1 = layerCodes.slice(); // determine if we need imperial or metric text layers based on current units

      if (groups.indexOf('text') > -1) {
        filtered_1 = filtered_1.map(function (value) {
          if (/-text-?/.test(value) && _this.layers.hasMetric(value)) {
            var text = _this.opts('metric') ? 'text-metric' : 'text';
            var matches = value.match(/^([\w-]+-text)(-metric)?(-(dk|lg)){0,2}/);
            var code = matches[1].replace(/-text.*$/, '');
            var modifiers = matches[3] || '';
            return code + "-" + text + modifiers;
          }

          return value.replace(/-metric/, '');
        });
      } // reduce layers.data and layers.text to either past or future layers depending on
      // value of `opts.future`


      if (groups.indexOf('data') !== -1 || groups.indexOf('text') !== -1) {
        var futureLayers = this.layers.future();
        var futureLayerCodes_1 = this.layers.futureCodes(); // if `opts.autoFuture` is enabled, iterate through data types and automatically
        // include the future layer type that corresponds with it

        if (this.opts('autoFuture')) {
          layerCodes.forEach(function (id) {
            var futureLayer = _this.layers.find('id', "f" + id, true);

            if (futureLayer && filtered_1.indexOf(futureLayer.id) === -1) {
              filtered_1.splice(layerCodes.indexOf(id) + 1, 0, futureLayer.id);
            }
          });
        }

        var isFuture_1 = function (code) {
          var match = futureLayerCodes_1.indexOf(code) !== -1;

          if (!match) {
            futureLayerCodes_1.forEach(function (id) {
              var re = new RegExp("^" + id + "-");

              if (!match && re.test(code)) {
                match = true;
              }
            });
          }

          return match;
        };

        filtered_1 = filtered_1.filter(function (id) {
          // allow overlays and masks to be included with either past or future layers
          if (_this.layers.inGroup(id, 'overlay') || _this.layers.inGroup(id, 'masks')) {
            return true;
          }

          return future ? isFuture_1(id) : !isFuture_1(id);
        });
      }

      if (filtered_1.length === 0) {
        layerCodes = null;
      } else {
        layerCodes = filtered_1;
      }
    }

    var center = this.center();

    if ((0, _utils.isPlainObject)(center)) {
      var coord = center;
      center = coord.lat + "," + coord.lon;
    }

    return {
      layers: {
        base: groups.indexOf('base') !== -1 ? this.base() : null,
        data: groups.indexOf('data') !== -1 ? layerCodes : null,
        overlays: groups.indexOf('overlays') !== -1 ? this.overlays() : null,
        text: groups.indexOf('text') !== -1 ? layerCodes : null
      },
      p: center,
      zoom: this.zoom(),
      bounds: this.bounds(),
      size: this.size(),
      offset: this.offset(),
      metric: this.metric(),
      format: 'png'
    };
  };

  return MapConfig;
}(_EventDispatcher.default);

var _default = MapConfig;
exports.default = _default;
module.exports = exports.default;