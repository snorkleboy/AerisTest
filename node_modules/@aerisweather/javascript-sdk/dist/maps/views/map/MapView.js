"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dateFns = require("date-fns");

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _MapConfig = _interopRequireDefault(require("./MapConfig"));

var _MapRequest = _interopRequireDefault(require("../../../network/maps/MapRequest"));

var _MapViewAnimator = _interopRequireDefault(require("./MapViewAnimator"));

var _LegendView = _interopRequireDefault(require("../legends/LegendView"));

var _Timeline = _interopRequireDefault(require("../../anim/Timeline"));

var _Layers = _interopRequireDefault(require("../../Layers"));

var _ActivityIndicator = _interopRequireDefault(require("../../../ui/ActivityIndicator"));

var _utils = require("../../../utils");

var _strings = require("../../../utils/strings");

var _globals = require("../../../globals");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @ignore
 */
var containers = {
  combined: ['layers'],
  split: ['base', 'past', 'future', 'overlays', 'past-text', 'future-text']
};

var MapTimestamp =
/** @class */
function () {
  function MapTimestamp(opts) {
    this._opts = (0, _utils.extend)({
      format: 'MM/DD/YYYY hh:mm A',
      continuous: true
    }, opts);
    this.element = (0, _DOM.default)('<div class="awxjs__map-overlay__timestamp"></div>');
  }

  MapTimestamp.prototype.continuous = function () {
    return this._opts.continuous === true;
  };

  MapTimestamp.prototype.update = function (time) {
    var d = new Date(time);
    this.element.html((0, _dateFns.format)(d, this._opts.format));
  };

  return MapTimestamp;
}();
/**
 * A view object that displays and manages static map content using imagery from the Aeris Maps
 * Platform (AMP).
 *
 * A `MapView` instance does not support user interaction in regards to panning and zooming other
 * support for static control elements to reload map content. If you need to support greater user
 * interaction for map panning and zooming, use an instance of `Map` instead.
 */


var MapView =
/** @class */
function (_super) {
  __extends(MapView, _super);
  /**
   * Initializes a map view instance with the specified target and configuration object.
   *
   * @param {HTMLElement} target
   * @param {MapViewOptions} [opts=undefined]
   * @memberof MapView
   */


  function MapView(target, opts) {
    if (opts === void 0) {
      opts = undefined;
    }

    var _this = _super.call(this) || this;

    _this._ready = false;
    /*
     * Event Handlers
     */

    _this.handleLayerChange = function (e) {
      if (_this.timeline) {
        // enable or disable text animation instances based on current map layers
        var enabled = _this.config.hasText();

        var pastText = _this.timeline.get('pastText');

        var futureText = _this.timeline.get('futureText');

        if (pastText) pastText.enabled(enabled);
        if (futureText) futureText.enabled(enabled);
      }

      _this.trigger(MapView.Event.CHANGE_DATA, {
        layers: _this.config.data()
      });
    };

    _this.handleOffsetChange = function (e) {
      var offset = e.data.offset;

      if ((0, _utils.isset)(offset)) {
        offset = "" + offset;

        if (/^-/.test(offset) || offset === '0' || offset == 'current') {
          if (!(0, _utils.get)(_this.opts, 'animation.alwaysShowFuture')) {
            ['future', 'futureText'].forEach(function (type) {
              return _this._targets[type].hide();
            });
          }
        } else {
          if (!(0, _utils.get)(_this.opts, 'animation.alwaysShowPast')) {
            ['past', 'pastText'].forEach(function (type) {
              return _this._targets[type].hide();
            });
          }
        }

        if (_this._timestamp) {
          var time = (0, _utils.offsetToTime)(_this.config.offset());

          _this._timestamp.update(time);
        }
      }
    };

    _this._loadingGroups = [];
    _this.update = (0, _utils.debounce)(function (groups) {
      if (!_this._ready) return;
      var hasDataLayers = (_this.config.data() || []).length > 0;

      _this._animator.past.enabled(hasDataLayers);

      _this._animator.pastText.enabled(hasDataLayers);

      _this._animator.future.enabled(hasDataLayers);

      _this._animator.futureText.enabled(hasDataLayers);

      var types = groups || _this._loadingGroups; // now adjust types based on what actually needs updating

      types = _this._adjustTypesForUpdate(types);

      if (types.length === 0) {
        return;
      }

      if (_this.timeline) {
        _this.timeline.reset();
      }

      if (_this._timestamp && (!_this.timeline || !_this.timeline.isEnabled())) {
        var time = (0, _utils.offsetToTime)(_this.config.offset());

        _this._timestamp.update(time);
      }

      _this.trigger(MapView.Event.LOAD_START);

      var onComplete = function () {
        Object.keys(images).forEach(function (key) {
          _this.setImage(key, images[key]);
        }); // if (this.timeline) {
        // 	const animations = this.timeline.animations;
        // 	if (animations) {
        // 		Object.keys(animations).forEach(key => {
        // 			const anim = <ImageAnimation>animations[key];
        // 			if (anim.isEnabled()) {
        // 				// anim.element.show();
        // 			}
        // 		});
        // 	}
        // }

        _this.trigger(MapView.Event.LOAD_DONE);
      };

      var checkCompletion = function () {
        // console.log('checkCompletion', needed, needed.length);
        if (needed.length === 0) {
          onComplete();
        }
      };

      var images = {};
      var needed = types.slice(0);
      types.forEach(function (type) {
        var isFuture = type == 'future';
        var group = type;

        if (type === 'past' || type === 'future') {
          group = 'data';
        } else if (type === 'pastText' || type === 'futureText') {
          group = 'text';
        }

        var hasLayers = (0, _utils.isset)(_this.config.opts("layers." + group));

        if (hasLayers) {
          if (_this.timeline && (group === 'data' || group === 'text')) {
            var anim = _this.timeline.get(type);

            if (anim) {
              // anim.element.hide();
              if (!anim.canShow()) {
                needed.splice(needed.indexOf(type), 1);
                checkCompletion();
              } else {
                anim.once('load:image load:error', function (e) {
                  needed.splice(needed.indexOf(type), 1);
                  checkCompletion();
                });
              }

              anim.goToTime(_this.timeline.currentTime);
            }

            return;
          }

          var request = _this._request.clone();

          request.setParams(_this.config.toRequestOpts([group], isFuture));
          request.get().then(function (result) {
            // console.log('done loading', type, result.image);
            needed.splice(needed.indexOf(type), 1);

            if (result.image) {
              images[type] = result.image.src;
            }

            checkCompletion();
          }).catch(function (e) {
            console.error('ERROR', e);
          });
        } else {
          _this.setImage(type, null);
        }
      });
    }, 500);

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for MapView');
    } // convert comma-separated strings to arrays


    ['base', 'data', 'overlays'].forEach(function (k) {
      var key = "map.layers." + k;
      var val = (0, _utils.get)(opts, key);

      if ((0, _utils.isString)(val)) {
        (0, _utils.set)(opts, key, val.replace(/\s/, '').split(','));
      }
    });
    _this._opts = (0, _utils.extend)({
      account: null,
      map: {
        layers: {
          base: ['flat'],
          overlays: ['admin']
        },
        size: {
          width: 600,
          height: 400
        },
        autoFuture: true,
        combine: false
      },
      animation: {
        enabled: true,
        from: -2 * 3600,
        to: 0,
        autoplay: false,
        alwaysShowPast: false,
        alwaysShowFuture: false
      },
      overlays: {
        title: undefined,
        timestamp: 'MM/DD/YYYY hh:mm A',
        branding: {
          html: undefined,
          img: undefined
        }
      },
      legend: {
        enabled: true
      },
      controls: {
        layers: undefined,
        regions: undefined
      }
    }, opts);
    _this._target = (0, _DOM.default)(target);
    _this._config = new _MapConfig.default(_this._opts.map);

    _this._config.on('change', function () {
      return _this.trigger(MapView.Event.CHANGE);
    });

    if (_this.account) {
      _this._request = new _MapRequest.default({
        server: (0, _utils.get)(_this._opts, 'servers.maps'),
        client: _this.account.credentials()
      });
    }

    _this._layers = new _Layers.default();

    _this._layers.fetch().then(function (data) {
      _this.config.layers = _this._layers;

      _this.render();
    });

    return _this;
  }

  Object.defineProperty(MapView.prototype, "$el", {
    /**
     * Primary DOM element associated with the view.
     *
     * @readonly
     * @type {*}
     * @memberof MapView
     */
    get: function () {
      return this._target;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "$map", {
    /**
     * DOM element associated with the map.
     *
     * @readonly
     * @type {*}
     * @memberof MapView
     */
    get: function () {
      return this._map;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "$container", {
    /**
     * DOM element associated with the map's container.
     *
     * @readonly
     * @type {*}
     * @memberof MapView
     */
    get: function () {
      return (0, _DOM.default)("." + _globals.Globals.cssPrefix + "map-container", this.$el);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "account", {
    /**
     * Aeris account used for the map data requests.
     *
     * @readonly
     * @type {Account}
     * @memberof MapView
     */
    get: function () {
      return this.opts.account;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "opts", {
    /**
     * Configuration options for the view.
     *
     * @readonly
     * @type {{ [key: string]: any }}
     * @memberof MapView
     */
    get: function () {
      return this._opts;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "config", {
    /**
     * Map configuration instance managing the underlying map imagery.
     *
     * @readonly
     * @type {MapConfig}
     * @memberof MapView
     */
    get: function () {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "timeline", {
    /**
     * Animation timeline used to control the map view's current time and animation.
     *
     * @readonly
     * @type {Timeline}
     * @memberof MapView
     */
    get: function () {
      if (this._animator) {
        return this._animator.timeline;
      }

      return null;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MapView.prototype, "legend", {
    /**
     * Legend view associated with the map.
     *
     * @readonly
     * @type {LegendView}
     * @memberof MapView
     */
    get: function () {
      return this._legend;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the DOM element within the view's container for the specified selector.
   *
   * @param {string} selector
   * @returns {*}
   * @memberof MapView
   */

  MapView.prototype.el = function (selector) {
    return (0, _DOM.default)(selector, this.$el);
  };
  /**
   * Sets the map layers.
   *
   * The legend displayed for the specified map layers can be overridden by providing a value for
   * the `legend` parameter, which can either be an array of layer codes for multiple
   * auto-configured legends, or a single URL string for a single legend image.
   *
   * @param {MapConfigLayersOptions} layers
   * @param {string} [legend]
   * @memberof MapView
   */


  MapView.prototype.setLayers = function (layers, legend) {
    this.config.setLayers(layers);

    if (legend) {
      this.setLegend(legend);
    }
  };
  /**
   * Sets the legend type(s) or image URL to display. If a source URL is provided, then this
   * image will be displayed regardless of which layer types exist on the map.
   *
   * @param {(string | string[])} source
   * @memberof MapView
   */


  MapView.prototype.setLegend = function (source) {
    this._legendUrl = null;

    if (source) {
      if ((0, _utils.isString)(source)) {
        var str = source;

        if (str.match(/^(https?:)?\/\//)) {
          this._legendUrl = str;
          this.legend.setUrl(str);
        } else {
          this.legend.set(str.replace(/\s/g, '').split(','));
        }
      } else if ((0, _utils.isArray)(source)) {
        this.legend.set(source);
      }
    }
  };
  /**
   * Sets the units to display on the map view.
   *
   * @param {boolean} metric
   * @memberof MapView
   */


  MapView.prototype.setMetric = function (metric) {
    this.config.setMetric(metric);
  };

  MapView.prototype.render = function () {
    this.$el.empty();
    this.$el.html("\n\t\t\t<div class=\"awxjs__mapview\">\n\t\t\t\t<ul class=\"awxjs__map-nav\"></ul>\n\t\t\t\t<div class=\"awxjs__map-container\">\n\t\t\t\t\t<div class=\"awxjs__map\">\n\t\t\t\t\t\t<ul class=\"awxjs__map-region-nav horizontal\"></ul>\n\t\t\t\t\t\t<ul class=\"awxjs__map-anim-controls\">\n\t\t\t\t\t\t\t<li data-anim-action=\"toggle\"><button>Play</button></li>\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"awxjs__map-legend\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t");
    var opts = this.opts;
    var $map = (0, _DOM.default)("." + _globals.Globals.cssPrefix + "map-container > ." + _globals.Globals.cssPrefix + "map", this.$el);
    this._map = $map;
    var w = $map.width() || 320;
    var h = $map.height() || 300;

    if (opts.map.size) {
      w = opts.map.size.width || w;
      h = opts.map.size.height || h;

      if (w === 'auto') {
        w = $map.width();
        opts.map.size.width = w; // enable auto-resizing of map width if configured

        if (opts.map.size.autoscale) {
          (0, _DOM.default)(window).on('resize', function (e) {
            var nw = $map.width(); // this._map.setWidth(w);

            opts.map.size.width = nw;
          });
        }
      }
    }

    var _a = this.config.size(),
        width = _a.width,
        height = _a.height;

    if (width && height) {
      $map.width(width).height(height);
      this.$container.width(width);
    }

    if (opts.map.region && !opts.map.bounds) {
      this.config.setRegion(opts.map.region);
    }

    var overlays = this.opts.overlays;
    var controls = this.opts.controls;
    var anim = this.opts.animation;
    var legend = this.opts.legend;
    this.setupContainers($map);

    if (overlays) {
      this.setupOverlays(overlays);
    }

    if (controls) {
      this.setupControls(controls);
    }

    if (anim) {
      this.setupAnimation(anim);
    }

    if (legend) {
      this.setupLegend(legend);
    }

    this.setupEvents();
    this.trigger(MapView.Event.READY);
    this._ready = true;
    this.updateGroups();
  };

  MapView.prototype.setupEvents = function () {
    var _this = this;

    this.config.on('change:data change:offset', function (e) {
      _this.updateGroups(['past', 'future']);
    });
    this.config.on('change:units', function (e) {
      _this.updateGroups(['pastText', 'futureText']);
    });
    this.config.on('change:data', this.handleLayerChange);
    this.config.on('change:bounds change:size', function (e) {
      _this.updateGroups();
    });
    this.config.on('change:size', function (e) {
      var _a = e.data,
          width = _a.width,
          height = _a.height;

      if (width && height) {
        _this.$map.width(width).height(height);

        _this.$container.width(width);
      }
    });

    if (!this.timeline) {
      this.config.on('change:offset', this.handleOffsetChange);
      this.config.setOffset(this.config.offset());
    }

    if (this._timestamp && this.timeline) {
      var ts_1 = this._timestamp;

      if (ts_1.continuous() === false) {
        this.timeline.on('advance:image', function (e) {
          ts_1.update(e.data.time);
        });
      } else {
        this.timeline.on('advance', function (e) {
          ts_1.update(e.data.time);
        });
      } // since our main animation is a timeline of combined animations, we need to listen for loading progress on either the past or
      // future animation instance within the timeline to update the timestamp; we can't do both since both will load concurrently if the
      // timeline spans past and future time periods


      if (this.timeline instanceof _Timeline.default) {
        Object.keys(this.timeline.animations).forEach(function (key) {
          var targetAnim = _this.timeline.get(key);

          var target;

          if (targetAnim.isEnabled()) {
            if (key === 'past') {
              target = targetAnim;
            } else if (key === 'future') {
              target = targetAnim;
            }
          }

          if (target) {
            target.on('load:progress', function (e) {
              if (target.canShow()) {
                ts_1.update(e.data.time);
              }
            });
          }
        });
      }
    }
  };

  MapView.prototype.setupContainers = function ($map) {
    var _this = this;

    var layersSel = _globals.Globals.cssPrefix + "map__layers";
    $map.append("<div class=\"" + layersSel + "\"></div>");
    var $layers = this.el("." + layersSel);
    this._indicator = new _ActivityIndicator.default();

    this._indicator.appendTo($layers[0]);

    this.on('load:start', function () {
      _this._indicator.startAnimating();
    });
    this.on('load:done', function () {
      _this._indicator.stopAnimating();
    }); // map.ext.append(this._indicator.element);

    var containerKeys = this.opts.map.combine ? containers.combined : containers.split; // create separate containers for base, past, future and overlay layers so we only have to animate content in the past and future layers

    var targets = {};
    containerKeys.forEach(function (key, i) {
      var sel = _globals.Globals.cssPrefix + "map-layer-" + key;
      $layers.append("<div class=\"" + sel + "\"></div>");
      var storeKey = (0, _strings.camelcase)(key);
      var $target = (0, _DOM.default)("." + sel, $layers);
      $target.css({
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        "z-index": i
      });
      targets[storeKey] = $target;
    });
    this._targets = targets;
  };

  MapView.prototype.setupControls = function (config) {
    var _this = this;

    if (config.layers) {
      var $target_1 = this.el("." + _globals.Globals.cssPrefix + "map-nav");
      config.layers.forEach(function (layer) {
        $target_1.append("<li data-map-layer=\"" + layer.value + "\"><button>" + layer.title + "</button></li>");
      });
      var $buttons_1 = (0, _DOM.default)('li', $target_1);
      $buttons_1.on('click', function (e) {
        e.preventDefault();
        var $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        var layers = $el.allData('map-layer');
        $buttons_1.removeClass('selected');
        $el.addClass('selected');

        if (layers) {
          _this.config.setData(layers.split(','));
        }
      }); // select initial button based on config options

      this.on('ready', function (e) {
        var initialLayers = (0, _utils.get)(_this.opts, 'map.layers.data') || null;

        if (initialLayers) {
          $buttons_1.each(function (el, i) {
            var $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-layer') === initialLayers.join(',')) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons_1.get(0).click();
        }
      });
    }

    if (config.regions) {
      var self_1 = this;
      var $target_2 = this.el("." + _globals.Globals.cssPrefix + "map-region-nav");
      config.regions.forEach(function (region) {
        var data = Object.keys(region).reduce(function (prev, current) {
          if (current !== 'title') {
            var val = region[current];

            if ((0, _utils.isObject)(val)) {
              if (current === 'center') {
                val = val.lat + "," + val.lon;
              } else if (current === 'bounds') {
                val = val.north + "," + val.west + "," + val.south + "," + val.east;
              }
            }

            prev.push("data-map-" + current + "=\"" + val + "\"");
          }

          return prev;
        }, []);
        $target_2.append("<li " + data.join(' ') + "><button>" + region.title + "</button></li>");
      });
      var $buttons_2 = (0, _DOM.default)('li', $target_2);
      $buttons_2.on('click', function (e) {
        e.preventDefault();
        var $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        var zoom = $el.allData('map-zoom');
        var center = $el.allData('map-center') || (0, _utils.get)(_this.opts, 'map.center');
        var region = $el.allData('map-region');
        var bounds = $el.allData('map-bounds');
        $buttons_2.removeClass('selected');
        $el.addClass('selected');

        if (region) {
          self_1.config.setRegion(region);
        } else if (bounds) {
          var b = bounds.split(',');

          if (b.length === 4) {
            self_1.config.setBounds({
              north: b[0],
              west: b[1],
              south: b[2],
              east: b[3]
            });
          }
        } else if (center && !(0, _utils.isEmpty)(center)) {
          if ((0, _utils.isset)(zoom) && zoom > 0) {
            self_1.config.setCenter(center, zoom);
          } else {
            self_1.config.setCenter(center, _this.config.zoom());
          }
        } else if (zoom > 0) {
          self_1.config.setZoom(zoom);
        }
      }); // select initial button based on config options

      this.on('ready', function (e) {
        var initialZoom = (0, _utils.get)(_this.opts, 'map.zoom') || null;

        if ((0, _utils.isset)(initialZoom)) {
          $buttons_2.each(function (el, i) {
            var $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-zoom') === "" + initialZoom) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons_2.get(0).click();
        }
      });
    }
  };

  MapView.prototype.setupOverlays = function (config) {
    var layersSel = _globals.Globals.cssPrefix + "map__overlays";
    this.$map.append("<div class=\"" + layersSel + "\"></div>");
    var $target = this.el("." + layersSel); // map timestamp

    if (config.timestamp) {
      var opts = config.timestamp;

      if ((0, _utils.isString)(opts)) {
        opts = {
          format: opts
        };
      }

      var timestamp = new MapTimestamp(opts);
      timestamp.element.css({
        "z-index": 10
      });
      $target.append(timestamp.element);
      this._timestamp = timestamp;
    } // map title


    if (config.title) {
      var sel = _globals.Globals.cssPrefix + "map-overlay__title";
      $target.append("<div class=\"" + sel + "\">" + config.title + "</div>");
      (0, _DOM.default)("." + sel, $target).css({
        "z-index": 11
      });
    } // map branding


    if (config.branding) {
      var _a = config.branding,
          img = _a.img,
          html = _a.html;
      var sel = _globals.Globals.cssPrefix + "map-overlay__branding";
      $target.append("<div class=\"" + sel + "\"></div>");
      var $branding = (0, _DOM.default)("." + sel, $target);
      $branding.css({
        "z-index": 12
      });

      if ((0, _utils.isset)(img)) {
        $branding.html("<img src=\"" + img + "\" />");
      } else if ((0, _utils.isset)(html)) {
        $branding.html(html);
      }
    }
  };

  MapView.prototype.setupAnimation = function (config) {
    var _this = this;

    var $controls = this.el('.awxjs__map-anim-controls > li'); // const $btnAnimate = $('li', $controls);
    // if animation is disabled, we only use the `animation.to` value so update the `from` value to match

    if (!config.enabled) {
      this.config.setOffset((0, _utils.get)(this.opts, 'map.offset') || 0);
      $controls.remove();
      return;
    }

    var animator = new _MapViewAnimator.default({
      past: this._targets.past,
      future: this._targets.future,
      pastText: this._targets.pastText,
      futureText: this._targets.futureText
    }, config);
    animator.provider = this;
    this._animator = animator;
    var timeline = animator.timeline; // show activity indicator while animation data is loading

    timeline.on('load:start', function () {
      _this._indicator.startAnimating();
    });
    timeline.on('load:done load:error', function () {
      _this._indicator.stopAnimating();
    }); // disable future layers for map if animation doesn't extend into the future

    this.config.opts('autoFuture', timeline.containsFuture());
    timeline.on('end:change', function (e) {
      _this.config.opts('autoFuture', timeline.containsFuture());
    });
    timeline.on('start:change end:change', function (e) {
      // show or hide animate button based on whether animation can actually animate
      if (timeline.canAnimate()) {
        $controls.show();
      } else {
        $controls.hide();
      }
    });

    if (!timeline.canAnimate()) {
      $controls.hide();
    }

    this.on('ready', function () {
      // need to reset animation and clear its image cache if the map's data layers change
      _this.config.on('change:data change:size change:zoom change:offset change:center change:bounds', function (e) {// timeline.reset();
      });

      _this.config.on('change:units', function (e) {
        timeline.stop();
        var pastTextAnim = timeline.get('pastText');

        if (pastTextAnim) {
          pastTextAnim.reset();
        }

        var futureTextAnim = timeline.get('futureText');

        if (futureTextAnim) {
          futureTextAnim.reset();
        }
      });

      if (timeline.isAutoPlay()) {
        timeline.play();
      } else {
        timeline.goToInit();
      }
    }); // // toggle animation when clicking on layers container
    // $layers.on('click', (e: any) => {
    // 	this.timeline.toggle();
    // });

    $controls.each(function (el) {
      var $el = (0, _DOM.default)(el);
      var action = $el.allData('anim-action');

      if (action === 'toggle') {
        var $btn_1 = (0, _DOM.default)('button', $el);
        timeline.on('play load:start', function () {
          $btn_1.html('Stop');
        });
        timeline.on('stop', function () {
          $btn_1.html('Play');
        });
      }
    }).on('click', function (e) {
      e.preventDefault();
      var $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
      var action = $el.allData('anim-action');

      if (action === 'toggle') {
        timeline.toggle();
      } else if (action === 'play') {
        timeline.play();
      } else if (action === 'pause') {
        timeline.pause();
      } else if (action === 'stop') {
        timeline.stop();
      }
    });
  };

  MapView.prototype.setupLegend = function (config) {
    var _this = this;

    var $legend = this.el('.awxjs__map-legend');

    if (!config.enabled) {
      $legend.remove();
      return;
    }

    var legend = new _LegendView.default($legend, (0, _utils.extend)({
      size: {
        width: this.$map.width()
      }
    }, config));
    this._legend = legend;
    var update = (0, _utils.debounce)(function () {
      // don't update legend based on map layer types if we have defined a value for _legendSource
      if (_this._legendUrl) return;

      var layers = _this.config.data();

      var opts = {
        account: _this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      if (layers && layers.indexOf('alerts') !== -1) {
        opts.within = {
          bounds: _this.config.bounds(),
          center: _this.config.center(),
          zoom: _this.config.zoom(),
          size: _this.config.size()
        };
      }

      legend.set(layers, opts);
    }, 50);
    this.config.on('change:data change:bounds', function (e) {
      update();
    });
    this.config.on('change:size', function (e) {
      legend.setWidth(e.data.width);
    });
    this.config.on('change:metric', function (e) {
      legend.setMetric(e.data.metric);
    });
    update();
  };
  /*
   * Image Methods
   */


  MapView.prototype.setImage = function (type, url) {
    var target = (0, _DOM.default)("." + _globals.Globals.cssPrefix + "map-layer-" + type, this.$el);

    if (target) {
      target.empty();

      if (url) {
        target.append("<img src=\"" + url + "\" width=\"" + this.config.size().width + "\" height=\"" + this.config.size().height + "\">");
      }
    }
  };

  MapView.prototype.updateGroups = function (groups) {
    var _this = this;

    groups = groups || ['base', 'past', 'future', 'overlays'];
    groups.forEach(function (group) {
      if (_this._loadingGroups.indexOf(group) === -1) {
        _this._loadingGroups.push(group);
      }
    });
    this.update();
  };

  MapView.prototype._adjustTypesForUpdate = function (types) {
    var filtered = types.splice(0);
    var now = new Date().getTime();

    if (this.timeline && this.timeline.isEnabled()) {
      // remove `past` if animation's start time doesn't start in the past
      var pastIndex = filtered.indexOf('past');

      if (pastIndex > -1 && this.timeline.startDate().getTime() > now) {
        filtered.splice(pastIndex, 1);
      } // remove `future` if animation's end time doesn't extend beyond now


      var futureIndex = filtered.indexOf('future');

      if (futureIndex > -1 && this.timeline.endDate().getTime() <= now && this._animator.timeline.get('future').canShow() === false) {
        filtered.splice(futureIndex, 1);
      }
    }

    if (this.config.hasText()) {
      if (filtered.indexOf('past') > -1) {
        filtered.push('pastText');
      }

      if (filtered.indexOf('future') > -1) {
        filtered.push('futureText');
      }
    }

    return filtered;
  };
  /*
   * ImageAnimationProvider
   */


  MapView.prototype.animationUrlForDate = function (animation, date) {
    var request = this._request.clone();

    var group = /text$/i.test(animation.key) ? 'text' : 'data';
    var options = this.config.toRequestOpts([group], animation.isFuture());

    if (group === 'data' && (0, _utils.isset)(options.layers.data) || group === 'text' && (0, _utils.isset)(options.layers.text)) {
      request.setParams(options);
      request.date(date);
      return request.url();
    }

    return null;
  };

  MapView.prototype.animationSizeForImage = function (animation) {
    return this.config.size();
  };
  /**
   * Events that can be triggered by a `MapView` instance.
   *
   * @static
   * @memberof MapView
   */


  MapView.Event = {
    /** Fired when the map is initialized and rendered. */
    READY: 'ready',

    /** Fired when any map property has changed, such as layers, size, region, etc. */
    CHANGE: 'change',

    /** Fired when the map weather data layers have changed. */
    CHANGE_DATA: 'change:data',

    /** Fired when map data begins loading. */
    LOAD_START: 'load:start',

    /** Fired when map data has completed loading. */
    LOAD_DONE: 'load:done'
  };
  return MapView;
}(_EventDispatcher.default);

var _default = MapView;
exports.default = _default;
module.exports = exports.default;