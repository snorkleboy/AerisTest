"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _Legend = _interopRequireDefault(require("./Legend"));

var _AdvisoryLegend = _interopRequireDefault(require("./AdvisoryLegend"));

var _GroupedLegend = _interopRequireDefault(require("./GroupedLegend"));

var _Http = _interopRequireDefault(require("../../../network/Http"));

var _utils = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

/**
 * A legend view is responsible for displaying and manging a series of legend elements.
 *
 * @export
 * @class LegendView
 * @extends {EventDispatcher}
 */
var LegendView =
/** @class */
function (_super) {
  __extends(LegendView, _super);
  /**
   * Initializes and returns a legend view instance with the specified target and configuration
   * object.
   *
   * @param {*} target
   * @param {LegendOptions} [opts]
   * @memberof LegendView
   */


  function LegendView(target, opts) {
    var _this = _super.call(this) || this;

    _this._loading = false;
    _this._loadCallbacks = {};

    _this._onResize = function () {
      _this.trigger('resize', _this.getSize());
    };

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for LegendView');
    }

    _this._opts = (0, _utils.extend)({
      size: {
        width: 400,
        height: 40
      }
    }, opts);
    _this._legends = {};
    _this._mapping = {};
    (0, _DOM.default)(target).append("<div class=\"awxjs__legend-view\"></div>");
    _this._target = (0, _DOM.default)('.awxjs__legend-view', target);
    return _this;
  }

  Object.defineProperty(LegendView.prototype, "$el", {
    /**
     * The DOM element for the legend view.
     *
     * @readonly
     * @type {*}
     * @memberof LegendView
     */
    get: function () {
      return this._target;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(LegendView.prototype, "count", {
    get: function () {
      return Object.keys(this._legends).length;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Adds a legend for the specified legend type code and options.
   *
   * @param {string} type
   * @param {LegendOptions} [opts]
   * @returns
   * @memberof LegendView
   */

  LegendView.prototype.add = function (type, opts) {
    var _this = this; // load default legend styles if not already cached


    if (!this._styles) {
      this._loadCallbacks[type] = function () {
        _this.add(type, opts);
      };

      if (this._loading === false) {
        this._loadStyles();
      }

      return;
    }

    var style = this._styleForType(type);

    var key = style.key;
    var styles = style.style;
    opts = (0, _utils.extend)((0, _utils.cloneDeep)(this._opts), opts);

    if (!(0, _utils.isset)(styles)) {
      return;
    }

    styles = (0, _utils.extend)({}, styles, {
      styles: opts.styles
    });
    var legendOpts = (0, _utils.extend)(opts, {
      title: styles.title,
      size: this._opts.size,
      autosize: this._opts.autosize,
      format: this._opts.format,
      metric: this._opts.metric,
      styles: styles
    }); // just update the legend as needed if it already exists

    if (this._legends[key]) {
      this._legends[key].update(legendOpts);

      return;
    }

    var legend;

    if (styles && !(0, _utils.isEmpty)(styles)) {
      // determine if we need a grouped legend or a single one
      if (styles.grouped && styles.items) {
        legendOpts.types = styles.items.reduce(function (prev, current) {
          var itemStyle = _this._styleForType(current.key).style;

          prev[current.key] = (0, _utils.extend)({
            factor: current.factor,
            size: {
              width: Math.floor(_this._opts.size.width * current.factor),
              height: _this._opts.size.height
            }
          }, itemStyle);
          return prev;
        }, {});
        legend = new _GroupedLegend.default(key, legendOpts);
      } else if (type === 'alerts' || type === 'advisories') {
        legend = new _AdvisoryLegend.default(key, legendOpts);
      } else {
        legend = new _Legend.default(key, legendOpts);
      }

      this.addLegend(legend);

      if (!this._mapping[key]) {
        this._mapping[key] = [];
      }

      if (this._mapping[key].indexOf(type) === -1) {
        this._mapping[key].push(type);
      }
    }
  };
  /**
   * Adds a legend item to the view.
   *
   * @param {ILegendRenderable} legend
   * @memberof LegendView
   */


  LegendView.prototype.addLegend = function (legend) {
    this._legends[legend.key] = legend;
    this.$el.append(legend.$el);
    this.$el.show();

    if (legend instanceof _EventDispatcher.default) {
      legend.on('resize', this._onResize);
    }

    this.trigger('add', {
      key: legend.key,
      count: Object.keys(this._legends).length
    });

    this._onResize();
  };
  /**
   * Updates the legend view for the specified type codes and options. All previously existing
   * legends will be removed.
   *
   * @param {string[]} types
   * @param {*} [opts]
   * @memberof LegendView
   */


  LegendView.prototype.set = function (types, opts) {
    var _this = this;

    types = types || [];
    this.removeAll(types);
    types.forEach(function (type) {
      if (!_this.has(type)) {
        _this.add(type, opts);
      } else {
        _this.get(type).update(opts);
      }
    });
  };
  /**
   * Sets the legend using a static image URL. All previously existing legends will be removed.
   *
   * @param {string} url
   * @memberof LegendView
   */


  LegendView.prototype.setUrl = function (url) {
    this.removeAll();
    this.$el.empty();
    this.$el.append("<div class=\"awxjs__legend\"><img src=\"" + url + "\"></div>");
  };
  /**
   * Returns the legend for the specified type code if it exists in the view.
   *
   * @param {string} type
   * @returns {ILegendRenderable}
   * @memberof LegendView
   */


  LegendView.prototype.get = function (type) {
    var key = this._styleForType(type).key;

    if (key) {
      return this._legends[key];
    }

    return null;
  };
  /**
   * Removes the legend for the specified type code.
   *
   * @param {string} type
   * @memberof LegendView
   */


  LegendView.prototype.remove = function (type) {
    var key = this._styleForType(type).key;

    if (key) {
      var legend = this._legends[key];

      if (legend) {
        this.removeLegend(legend);
      }

      if (legend instanceof _EventDispatcher.default) {
        legend.off('resize', this._onResize);
      }

      this._onResize();
    }

    if (this.count === 0) {
      this.$el.hide();
      this.trigger('empty');
    }
  };
  /**
   * Removes a legend item from the view.
   *
   * @param {ILegendRenderable} legend
   * @memberof LegendView
   */


  LegendView.prototype.removeLegend = function (legend) {
    if (legend) {
      legend.$el.remove();
      delete this._legends[legend.key];
      this.trigger('remove', {
        key: legend.key,
        count: Object.keys(this._legends).length
      });
    }
  };
  /**
   * Removes all existing legends from the view.
   *
   * @param {string[]} [exclude]
   * @memberof LegendView
   */


  LegendView.prototype.removeAll = function (exclude) {
    var _this = this;

    Object.keys(this._legends).forEach(function (key) {
      var remove = true;

      if (exclude) {
        var altkeys = _this._mapping ? _this._mapping[key] : [];

        if (exclude.indexOf(key) !== -1) {
          remove = false;
        } else if (altkeys) {
          altkeys.forEach(function (k) {
            if (exclude.indexOf(k) !== -1) {
              remove = false;
            }
          });
        }
      }

      if (remove) {
        _this.remove(key);
      }
    });
  };
  /**
   * Returns whether the view contains a legend for the specified type code.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof LegendView
   */


  LegendView.prototype.has = function (type) {
    var key = this._styleForType(type).key;

    if (key) {
      return (0, _utils.isset)(this._legends[key]);
    }

    return false;
  };
  /**
   * Forces an update of all existing legends.
   *
   * @param {{ [key: string]: any }} [opts]
   * @memberof LegendView
   */


  LegendView.prototype.update = function (opts) {
    this._each(function (key, legend) {
      return legend.update(opts);
    });
  };
  /**
   * Sets whether the display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof LegendView
   */


  LegendView.prototype.setMetric = function (metric) {
    this._opts.metric = metric;

    this._each(function (key, legend) {
      return legend.setMetric(metric);
    });
  };
  /**
   * Sets the size of the view and existing legends.
   *
   * @param {ISize} size
   * @memberof LegendView
   */


  LegendView.prototype.setSize = function (size) {
    this._opts.size = size;

    this._each(function (key, legend) {
      return legend.setSize(size);
    });
  };

  LegendView.prototype.getSize = function () {
    var height = 0;
    var width = 0;

    this._each(function (key, legend) {
      var size = legend.getSize();
      height += size.height;
      width = Math.max(width, size.width);
    });

    return {
      width: width,
      height: height
    };
  };
  /**
   * Sets the width of the view and all existing legends. The previous height value will be
   * used.
   *
   * @param {number} width
   * @memberof LegendView
   */


  LegendView.prototype.setWidth = function (width) {
    var height = this._opts.size.height;
    this.setSize({
      width: width,
      height: height
    });
  };

  LegendView.prototype._styleForType = function (type) {
    var _this = this;

    if (!this._styles) return {
      key: null,
      style: null
    };
    var styles = this._styles[type];
    var altkey;

    if (!styles && /^f/.test(type)) {
      altkey = type.replace(/^f/, '');
      styles = this._styles[altkey];
    }

    if (!styles) {
      Object.keys(this._styles).forEach(function (key) {
        var defaults = _this._styles[key];
        var enabled = defaults.enabled === true || !(0, _utils.isset)(defaults.enabled);

        if (enabled) {
          var layers = defaults.layers;

          if (layers) {
            layers.forEach(function (pattern) {
              var re = new RegExp(pattern);

              if (re.test(type)) {
                styles = (0, _utils.cloneDeep)(defaults);
                altkey = key;
              }
            });

            if (styles && !altkey) {
              altkey = key;
            }
          }
        }
      });
    }

    return {
      key: altkey || type,
      style: styles
    };
  };

  LegendView.prototype._reset = function () {
    this.$el.empty();

    this._each(function (key, legend) {
      return legend.reset();
    });
  };

  LegendView.prototype._each = function (fn) {
    var _this = this;

    Object.keys(this._legends).forEach(function (key) {
      return fn(key, _this._legends[key]);
    });
  };

  LegendView.prototype._loadStyles = function () {
    var _this = this;

    this._loading = true;
    return new Promise(function (resolve, reject) {
      return __awaiter(_this, void 0, void 0, function () {
        var _this = this;

        return __generator(this, function (_a) {
          if (this._styles) {
            resolve(this._styles);
            return [2
            /*return*/
            ];
          }

          _Http.default.request('https://legends.aerisapi.com/defaults.json').then(function (res) {
            if (res.data) {
              var configs_1 = res.data;
              Object.keys(configs_1).forEach(function (key) {
                var config = configs_1[key];

                if (config.config) {
                  // convert underscore keys to dot-notation
                  Object.keys(config.config).forEach(function (configKey) {
                    if (configKey.indexOf('_') !== -1) {
                      var setKey = configKey.replace(/^labels_/, 'label_').replace(/_/g, '.');
                      (0, _utils.set)(config.config, setKey, config.config[configKey]);
                      delete config.config[configKey];
                    }
                  });
                  config.styles = (0, _utils.cloneDeep)(config.config);
                  delete config.config;
                }
              });
              _this._styles = configs_1;
              _this._loading = false;
              resolve((0, _utils.cloneDeep)(_this._styles));
              Object.keys(_this._loadCallbacks).forEach(function (key) {
                var fn = _this._loadCallbacks[key];
                fn();
              });
            }
          });

          return [2
          /*return*/
          ];
        });
      });
    });
  };

  return LegendView;
}(_EventDispatcher.default);

var _default = LegendView;
exports.default = _default;
module.exports = exports.default;