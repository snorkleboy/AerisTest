"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _types = require("./types");

var _utils = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A legend implements the `ILegendRenderable` interface and is responsible for rendering a legend
 * image based on a specific legend configuration and style.
 *
 * @export
 * @class Legend
 * @implements {ILegendRenderable}
 */
var Legend =
/** @class */
function (_super) {
  __extends(Legend, _super);
  /**
   * Initializes and returns a legend for the specified key and configuration options.
   *
   * @param {string} key
   * @param {LegendOptions} opts
   * @memberof Legend
   */


  function Legend(key, opts) {
    var _this = _super.call(this) || this;

    _this._load = (0, _utils.debounce)(function () {
      var url = _this._url();

      if (!url) {
        var error = new Error('Invalid legend url');

        _this.trigger('load:error', {
          error: error
        });

        _this.$el.hide();

        return;
      }

      if (!_this._image) {
        _this._image = new Image();
      }

      _this.trigger('load:start');

      _this._image.onload = function () {
        var units = _this.units();

        var title = _this._opts.title ? _this._opts.title.replace(/\([^\)]+\)$/, "" + (units ? "(" + units + ")" : '')) : null;

        _this.$el.html("\n\t\t\t\t" + (_this._opts.title ? "<div class=\"awxjs__legend-title\">" + title + "</div>" : '') + "\n\t\t\t\t<div class=\"awxjs__legend-content\"><img src=\"" + url + "\"></div>\n\t\t\t"); // this.$el.show();


        _this.trigger('load:done');

        setTimeout(function () {
          var size = _this.getSize();

          size.width = Math.max(size.width, _this._image.width);

          _this.$el.css('width', size.width + "px");

          _this.trigger('resize', size);
        }, 150);
      };

      _this._image.src = url;
    }, 250);
    _this._key = key;
    _this._opts = (0, _utils.extend)({
      size: undefined,
      autosize: false,
      format: 'svg',
      metric: false
    }, opts);

    if (!(0, _utils.isset)(_this._opts.size)) {
      _this._opts.autosize = true;
    }

    _this._target = (0, _DOM.default)("<div class=\"awxjs__legend awxjs__legend-" + key + "\"></div>");

    _this._update();

    return _this;
  }

  Object.defineProperty(Legend.prototype, "opts", {
    /**
     * Configuration options.
     *
     * @readonly
     * @type {LegendOptions}
     * @memberof Legend
     */
    get: function () {
      return this._opts;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Legend.prototype, "key", {
    /**
     * Key associated with the legend.
     *
     * @readonly
     * @type {string}
     * @memberof Legend
     */
    get: function () {
      return this._key;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Legend.prototype, "account", {
    /**
     * Aeris account used when requesting data for dynamic legends.
     *
     * @readonly
     * @type {Account}
     * @memberof Legend
     */
    get: function () {
      return this.opts.account;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Legend.prototype, "$el", {
    /**
     * DOM element for the legend.
     *
     * @readonly
     * @type {*}
     * @memberof Legend
     */
    get: function () {
      return this._target;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Shows the legend DOM element.
   *
   * @memberof Legend
   */

  Legend.prototype.show = function () {
    this.$el.show();
  };
  /**
   * Hides the legend DOM element.
   *
   * @memberof Legend
   */


  Legend.prototype.hide = function () {
    this.$el.hide();
  };
  /**
   * Sets the size of the legend.
   *
   * @param {ISize} size
   * @memberof Legend
   */


  Legend.prototype.setSize = function (size) {
    this._opts.size = (0, _utils.extend)(this._opts.size, size);

    this._update();
  };

  Legend.prototype.getSize = function () {
    if (this.$el) {
      var bounds = this.$el.bounds();
      var h = this.$el.outerHeight(true);
      return {
        width: bounds.width,
        height: h
      };
    }

    return {
      width: 0,
      height: 0
    };
  };
  /**
   * Sets whether to display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof Legend
   */


  Legend.prototype.setMetric = function (metric) {
    this._opts.metric = metric;

    this._update();
  };
  /**
   * Returns the unit based on whether the legend is displaying values in Metric or Imperial.
   *
   * @returns {string}
   * @memberof Legend
   */


  Legend.prototype.units = function () {
    var key = this._opts.metric ? 'metric' : 'imperial';
    var unit = (0, _utils.get)(this._opts, "styles.units." + key);

    if (unit && /^(f|c)$/.test(unit)) {
      unit = unit.toUpperCase();
    }

    return unit;
  };
  /**
   * Resets the legend by removing an existing image.
   *
   * @memberof Legend
   */


  Legend.prototype.reset = function () {
    this.$el.empty();

    if (this._image) {
      this._image.onload = null;
    }

    this._image = null;
  };
  /**
   * Forces the legend to update if needed.
   *
   * @param {*} [opts]
   * @memberof Legend
   */


  Legend.prototype.update = function (opts) {};

  Legend.prototype._update = function () {
    this._load();
  };

  Legend.prototype._url = function () {
    var config = this._opts;
    var style = (0, _utils.extend)({
      interval: 1,
      gutter: null,
      radius: 6,
      columns: 4,
      metric: false,
      orientation: _types.LegendOrientation.HORIZONTAL,
      cell: {
        size: {
          width: 2,
          height: 10
        }
      },
      label: {
        interval: 20,
        position: _types.LegendLabelPosition.BOTTOM,
        fontsize: 11,
        color: '#222222'
      }
    }, config.styles);
    var type = style.type || _types.LegendType.BAR;
    var cellOpts = style.cell || {};
    var labelOpts = style.label || {};
    var params = {};

    if (type === _types.LegendType.POINT && !(0, _utils.isset)(style.gutter)) {
      style.gutter = {
        x: 20,
        y: 5
      };
    }

    params.ls = labelOpts.fontsize;

    if (!(0, _utils.isEmpty)(labelOpts.custom)) {
      params.labels = labelOpts.custom.replace(/,\s+/g, ',').replace(/\s/g, '%20');
    }

    if (!(0, _utils.isEmpty)(labelOpts.color)) {
      var color = labelOpts.color.replace(/#/, '');

      if (color.length === 6) {
        params.lc = color;
      }
    }

    if (type === _types.LegendType.POINT && !(0, _utils.isEmpty)(style.filter_groups)) {
      params.filter = style.filter_groups;
    }

    if ((0, _utils.isset)(style.range)) {
      params.range = style.range.join(',');
    }

    if ((0, _utils.isset)(config.keys)) {
      params.keys = config.keys;
    } else if ((0, _utils.isset)(config.filter)) {
      params.filter = config.filter;
    }

    var units = style.units;

    if (units) {
      if (config.metric) {
        params.units = units.metric;
      } else {
        params.units = units.imperial;
      }
    }

    var _a = config.size || {
      width: null,
      height: null
    },
        width = _a.width,
        height = _a.height;

    var _b = cellOpts.size || {
      width: null,
      height: null
    },
        cellWidth = _b.width,
        cellHeight = _b.height;

    var vars = {
      type: type,
      interval: !(0, _utils.isEmpty)(style.interval) ? "-i" + style.interval : '',
      label: {
        interval: !(0, _utils.isEmpty)(labelOpts.interval) ? "-li" + labelOpts.interval : ''
      },
      cell: {
        size: !(0, _utils.isEmpty)(cellWidth) && !(0, _utils.isEmpty)(cellHeight) ? "-c" + cellWidth + "x" + cellHeight : '',
        pad: (0, _utils.isset)(style.gutter) ? "-p" + style.gutter.x + "," + style.gutter.y : ''
      },
      layout: "-" + style.orientation + "," + labelOpts.position,
      metric: config.metric ? '-metric' : '',
      size: !(0, _utils.isEmpty)(width) && !(0, _utils.isEmpty)(height) && !config.autosize ? "_" + width + "x" + height : '',
      format: config.format,
      radius: !(0, _utils.isEmpty)(style.radius) ? "-r" + style.radius : '',
      columns: !(0, _utils.isEmpty)(style.columns) && style.columns > 0 ? "-col" + style.columns : ''
    };
    var url = "https://legends.aerisapi.com/" + this.key;

    if (type === _types.LegendType.POINT) {
      url += "" + vars.radius + vars.columns + vars.cell.pad;
    } else {
      url += "" + vars.interval + vars.label.interval + vars.cell.size + vars.cell.pad + vars.layout + vars.metric;
    }

    url += vars.size + "." + vars.format; // add query string to url if we have params

    url += (url.indexOf('?') > -1 ? '&' : '?') + Object.keys(params).map(function (k) {
      return encodeURIComponent(k) + "=" + params[k];
    }).join('&');
    return url;
  };

  return Legend;
}(_EventDispatcher.default);

var _default = Legend;
exports.default = _default;
module.exports = exports.default;