"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Legend = _interopRequireDefault(require("./Legend"));

var _ApiRequest = _interopRequireWildcard(require("../../../network/api/ApiRequest"));

var _Mercator = require("../../proj/Mercator");

var _utils = require("../../../utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var boundsStrFromCenter = function (lat, lon, zoom, size) {
  var center = {
    lat: lat,
    lon: lon
  };

  var nw = _Mercator.Mercator.pointToCoord(0, 0, zoom, center, size);

  var se = _Mercator.Mercator.pointToCoord(size.width, size.height, zoom, center, size);

  nw.lat = parseFloat(nw.lat.toFixed(2));
  nw.lon = parseFloat(nw.lon.toFixed(2));
  se.lat = parseFloat(se.lat.toFixed(2));
  se.lon = parseFloat(se.lon.toFixed(2));
  return nw.lat + "," + nw.lon + "," + se.lat + "," + se.lon;
};
/**
 * An advisory legend is a legend object that is responsible for displaying and managing a point
 * legend based on dynamic advisory data that filters advisory elements based on specific filters
 * and/or VTEC codes.
 *
 * @export
 * @class AdvisoryLegend
 * @extends {Legend}
 */


var AdvisoryLegend =
/** @class */
function (_super) {
  __extends(AdvisoryLegend, _super);

  function AdvisoryLegend() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * Forces the legend to update if needed.
   *
   * Typically this method is called with valid coordinate bounds passed to the `opts.within`
   * property in order to update the advisories displayed based on those within the specified
   * bounds.
   *
   * @param {*} [opts]
   * @memberof AdvisoryLegend
   */


  AdvisoryLegend.prototype.update = function (opts) {
    if (opts.within) {
      this.opts.within = opts.within;
    }

    this._update();
  };

  AdvisoryLegend.prototype._update = function () {
    var _this = this;

    if (!this.account) {
      console.warn('Cannot render advisories/alerts legend, no valid Aeris account defined');
      return;
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)(function (opts) {
        _this._getVtecCodes(opts).then(function (codes) {
          _this.opts.keys = codes.join(','); // hide the legend if we don't have any VTEC codes

          if (codes.length === 0) {
            _this.hide();

            _this.reset();

            return;
          }

          _this.show();

          _this._load();
        });
      }, 1000);
    }

    this._request(this.opts.within);
  };

  AdvisoryLegend.prototype._getVtecCodes = function (opts) {
    var _this = this;

    var size = opts.size;
    var center = opts.center,
        bounds = opts.bounds,
        zoom = opts.zoom;
    zoom = parseInt(zoom, 10);
    return new Promise(function (resolve, reject) {
      if (!bounds) {
        if (!size || Number.isNaN(size.width) || Number.isNaN(size.height)) {
          reject(new Error('Size is not a number'));
          return;
        }

        if (!bounds && center) {
          if ((0, _utils.isString)(center) && /^[\d\.-]+,[\d\.-]+/.test(center)) {
            center = center.split(',');
            bounds = boundsStrFromCenter(center[0], center[1], zoom, size);
          } else if ((0, _utils.isObject)(center) && center.lat && center.lon) {
            bounds = boundsStrFromCenter(center.lat, center.lon, zoom, size);
          }
        }
      }

      if (bounds) {
        _this._getAdvisories(bounds).then(function (codes) {
          resolve(codes);
        });
      } else if (center) {
        _this._getPlace(center, size, zoom).then(function (b) {
          _this._getAdvisories(b).then(function (codes) {
            resolve(codes);
          });
        });
      }
    });
  };

  ;

  AdvisoryLegend.prototype._getPlace = function (loc, size, zoom) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var request = new _ApiRequest.default({
        client: _this.account.credentials()
      });
      request.endpoint('places').place(loc).limit(1).get().then(function (result) {
        if (result.data) {
          var _a = result.data.loc,
              lat = _a.lat,
              lon = _a.long;
          var boundsStr = boundsStrFromCenter(lat, lon, zoom, size);
          var bounds = boundsStr.split(',').map(function (val) {
            return parseFloat(val);
          });

          if (bounds.length === 4) {
            resolve({
              north: bounds[0],
              west: bounds[1],
              south: bounds[2],
              east: bounds[3]
            });
          } else {
            reject();
          }
        }
      });
    });
  };

  AdvisoryLegend.prototype._getAdvisories = function (bounds) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var request = new _ApiRequest.default({
        client: _this.account.credentials()
      }); // use the advisories/summary endpoint by default if user has access to it, otherwise
      // fall back to a basic advisories within request

      var isSummary = true;

      if (_this.account.canAccess('advisories_summary')) {
        request.endpoint('alerts/summary').fields('summary.typeCodes,summary.types.type,summary.types.code');
      } else {
        request.endpoint('alerts').fields('details.type,details.name').limit(300);
        isSummary = false;
      }

      request.action(_ApiRequest.ApiAction.WITHIN).bounds(bounds).get().then(function (result) {
        var data = result.data || {};
        var vtecs = [];
        var names = [];

        if (data) {
          if (isSummary) {
            data = data[0] || data; // vtecs = get(data, 'summary.typeCodes');

            var types = (0, _utils.get)(data, 'summary.types');
            (types || []).forEach(function (item) {
              var code = item.code,
                  type = item.type;

              if (code && vtecs.indexOf(code) === -1 && names.indexOf(type.toUpperCase()) === -1) {
                vtecs.push(code);
                names.push(type.toUpperCase());
              }
            });
          } else {
            data.forEach(function (advisory) {
              var _a = advisory.details,
                  code = _a.type,
                  type = _a.name;

              if (code && vtecs.indexOf(code) === -1 && names.indexOf(type.toUpperCase()) === -1) {
                vtecs.push(code);
                names.push(type.toUpperCase());
              }
            });
          }
        }

        resolve(vtecs);
      });
    });
  };

  return AdvisoryLegend;
}(_Legend.default);

var _default = AdvisoryLegend;
exports.default = _default;
module.exports = exports.default;