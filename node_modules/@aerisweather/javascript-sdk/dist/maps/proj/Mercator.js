"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mercator = void 0;

/**
 * @ignore
 */
var DegToRad = Math.PI / 180;
/**
 * @ignore
 */

var RadToDeg = 180 / Math.PI;
/**
 * @ignore
 */

var TILE_SIZE = 256;
/**
 * @ignore
 */

var _scale = function (zoom) {
  return TILE_SIZE * 0.5 / Math.PI * Math.pow(2, zoom);
};
/**
 * @ignore
 */


var _radians = function (value) {
  return value * DegToRad;
};
/**
 * @ignore
 */


var _degrees = function (value) {
  return value * RadToDeg;
};
/**
 * @ignore
 */


var _offset = function (coord, zoom, size) {
  var pi = Math.PI;
  var scale = TILE_SIZE * 0.5 / pi * Math.pow(2, zoom);

  var lat = _radians(coord.lat);

  var lon = _radians(coord.lon);

  var x = scale * (lon + pi);
  var y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
  return {
    x: size.width * 0.5 - x,
    y: size.height * 0.5 - y
  };
};
/**
 * @ignore
 */


var toFixed = function (value, places) {
  if (places === void 0) {
    places = 4;
  }

  var factor = Math.pow(10, places);
  return Math.round(value * factor) / factor;
};
/**
 * The `Mercator` module provides utility functions when working with a map in Mercator project,
 * such as converting between geographical coordinates and pixel coordinates and calculating
 * coordinate bounds.
 */


var Mercator;
exports.Mercator = Mercator;

(function (Mercator) {
  /**
   * Returns the coordinate for the specified pixel location on a map.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} zoom
   * @param {ICoordinate} [center=undefined]
   * @param {ISize} [size=undefined]
   * @returns {ICoordinate}
   */
  Mercator.pointToCoord = function (x, y, zoom, center, size) {
    if (center === void 0) {
      center = undefined;
    }

    if (size === void 0) {
      size = undefined;
    }

    var pi = Math.PI;

    var scale = _scale(zoom);

    var offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    var x2 = x - offset.x;
    var y2 = y - offset.y;
    var lon = x2 / scale - pi;
    var lat = 2 * (Math.atan(Math.exp(pi - y2 / scale)) - pi * 0.25);
    return {
      lat: _degrees(lat),
      lon: _degrees(lon)
    };
  };
  /**
   * Returns the pixel location for the specified pixel location on a map.
   *
   * @param {number} lat
   * @param {number} lon
   * @param {number} zoom
   * @param {ICoordinate} [center=undefined]
   * @param {ISize} [size=undefined]
   * @returns {IPoint}
   */


  Mercator.coordToPoint = function (lat, lon, zoom, center, size) {
    if (center === void 0) {
      center = undefined;
    }

    if (size === void 0) {
      size = undefined;
    }

    lon *= DegToRad;
    lat *= DegToRad;
    var pi = Math.PI;

    var scale = _scale(zoom);

    var offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    var x = scale * (lon + pi);
    var y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
    return {
      x: x + offset.x,
      y: y + offset.y
    };
  };
  /**
   * Returns the center coordinate for the specified coordinate bounds.
   *
   * @param {ICoordinateBounds} bounds
   * @returns {ICoordinate}
   */


  Mercator.getBoundsCenter = function (bounds) {
    var lon = (bounds.west + bounds.east) / 2; // handle international dateline crossover

    if (bounds.west > bounds.east) {
      lon = bounds.west - 360 + (bounds.west + bounds.east) / 2;
    }

    return {
      lat: (bounds.south + bounds.north) / 2,
      lon: lon
    };
  };
  /**
   * Returns the zoom level that best fits the given coordinate bounds based on the map size.
   *
   * @param {ICoordinateBounds} bounds
   * @param {ISize} size
   * @returns {number}
   */


  Mercator.getBoundsZoomLevel = function (bounds, size) {
    var WORLD_HEIGHT = 256;
    var WORLD_WIDTH = 256;
    var ZOOM_MAX = 21;

    var latRad = function (lat) {
      var sin = Math.sin(lat * Math.PI / 180);
      var radX2 = Math.log((1 + sin) / (1 - sin)) / 2;
      return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;
    };

    var zoom = function (mapPx, worldPx, fraction) {
      return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);
    };

    var latFraction = (latRad(bounds.north) - latRad(bounds.south)) / Math.PI;
    var lonDiff = bounds.east - bounds.west;
    var lonFraction = (lonDiff < 0 ? lonDiff + 360 : lonDiff) / 360;
    var latZoom = zoom(size.height, WORLD_HEIGHT, latFraction);
    var lngZoom = zoom(size.width, WORLD_WIDTH, lonFraction);
    return Math.min(latZoom, lngZoom, ZOOM_MAX);
  };
  /**
   * Returns the map size for the given coordinate bounds and zoom level.
   *
   * @param {ICoordinateBounds} bounds
   * @param {number} zoom
   * @returns {ISize}
   */


  Mercator.getSizeForBounds = function (bounds, zoom) {
    var nw = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    var se = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    return {
      width: se.x - nw.x,
      height: se.y - nw.y
    };
  };
  /**
   * Returns a new coordinate bounds that best fits the given coordinate bounds based on the map
   * size and any amount of padding.
   *
   * @param {ICoordinateBounds} bounds
   * @param {ISize} size
   * @param {number} [padding=0]
   * @returns {ICoordinateBounds}
   */


  Mercator.getBoundsThatFits = function (bounds, size, padding) {
    if (padding === void 0) {
      padding = 0;
    }

    var zoom = 0;
    var tl = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    var br = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    var bw = Math.abs(br.x - tl.x);
    var bh = Math.abs(br.y - tl.y);
    var center = {
      x: tl.x + bw / 2,
      y: tl.y + bh / 2
    };
    var targetSize = {
      width: bw,
      height: bh
    };
    var sizeRatio = size.height / size.width;
    var boundsRatio = toFixed(bh / bw, 2); // console.log('RATIO - SIZE', sizeRatio, 'BOUNDS', boundsRatio);

    var pxRatio = targetSize.width / size.width;

    if (sizeRatio !== boundsRatio) {
      if (size.width < size.height) {
        var ratio = size.width / size.height;
        targetSize.height = targetSize.width * (1 / ratio); // pxRatio = targetSize.width / size.width;
      } else {
        var ratio = size.height / size.width;
        targetSize.width = targetSize.height * (1 / ratio); // pxRatio = targetSize.height / size.height;
      }
    }

    targetSize.width += padding * pxRatio;
    targetSize.height += padding * pxRatio;
    var offset = {
      x: targetSize.width / 2,
      y: targetSize.height / 2
    };
    var nw = Mercator.pointToCoord(center.x - offset.x, center.y - offset.y, zoom);
    var se = Mercator.pointToCoord(center.x + offset.x, center.y + offset.y, zoom); // console.log('ADJ PX BOUNDS', 'CENTER', center, 'OFFSET', offset, 'TARGET SIZE', targetSize);
    // console.log('PX CALC', `${se.lat},${nw.lon},${nw.lat},${se.lon}`);

    return {
      north: toFixed(nw.lat),
      south: toFixed(se.lat),
      west: toFixed(nw.lon),
      east: toFixed(se.lon)
    };
  };
  /**
   * Returns the map tile coordinate that contains the given geographical coordinate based on a
   * specific zoom level.
   *
   * @param {ICoordinate} coord
   * @param {number} zoom
   * @returns {IPoint}
   */


  Mercator.coordToTile = function (coord, zoom) {
    var pi = Math.PI;
    var lon = coord.lon;

    var lat = _radians(coord.lat);

    var x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    var y = Math.floor((1 - Math.log(Math.tan(lat) + 1 / Math.cos(lat)) / pi) / 2 * Math.pow(2, zoom));
    return {
      x: x,
      y: y
    };
  };
  /**
   * Returns the geographical coordinate for the top-left corner of the given map tile
   * coordinate based on a specific zoom level.
   *
   * @param {IPoint} tile
   * @param {number} zoom
   * @returns {ICoordinate}
   */


  Mercator.tileToCoord = function (tile, zoom) {
    var n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, zoom);
    var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    var lon = tile.x / Math.pow(2, zoom) * 360 - 180;
    return {
      lat: lat,
      lon: lon
    };
  };
})(Mercator || (exports.Mercator = Mercator = {}));