"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("./Event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The EventDispatcher class is the base class for all classes that dispatch events.
 *
 * @export
 * @class EventDispatcher
 */
var EventDispatcher =
/** @class */
function () {
  function EventDispatcher() {
    /**
     * @ignore
     * @type {*}
     * @memberof EventDispatcher
     */
    this.parentEvent = null;
    /**
     * @ignore	 *
     * @protected
     * @type {*}
     * @memberof EventDispatcher
     */

    this._listeners = {};
  }
  /**
   * Registers a listener function to be executed each time an event occurs
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  EventDispatcher.prototype.on = function (type, callback, scope, priority) {
    var _this = this;

    if (scope === void 0) {
      scope = null;
    }

    if (priority === void 0) {
      priority = 0;
    }

    scope = scope || this;

    if (/\s+/.test(type)) {
      var events = type.split(' ');
      events.forEach(function (event) {
        _this.on(event, callback, scope, priority);
      });
      return this;
    }

    var list = this._listeners[type];

    if (list == null) {
      list = [];
      this._listeners[type] = list;
    }

    var index = 0;
    var listener;
    var i = list.length - 1;

    while (i > -1) {
      listener = list[i];

      if (listener.callback === callback && listener.scope === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.priority < priority) {
        index = i + 1;
      }

      i -= 1;
    } // insert the event listener to the list array at the index value


    list.splice(index, 0, {
      callback: callback,
      scope: scope,
      priority: priority,
      once: false
    });
    return this;
  };
  /**
   * Registers a listener function to be executed the first time an event occurs.
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  EventDispatcher.prototype.once = function (type, callback, scope, priority) {
    var _this = this;

    if (scope === void 0) {
      scope = null;
    }

    if (priority === void 0) {
      priority = 0;
    }

    scope = scope || this;

    if (/\s+/.test(type)) {
      var events = type.split(' ');
      events.forEach(function (event) {
        _this.once(event, callback, scope, priority);
      });
      return this;
    }

    this.on(type, callback, scope, priority); // get the listeners just added

    var list = this._listeners[type];
    var listener = list[0]; // change the value to true so it will be removed after `trigger` is called

    listener.once = true;
    return this;
  };
  /**
   * Removes a registered listener function for the specified event.
   *
   * @param {string} type Name of the event to remove the listener for.
   * @param {Function} callback Handler function to remove so it won't be executed next time the
   * event is triggered.
   * @param {*} [scope=null]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  EventDispatcher.prototype.off = function (type, callback, scope) {
    var _this = this;

    if (scope === void 0) {
      scope = null;
    }

    scope = scope || this;

    if (/\s+/.test(type)) {
      var events = type.split(' ');
      events.forEach(function (event) {
        _this.off(event, callback, scope);
      });
      return this;
    }

    var list = this._listeners[type];

    if (undefined !== list) {
      var i = list.length - 1;

      while (i > -1) {
        // if the callback and scope are the same then remove the event listener
        if (list[i].callback === callback && list[i].scope === scope) {
          list.splice(i, 1);
          break;
        }

        i -= 1;
      }
    }

    return this;
  };
  /**
   * Triggers the specified event so that all registered listeners will be executed with the
   * specified parameters.
   *
   * @param {*} type Event name to trigger
   * @param {*} [data=null] Object containing data to pass to all listener functions.
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  EventDispatcher.prototype.trigger = function (type, data) {
    if (data === void 0) {
      data = null;
    }

    var event = type;

    if (typeof event === 'string') {
      event = new _Event.default(type, false, true, data);
    } else if (event instanceof _Event.default) {
      type = event.type;
    }

    if (event instanceof _Event.default && event.target == null) {
      event.target = this;
      event.currentTarget = this;
    }

    var list = this._listeners[type];

    if (undefined !== list) {
      var cachedList = list.slice();
      var i = cachedList.length - 1;
      var listener = void 0;

      while (i > -1) {
        // if cancellable and isImmediatePropagationStopped are true then break out of the
        // while loop
        if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
          break;
        }

        listener = cachedList[i];
        listener.callback.call(listener.scope, event); // if the `once` value is true we want to remove the listener right after this
        // callback was called

        if (listener.once === true) {
          this.off(event.type, listener.callback, listener.scope);
        }

        i -= 1;
      }
    }

    if (this.parentEvent != null && event.bubbles === true) {
      if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
        return this;
      } // assign the current object that is currently processing the event (e.g. event
      // bubbling at)


      event.currentTarget = this; // pass the event to the parentEvent (event bubbling)

      this.parentEvent.trigger(event);
    }

    return this;
  };
  /**
   * Returns whether the listeners are registered for the specified event name.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof EventDispatcher
   */


  EventDispatcher.prototype.has = function (type) {
    return this._listeners[type] !== undefined;
  };

  return EventDispatcher;
}();

var _default = EventDispatcher;
exports.default = _default;
module.exports = exports.default;