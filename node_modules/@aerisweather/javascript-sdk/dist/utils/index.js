"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extend = extend;
exports.loadStyles = exports.loadScript = exports.debounce = exports.dateFromISO = exports.adjustDate = exports.toTimeOffsetHours = exports.toTimeStr = exports.toQueryStr = exports.toRangeStr = exports.toBool = exports.interval = exports.flatten = exports.cloneDeep = exports.pickBy = exports.pick = exports.has = exports.set = exports.get = exports.mergeUnique = exports.unique = exports.merge = exports.replace = exports.toUTC = exports.offsetToTime = exports.isZipcode = exports.isCoord = exports.isDOM = exports.isHTMLElement = exports.isPlainObject = exports.isObject = exports.isEmpty = exports.isDate = exports.isNumeric = exports.isNumber = exports.isString = exports.isBoolean = exports.isFunction = exports.isArray = exports.isset = exports.isUndefined = exports.isNull = exports.toTypeName = exports.toType = void 0;

var _dateFns = require("date-fns");

var toString = {}.toString;

var toType = function (a) {
  return toString.call(a).match(/([a-z]+)(:?\])/i)[1];
};

exports.toType = toType;

var toTypeName = function (o) {
  var objectToString = Object.prototype.toString.call(o).slice(8, -1);

  if (objectToString === 'Function') {
    var instanceToString = o.toString();

    if (instanceToString.indexOf(' => ') !== -1) {
      return 'ArrowFunction';
    }

    var getFunctionName = /^function ([^(]+)\(/;
    var match = instanceToString.match(getFunctionName);

    if (match === null) {
      return 'AnonymousFunction';
    }

    return 'Function';
  }

  return objectToString;
};

exports.toTypeName = toTypeName;

var isNull = function (obj) {
  return obj === null;
};

exports.isNull = isNull;

var isUndefined = function (obj) {
  return undefined === obj;
};

exports.isUndefined = isUndefined;

var isset = function (obj) {
  return !isUndefined(obj) && !isNull(obj);
};

exports.isset = isset;

var isArray = function (value) {
  return toString.call(value) === '[object Array]';
};

exports.isArray = isArray;

var isFunction = function (value) {
  return typeof value === 'function';
};

exports.isFunction = isFunction;

var isBoolean = function (value) {
  return value === true || value === false || toString.call(value) === '[object Boolean]';
};

exports.isBoolean = isBoolean;

var isString = function (obj) {
  return toString.call(obj) === '[object String]';
};

exports.isString = isString;

var isNumber = function (obj) {
  return !Number.isNaN(parseFloat(obj));
};

exports.isNumber = isNumber;

var isNumeric = function (obj) {
  return !isString(obj) && isNumber(obj) || isString(obj) && !isNull(obj.match(/^[\-\+]?\d*\.?\d*$/)) && !isNull(obj.match(/\d/));
};

exports.isNumeric = isNumeric;

var isDate = function (obj) {
  return obj.constructor.toString().indexOf('Date') > -1 && typeof obj.getTime !== 'undefined' && !Number.isNaN(obj.getTime());
};

exports.isDate = isDate;

var isEmpty = function (obj) {
  if (obj == null) return true;
  if (isNumber(obj)) return false;
  if (isArray(obj) || isString(obj)) return obj.length === 0;
  return Object.keys(obj).length === 0;
};

exports.isEmpty = isEmpty;

var isObject = function (value) {
  return value !== null && typeof value === 'object';
};

exports.isObject = isObject;

var isPlainObject = function (value) {
  return isObject(value) && value.constructor.name === 'Object' && !isArray(value) && !isFunction(value) && toString.call(value) === '[object Object]';
};

exports.isPlainObject = isPlainObject;

var isHTMLElement = function (value) {
  return value instanceof HTMLElement === true;
};

exports.isHTMLElement = isHTMLElement;

var isDOM = function (value) {
  return isObject(value) && (value.constructor.name === 'DOMtastic' || isset(value[0]));
};

exports.isDOM = isDOM;

var isMergebleObject = function (value) {
  return isPlainObject(value) && !Array.isArray(value);
};

var isCoord = function (str) {
  return /^(-?[\d\.]+),\s*(-?[\d\.]+)$/.test(str);
};

exports.isCoord = isCoord;

var isZipcode = function (str) {
  return /^(\d\d\d\d\d(?:-\d\d\d\d)?|[ABCEGHJKLMNPRSTVXY]\d[A-Z] ?\d[A-Z]\d)$/.test(str);
};

exports.isZipcode = isZipcode;

var offsetToTime = function (str) {
  var offset = 0;
  var matches = (str || '').match(/^([\d\.-]+)(\w*)$/);

  if (matches && matches.length >= 3) {
    var match = matches[0],
        value = matches[1],
        type = matches[2];
    offset = parseFloat(value);

    if (/^days?/.test(type)) {
      offset *= 86400;
    } else if (/^hours?/.test(type)) {
      offset *= 3600;
    } else if (/^minutes?/.test(type)) {
      offset *= 60;
    }
  }

  return new Date().getTime() + offset * 1000;
};

exports.offsetToTime = offsetToTime;

var toUTC = function (date) {
  var utc = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  return new Date(utc);
};

exports.toUTC = toUTC;

var replace = function (target, value, replacement) {
  if (target.indexOf(value) !== -1) {
    target[target.map(function (e, i) {
      return [i, e];
    }).filter(function (e) {
      return e[1] === value;
    })[0][0]] = replacement;
  }
};

exports.replace = replace;

var merge = function (target) {
  var sources = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }

  if (!sources.length) {
    return target;
  }

  var source = sources.shift();

  if (source === undefined) {
    return target;
  }

  if (isMergebleObject(target) && isMergebleObject(source)) {
    Object.keys(source).forEach(function (key) {
      if (isMergebleObject(source[key])) {
        if (!target[key]) {
          target[key] = {};
        }

        merge(target[key], source[key]);
      } else {
        target[key] = source[key];
      }
    });
  } else if (isObject(target) && isObject(source)) {
    for (var name_1 in source) {
      if (target.hasOwnProperty(name_1)) {
        target[name_1] = source[name_1];
      }
    }
  }

  return merge.apply(void 0, [target].concat(sources));
};

exports.merge = merge;

var unique = function (ar) {
  var a = ar.concat();

  for (var i = 0; i < a.length; i += 1) {
    for (var j = i + 1; j < a.length; j += 1) {
      if (a[i] === a[j]) {
        a.splice(j--, 1);
      }
    }
  }

  return a;
};

exports.unique = unique;

var mergeUnique = function (arr1, arr2) {
  return arr1.concat(arr2.filter(function (item) {
    return arr1.indexOf(item) === -1;
  }));
};
/**
 * Access a deep value inside a object.
 * Works by passing a path like "foo.bar", also works with nested arrays like "foo[0][1].baz"
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 * Unit tests: http://jsfiddle.net/Victornpb/0u1qygrh/
 */


exports.mergeUnique = mergeUnique;

var get = function (obj, path) {
  if (typeof obj === 'undefined' || obj === null) return undefined;
  var props = path.split(/[\.\[\]\"\']{1,2}/);
  var len = props.length;

  for (var i = 0; i < len; i += 1) {
    if (!isEmpty(props[i])) {
      obj = obj[props[i]];
      if (typeof obj === 'undefined' || obj === null) return undefined;
    }
  }

  return obj;
};
/**
 * Set a deep property on nested objects.
 * @param  {object}   obj  A object
 * @param  {String}   path A path
 * @param  {Any}      val  Anything that can be set
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 */


exports.get = get;

var set = function (obj, path, val) {
  var props = path.split('.');
  var len = props.length - 1;
  var i;

  for (i = 0; i < len; i += 1) {
    obj[props[i]] = obj[props[i]] || {};
    obj = obj[props[i]];
  }

  obj[props[i]] = val;
  return obj;
};

exports.set = set;

var has = function (obj, path) {
  var props = path.split(/[\.\[\]\"\']{1,2}/).filter(function (val) {
    return val !== '';
  });
  return !!props.reduce(function (el, prop) {
    return el && el[prop] ? el[prop] : undefined;
  }, obj);
};
/**
 * @ignore
 */


exports.has = has;

var _pick = function (obj, paths, predicate) {
  if (!paths || paths.length === 0) {
    return null;
  }

  var len = paths.length;
  var result = {};
  var index = 0;

  while (index < len) {
    var path = paths[index];
    var val = get(obj, path);

    if (predicate(val, path)) {
      set(result, path, val);
    }

    index += 1;
  }

  return result;
};

var pick = function (obj, paths) {
  return obj == null ? {} : _pick(obj, paths, function (val, path) {
    return has(obj, path);
  });
};

exports.pick = pick;

var pickBy = function (obj, predicate) {
  if (obj == null) return {};
  var props = Object.keys(obj);
  return _pick(obj, props, function (val, path) {
    return predicate(val, path[0]);
  });
};

exports.pickBy = pickBy;

var cloneDeep = function (obj) {
  if (isArray(obj)) {
    var ar = obj;

    if (ar.length > 0) {
      return ar.map(function (el) {
        if (isPlainObject(el)) {
          return cloneDeep(el);
        }

        return el;
      });
    }

    return ar.slice(0);
  }

  return merge({}, obj);
};

exports.cloneDeep = cloneDeep;

var flatten = function (arr, result) {
  if (result === void 0) {
    result = [];
  }

  for (var i = 0, length_1 = arr.length; i < length_1; i += 1) {
    var value = arr[i];

    if (Array.isArray(value)) {
      flatten(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
};

exports.flatten = flatten;

var interval = function (value, int) {
  if (value % int === 0) {
    return value;
  }

  return Math.round((value + int / 2) / int) * int;
};

exports.interval = interval;

var toBool = function (value) {
  if (isBoolean(value)) return value;
  if (isString(value)) return value === 'true' || value === '1';
  if (isNumber(value)) return value === 1;
  return false;
};

exports.toBool = toBool;

var toRangeStr = function (min, max, valueInterval) {
  var nearestInterval = function (value, int) {
    return Math.floor((value + int / 2) / int) * int;
  };

  var minInterval = nearestInterval(min, valueInterval);
  var maxInterval = nearestInterval(max, valueInterval);

  if (minInterval === maxInterval) {
    return "" + minInterval;
  }

  return minInterval + "-" + maxInterval;
};

exports.toRangeStr = toRangeStr;

var toQueryStr = function (obj) {
  return Object.keys(obj).map(function (k) {
    return encodeURIComponent(k) + "=" + encodeURIComponent(obj[k]);
  }).join('&');
};

exports.toQueryStr = toQueryStr;

var toTimeStr = function (date, from) {
  var relativeTo = from || new Date();

  if (Math.abs(date.getTime() - relativeTo.getTime()) < 60 * 1000) {
    return '';
  }

  var now = new Date();
  var month = 86400 * 30 * 1000;
  var delta = Math.abs(now.getTime() - date.getTime());

  if (delta > month) {
    return (0, _dateFns.format)(date, 'M/D/YYYY');
  }

  var str = (0, _dateFns.distanceInWordsStrict)(relativeTo, date).replace(/\s+/, '');

  if (date.getTime() < relativeTo.getTime()) {
    return "-" + str;
  }

  return str;
};

exports.toTimeStr = toTimeStr;

var toTimeOffsetHours = function (str) {
  str = str.replace(/\s/g, '');
  var factors = {
    second: 1 / 3600,
    minute: 1 / 60,
    hour: 1,
    day: 24,
    month: 720,
    year: 8760
  };
  var offset = 0;
  var m = str.match(/[\d\.-]+\w+/g);

  if (m && m.length > 0) {
    m.forEach(function (result) {
      var parts = result.match(/^([\d\.-]+)(\w+)$/);

      if (parts && parts.length >= 3) {
        var val = parseFloat(parts[1]);
        var period = (parts[2] || '').replace(/s$/, '');
        var multiplier = factors[period] || 0;
        offset += val * multiplier;
      }
    });
  }

  return offset;
};

exports.toTimeOffsetHours = toTimeOffsetHours;

var adjustDate = function (date, tzoffset) {
  if (tzoffset === void 0) {
    tzoffset = null;
  }

  var utcOffset = new Date().getTimezoneOffset() * 60000;
  var tzShift = tzoffset ? utcOffset + tzoffset : 0; // need to add timezone offset difference between the local and alert timezones

  return new Date(date.getTime() + tzShift);
};

exports.adjustDate = adjustDate;

var dateFromISO = function (isoDate) {
  isoDate = isoDate || '';
  var parts = isoDate.split(/[\D\-\+]+/).map(function (v) {
    return parseInt(v, 10);
  });
  var tz = isoDate.replace(/^.+\d\d(\-?\d\d\:\d\d)Z?$/, '$1');
  var utcOffset = new Date().getTimezoneOffset() / 60 * -1; // const result = new Date();
  // result.setUTCFullYear(parts[0]);
  // result.setUTCMonth(parts[1] - 1);
  // result.setUTCDate(parts[2]);
  // result.setUTCHours(parts[3]);
  // result.setUTCMinutes(parts[4]);
  // result.setUTCSeconds(parts[5]);
  // result.setUTCMilliseconds(parts[6]);

  var result = new Date(parts[0], parts[1] - 1, parts[1], parts[3], parts[4], parts[5]);
  var tzHourOffset = 0;

  if (!isEmpty(tz)) {
    var tzParts = tz.split(':');

    if (tzParts.length === 2) {
      var _a = tzParts.map(function (v) {
        return parseInt(v, 10);
      }),
          h = _a[0],
          m = _a[1];

      tzHourOffset += h;
      tzHourOffset += m / 60;
    }
  } // result.setHours(result.getUTCHours() + tzHourOffset);


  return result;
};

exports.dateFromISO = dateFromISO;

var debounce = function (fn, wait, isImmediate) {
  if (isImmediate === void 0) {
    isImmediate = false;
  }

  var timeout;
  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var context = this;

    var later = function () {
      timeout = undefined;

      if (!isImmediate) {
        fn.apply(context, args);
      }
    };

    var shouldCall = isImmediate && timeout === undefined;

    if (timeout !== undefined) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(later, wait);

    if (shouldCall) {
      fn.apply(context, args);
    }
  };
};

exports.debounce = debounce;

var loadScript = function (src) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.charset = 'utf-8';
    script.async = true;
    script.src = src; // script.timeout = 120000;

    script.addEventListener('load', resolve);
    script.addEventListener('error', function () {
      return reject(new Error('Error loading script.'));
    });
    script.addEventListener('abort', function () {
      return reject(new Error('Script loading aborted.'));
    });
    document.body.appendChild(script);
  });
};

exports.loadScript = loadScript;

var loadStyles = function (src) {
  return new Promise(function (resolve, reject) {
    var link = document.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';

    link.onload = function () {
      resolve();
    };

    link.href = src;
    var head = document.getElementsByTagName('head');

    if (head) {
      head[0].appendChild(link);
    }
  });
};

exports.loadStyles = loadStyles;

function extend() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  } // let args = Array.prototype.slice.call(arguments, 1);
  // let args = arguments;


  var len = args.length;
  if (len === 0) return null;
  var target = args[0] || {};
  if (len < 2 || target == null) return target;

  if (!isObject(target) && typeof target === 'function') {
    target = {};
  }

  var obj;
  var src;
  var cp;
  var clone;

  var assignKey = function (o, key) {
    src = target[key];
    cp = o[key]; // console.log('...key: '+key+', src: '+src+', cp: '+cp+', typeof: '+(typeof cp));
    // prevent endless loop

    if (target !== cp) {
      if (isset(cp) && isPlainObject(cp)) {
        if (isArray(cp)) {
          clone = src && isArray(src) ? src : []; // need to perform a deep copy of array so internal objects are no longer references

          var arCopy_1 = [];
          cp.forEach(function (el, j) {
            if (isPlainObject(el)) {
              arCopy_1[j] = cloneDeep(el);
            } else {
              arCopy_1[j] = el;
            }
          }); // target[key] = cp.slice();	// make copy of array instead of passing by reference

          target[key] = arCopy_1;
        } else if (isFunction(cp)) {
          target[key] = cp;
        } else if (isDate(cp)) {
          target[key] = cp;
        } else {
          clone = isset(src) && isPlainObject(src) ? src : {};
          target[key] = extend({}, clone, cp);
        }
      } else if (isset(cp)) {
        target[key] = cp;
      }
    }
  };

  for (var i = 1; i < len; i += 1) {
    obj = args[i];

    if (obj != null) {
      Object.keys(obj).forEach(function (key) {
        return assignKey(obj, key);
      }); // eslint-disable-line no-loop-func
    }
  }

  return target;
}