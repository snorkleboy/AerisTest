"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Component = _interopRequireDefault(require("./Component"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `Slider` is a component....
 */
var Slider =
/** @class */
function (_super) {
  __extends(Slider, _super);
  /**
   * Initializes and returns a slider instance configured with the specified options.
   *
   * @param {SliderOptions} [opts]
   * @memberof Slider
   */


  function Slider(opts) {
    var _this = this;

    opts = (0, _utils.extend)({
      range: {
        min: 0,
        max: 1
      },
      ticks: true,
      ui: {
        range: '.awxjs__ui-slider-span-inner',
        past: '.awxjs__ui-slider-span-past',
        future: '.awxjs__ui-slider-span-future',
        ticks: '.awxjs__ui-slider-ticks',
        indicator: '.awxjs__ui-slider-indicator'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? "ui-slider " + opts.className : 'ui-slider'
    });
    _this = _super.call(this, opts) || this;

    _this.setState({
      dragging: false
    });

    _this._mouse = {
      x: 0,
      y: 0
    };
    return _this;
  }

  Object.defineProperty(Slider.prototype, "dragging", {
    /**
     * A Boolean indicating whether the slider is currently being dragged.
     *
     * @readonly
     * @type {boolean}
     * @memberof Slider
     */
    get: function () {
      var dragging = this.state.dragging;
      return dragging;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the size of the slider position indicator/handle.
   *
   * @returns {ISize}
   * @memberof Slider
   */

  Slider.prototype.indicatorSize = function () {
    return {
      height: this.ui.indicator.outerHeight(true),
      width: this.ui.indicator.outerWidth(true)
    };
  };
  /**
   * Returns either the value for the current slider position or the value at the specified
   * position value, if provided.
   *
   * @param {number} [position]
   * @returns {number}
   * @memberof Slider
   */


  Slider.prototype.value = function (position) {
    if (!(0, _utils.isset)(this._x)) return null;

    if (!(0, _utils.isset)(position) || Number.isNaN(position)) {
      position = this.position();
    }

    return position * ((this.opts.range.max - this.opts.range.min) / (this._x.max - this._x.min));
  };
  /**
   * Updates the slider position based on the specified value.
   *
   * @param {number} value
   * @param {boolean} [fireEvents=true]
   * @memberof Slider
   */


  Slider.prototype.setValue = function (value, fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    this.setPosition(value / this._increment(), fireEvents);
  };

  Slider.prototype.position = function () {
    var x = this.ui.indicator.css('left');

    if ((0, _utils.isEmpty)(x) || !(0, _utils.isset)(x)) {
      x = '0px';
    }

    return Number.parseInt(x.replace(/[^0-9\.-]/g, ''), 10);
  };

  Slider.prototype.setPosition = function (pos, fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    if (Number.isNaN(pos) === false) {
      pos = Math.max(Math.min(pos, this._x.max), 0);
      this.ui.indicator.css('left', pos + "px");

      if (fireEvents) {
        this.trigger('change', {
          value: this.value(),
          position: this.position(),
          progress: this.progress()
        });
      }
    }
  };

  Slider.prototype.progress = function () {
    var delta = this._x.max - this._x.min;
    return (this.position() - this._x.min) / delta;
  };

  Slider.prototype.setProgress = function (progress, fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    var delta = this._x.max - this._x.min;
    var pos = Math.round(this._x.min + delta * progress);

    if (pos !== this.position()) {
      this.setPosition(pos, fireEvents);
    }
  };

  Slider.prototype.setDateRange = function (start, end) {
    var now = new Date().getTime();
    var range = end.getTime() - start.getTime();
    var past = (now - start.getTime()) / range;
    var future = (end.getTime() - now) / range;

    if (past > 0) {
      past = Math.round(past * 100 * 100) / 100;
      this.ui.past.css({
        width: past + "%"
      }).show();
    } else {
      this.ui.past.hide();
    }

    if (future > 0) {
      future = Math.round(future * 100 * 100) / 100;
      this.ui.future.css({
        width: future + "%"
      }).show();
    } else {
      this.ui.future.hide();
    }
  };

  Slider.prototype.setTicks = function (ticks) {
    var _this = this;

    if (this.opts.ticks === true && this.ui.ticks) {
      var size = this.indicatorSize();
      var x = size.width / 2;
      var w = this.$el.width() - size.width;
      this.ui.ticks.css({
        left: x + "px",
        width: w + "px"
      });
      this.ui.ticks.empty();
      Object.keys(ticks).sort().forEach(function (pos) {
        var per = parseFloat(pos) * 100;

        _this.ui.ticks.append("\n\t\t\t\t\t<div class=\"awxjs__ui-slider-tick\" style=\"left:" + per + "%;\">\n\t\t\t\t\t\t<div class=\"awxjs__ui-slider-tick-label\">" + ticks[pos] + "</div>\n\t\t\t\t\t</div>\n\t\t\t\t");
      });
    }
  };

  Slider.prototype._render = function () {
    return "\n\t\t\t<div class=\"awxjs__ui-slider-span\">\n\t\t\t\t<div class=\"awxjs__ui-slider-span-inner\">\n\t\t\t\t\t<div class=\"awxjs__ui-slider-span-item awxjs__ui-slider-span-past\"></div>\n\t\t\t\t\t<div class=\"awxjs__ui-slider-span-item awxjs__ui-slider-span-future\"></div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"awxjs__ui-slider-ticks\"></div>\n\t\t\t<div class=\"awxjs__ui-slider-indicator\"></div>\n\t\t";
  };

  Slider.prototype._layout = function () {
    var progress = (0, _utils.isset)(this._x) ? this.progress() : 0;
    this._x = {
      min: 0,
      max: this.$el.width() - this.ui.indicator.outerWidth(true)
    };
    this.setProgress(progress);

    if (this.ui.range) {
      var size = this.indicatorSize();
      var x = size.width / 2;
      var w = this._x.max - this._x.min;
      this.ui.range.css({
        left: x + "px",
        width: w + "px"
      });
    }
  };

  Slider.prototype._setupEvents = function () {
    var _this = this;

    var dragHandler = function (e) {
      _this._handleDrag(e);
    };

    var mouseUpHandler = function (e) {
      (0, _DOM.default)(document).off('mousemove', dragHandler);
      (0, _DOM.default)(document).off('mouseup', mouseUpHandler);

      _this.setState({
        dragging: false
      });

      _this.ui.indicator.removeClass('is-dragging');

      _this.trigger('slide:stop', {
        mouse: _this._mouse
      });
    };

    this.ui.indicator.on('mousedown', function (e) {
      e.preventDefault();

      _this.setState({
        dragging: true
      });

      _this._mouse.x = e.pageX;
      _this._mouse.y = e.pageY;

      _this.ui.indicator.addClass('is-dragging');

      _this.trigger('slide:start', {
        mouse: _this._mouse
      }); // add event listeners during drag event


      (0, _DOM.default)(document).on('mousemove', dragHandler);
      (0, _DOM.default)(document).on('mouseup', mouseUpHandler);
    });
    this.ui.ticks.on('click', function (e) {
      var x = e.layerX; // if a child node was clicked, calculate x relative to its container

      if (e.target !== _this.ui.ticks[0]) {
        var b = _this.ui.ticks.bounds();

        x = e.x - b.left;
      }

      var pos = x / _this.ui.ticks.width();

      _this.setProgress(pos);
    }); // this.parent().on('mouseoff', mouseUpHandler);
  };

  Slider.prototype._increment = function () {
    return (this._x.max - this._x.min) / (this.opts.range.max - this.opts.range.min);
  };

  Slider.prototype._handleDrag = function (e) {
    var dragging = this.state.dragging;

    if (dragging) {
      var delta = e.pageX - this._mouse.x;
      var pos = this.position();

      if (delta === 0) {
        return;
      }

      pos += delta;
      this.setPosition(pos, true);
      this._mouse.x = e.pageX;
      this._mouse.y = e.pageY;
    }
  };

  return Slider;
}(_Component.default);

var _default = Slider;
exports.default = _default;
module.exports = exports.default;