import Button, { ButtonOptions, ButtonState } from './Button';
import { ComponentState, ComponentOptions } from './Component';
/**
 * A data type that represents the configuration options for a button segment.
 */
export declare type ButtonSegment = {
    /**
     * Identifier for the segment. If not provided, the `value` will be used as the segment's identifier.
     *
     * @type {string}
     */
    id?: string;
    /**
     * Button segment title.
     *
     * @type {string}
     */
    title: string;
    /**
     * Value associated with the button segment.
     *
     * @type {*}
     */
    value: any;
    /**
     * Custom data associated with the button segment.
     *
     * @type {{ [key: string]: any }}
     */
    options?: {
        [key: string]: any;
    };
    /**
     * A Boolean indicating whether multiple options can be selected at once.
     *
     * @type {boolean}
     */
    multiselect?: boolean;
};
/**
 * A data type that represents the configuration options for a segmented button component.
 */
export declare type SegmentedButtonOptions = (ButtonOptions & ComponentOptions) & {
    /**
     * An array of button segment configurations to render for the button's segments.
     *
     * @type {ButtonSegment[]}
     */
    segments: ButtonSegment[];
    /**
     * A Boolean indicating whether the segments should function as filters to the primary button.
     * This value affects which events are triggered when a segment is selected as filters should
     * be handled differently than changing values.
     *
     * @type {boolean}
     */
    filter?: boolean;
    /**
     * A Boolean indicating whether multiple segments can be selected, only when `filter` is
     * `true`.
     *
     * @type {boolean}
     */
    multiselect?: boolean;
};
/**
 * A data type that represents a segmented button's state.
 */
export declare type SegmentedButtonState = (ButtonState & ComponentState) & {};
/**
 * A `SegmentedButton` is a button subclass that also contains a segmented control within the
 * button, which can be used to change the current value of the button or to use as a secondary
 * value associated with the button's value, such as filters.
 *
 * @export
 * @class SegmentedButton
 * @extends {Button<SegmentedButtonOptions, SegmentedButtonState>}
 */
export default class SegmentedButton extends Button<SegmentedButtonOptions, SegmentedButtonState> {
    /**
     * Value associated with the currently selected segment(s).
     *
     * @readonly
     * @type {*}
     * @memberof SegmentedButton
     */
    readonly value: any;
    /**
     * Returns whether the segments are configured as filter options.
     *
     * @readonly
     * @type {boolean}
     * @memberof SegmentedButton
     */
    readonly isFilter: boolean;
    /**
     * Initializes and returns a segmented button instance configured with the specified options.
     *
     * @param {SegmentedButtonOptions} [opts]
     * @memberof SegmentedButton
     */
    constructor(opts?: SegmentedButtonOptions);
    /**
     * Returns an array of values from the button segments.
     *
     * @returns {string[]}
     * @memberof SegmentedButton
     */
    segments(): string[];
    /**
     * Selects the button segment associated with the specified option. If `select` is `true`, then
     * then parent button will also be selected.
     *
     * @param {string} option
     * @param {boolean} [select=true]
     * @memberof SegmentedButton
     */
    selectSegment(option: string, select?: boolean): void;
    /**
     * Returns the value for the selected button segment(s).
     *
     * @returns {string}
     * @memberof SegmentedButton
     */
    selectedSegment(): string;
    protected _onSelect(): void;
    protected _onDeselect(): void;
    protected _render(data?: any): string;
    protected _setupEvents(): void;
    protected _handleClick(e: Event): void;
    protected _showSegments(show: boolean): void;
}
