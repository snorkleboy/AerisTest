"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Button = _interopRequireDefault(require("./Button"));

var _utils = require("../../utils");

var _globals = require("../../globals");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A `SegmentedButton` is a button subclass that also contains a segmented control within the
 * button, which can be used to change the current value of the button or to use as a secondary
 * value associated with the button's value, such as filters.
 *
 * @export
 * @class SegmentedButton
 * @extends {Button<SegmentedButtonOptions, SegmentedButtonState>}
 */
var SegmentedButton =
/** @class */
function (_super) {
  __extends(SegmentedButton, _super);
  /**
   * Initializes and returns a segmented button instance configured with the specified options.
   *
   * @param {SegmentedButtonOptions} [opts]
   * @memberof SegmentedButton
   */


  function SegmentedButton(opts) {
    var _this = this;

    opts = (0, _utils.extend)({
      filter: false,
      multiselect: false,
      ui: {
        all: '.awxjs__ui-btn-segmented__option-all',
        segments: '.awxjs__ui-btn-segments'
      }
    }, opts, {
      className: opts.className ? "ui-btn-segmented " + opts.className : 'ui-btn-segmented'
    });
    _this = _super.call(this, opts) || this;
    return _this;
  }

  Object.defineProperty(SegmentedButton.prototype, "value", {
    /**
     * Value associated with the currently selected segment(s).
     *
     * @readonly
     * @type {*}
     * @memberof SegmentedButton
     */
    get: function () {
      var val = this.selectedSegment();

      if (val && this.opts.filter === false) {
        return val.split(';');
      }

      return val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(SegmentedButton.prototype, "isFilter", {
    /**
     * Returns whether the segments are configured as filter options.
     *
     * @readonly
     * @type {boolean}
     * @memberof SegmentedButton
     */
    get: function () {
      return this.opts.filter;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns an array of values from the button segments.
   *
   * @returns {string[]}
   * @memberof SegmentedButton
   */

  SegmentedButton.prototype.segments = function () {
    return (0, _DOM.default)('li', this.ui.segments).map(function (el) {
      return (0, _DOM.default)(el).attr('data-value');
    });
  };
  /**
   * Selects the button segment associated with the specified option. If `select` is `true`, then
   * then parent button will also be selected.
   *
   * @param {string} option
   * @param {boolean} [select=true]
   * @memberof SegmentedButton
   */


  SegmentedButton.prototype.selectSegment = function (option, select) {
    if (select === void 0) {
      select = true;
    }

    var found = false;
    var $options = (0, _DOM.default)('li', this.ui.segments);

    if ($options && $options.length > 0) {
      $options.forEach(function (item) {
        var $option = (0, _DOM.default)(item);

        if ($option.attr('data-value') === option || $option.attr('data-id') === option) {
          $option.click();
          found = true;
        }
      });
    }

    if (found && select) {
      this.select();
    }
  };
  /**
   * Returns the value for the selected button segment(s).
   *
   * @returns {string}
   * @memberof SegmentedButton
   */


  SegmentedButton.prototype.selectedSegment = function () {
    return this.$el.attr('data-value');
  };

  SegmentedButton.prototype._onSelect = function () {
    this.trigger('select', {
      id: this.id,
      value: this.value,
      options: (0, _utils.cloneDeep)(this.opts.options),
      filter: this.opts.filter,
      multiselect: this.opts.multiselect
    });
  };

  SegmentedButton.prototype._onDeselect = function () {
    this.trigger('deselect', {
      id: this.id,
      value: this.value,
      filter: this.opts.filter,
      multiselect: this.opts.multiselect
    });
  };

  SegmentedButton.prototype._render = function (data) {
    var content = _super.prototype._render.call(this, data);

    var segments = [];

    if (this.opts.segments) {
      segments = (this.opts.segments || []).map(function (segment) {
        var id = segment.value.replace(/\:.+$/, '');
        var multiselect = (0, _utils.isset)(segment.multiselect) ? segment.multiselect : true;
        return "<li data-id=\"" + id + "\" data-value=\"" + segment.value + "\" data-multiselect=\"" + multiselect + "\"" + (segment.value === 'all' ? ' class="awxjs__ui-btn-segmented__option-all"' : '') + ">" + segment.title + "</li>";
      });
    }

    return content + "<div class=\"" + _globals.Globals.cssPrefix + "ui-btn-segments\"><ul>" + segments.join('') + "</ul></div>";
  };

  SegmentedButton.prototype._setupEvents = function () {
    var _this = this;

    _super.prototype._setupEvents.call(this);

    this.on('select', function () {
      _this._showSegments(true);
    }).on('deselect', function () {
      _this._showSegments(false);
    });
    (0, _DOM.default)('li', this.$el).on('click', function (e) {
      _this._handleClick(e);
    });
  };

  SegmentedButton.prototype._handleClick = function (e) {
    e.stopPropagation();
    var $el = (0, _DOM.default)(e.target);
    var previous = this.selectedSegment();
    var value = $el.attr('data-value');
    var multiselect = (0, _utils.toBool)($el.attr('data-multiselect'));
    var options = this.opts.options;
    this.opts.segments.forEach(function (segment) {
      if (segment.value === value) {
        options = segment.options || options;
      }
    });

    if (options) {
      options = (0, _utils.cloneDeep)(options);
    }

    if (this.opts.multiselect) {
      // if "all" or non-multiselect option is selected, deselect all other options
      if (value === 'all' || multiselect === false) {
        (0, _DOM.default)('li', this.$el).removeClass('selected');
        $el.addClass('selected');
      } else {
        (0, _DOM.default)('li', this.$el).forEach(function (item) {
          var $li = (0, _DOM.default)(item);

          if ((0, _utils.toBool)($li.attr('data-multiselect')) === false) {
            $li.removeClass('selected');
          }
        });

        if (this.ui.all) {
          this.ui.all.removeClass('selected');
        }

        if ($el.hasClass('selected')) {
          $el.removeClass('selected');
        } else {
          $el.addClass('selected');
        }
      }

      var selected = (0, _DOM.default)('li.selected', this.$el); // if no selection and we have non-multiselect options (or 'all'), then select
      // tht one instead by default

      if (selected.length === 0) {
        if (this.ui.all) {
          this.ui.all.addClass('selected');
        } else {
          var done_1 = false;
          (0, _DOM.default)('li', this.$el).forEach(function (item) {
            if (!done_1) {
              var $li = (0, _DOM.default)(item);

              if ((0, _utils.toBool)($li.attr('data-multiselect')) === false) {
                $li.addClass('selected');
                done_1 = true;
              }
            }
          });
        }

        selected = (0, _DOM.default)('li.selected', this.$el);
      }

      var values = selected.map(function (el) {
        return (0, _DOM.default)(el).attr('data-value');
      });
      this.$el.attr('data-value', values.join(';')); // if segments should be treated as filters, then join the selected items into a
      // single semicolon separate string instead of an array

      if (this.opts.filter) {
        values = values.join(';');
      }

      this.trigger('value:change', {
        id: this.id,
        value: values,
        previous: (previous || '').split(';'),
        options: options,
        filter: this.opts.filter,
        multiselect: this.opts.multiselect
      });
    } else {
      this.$el.attr('data-value', value);

      if (value !== previous) {
        (0, _DOM.default)('li', this.$el).removeClass('selected');
        $el.addClass('selected');
        this.trigger('value:change', {
          id: this.id,
          value: value,
          previous: previous,
          options: options,
          filter: this.opts.filter,
          multiselect: this.opts.multiselect
        });
      }
    }
  };

  SegmentedButton.prototype._showSegments = function (show) {
    var selectedSegment = this.selectedSegment();
    var value = show ? selectedSegment : null;
    var previous = show === false ? selectedSegment : null;
    var options = this.opts.options;

    if (this.opts.segments) {
      this.opts.segments.forEach(function (segment) {
        if (segment.value === value) {
          options = segment.options || options;
        }
      });
    }

    if (selectedSegment) {
      this.trigger('value:change', {
        id: this.id,
        value: value,
        previous: previous,
        options: options,
        filter: this.opts.filter
      });
    } else {
      var $sel = (0, _DOM.default)('li.selected', this.ui.segments);

      if (show && $sel.length === 0) {
        (0, _DOM.default)('li', this.ui.segments)[0].click();
      }
    }

    var height = show ? (0, _DOM.default)('ul', this.ui.segments).height() : 0;
    this.ui.segments.css({
      'max-height': height + "px"
    });
  };

  return SegmentedButton;
}(_Button.default);

var _default = SegmentedButton;
exports.default = _default;
module.exports = exports.default;