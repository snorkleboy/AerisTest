"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Component = _interopRequireDefault(require("./Component"));

var _SliderHandle = _interopRequireDefault(require("./SliderHandle"));

var _Tooltip = _interopRequireDefault(require("./Tooltip"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

/**
 * @ignore
 */
var isValueOutOfRange = function (value, min, max) {
  return value < min || value > max;
};
/**
 * @ignore
 */


var getClosestPoint = function (value, marks, step, min, max) {
  var points = Object.keys(marks).map(parseFloat);

  if (step !== null) {
    var maxSteps = Math.floor((max - min) / step);
    var steps = Math.min((value - min) / step, maxSteps);
    var closest = Math.round(steps) * step + min;
    points.push(closest);
  }

  var diffs = points.map(function (point) {
    return Math.abs(value - point);
  });
  return points[diffs.indexOf(Math.min.apply(Math, diffs))];
};
/**
 * @ignore
 */


var getPrecision = function (step) {
  var str = step.toString();
  var precision = 0;

  if (str.indexOf('.') >= 0) {
    precision = str.length - str.indexOf('.') - 1;
  }

  return precision;
};
/**
 * @ignore
 */


var ensureValueInRange = function (value, min, max) {
  if (value <= min) {
    return min;
  }

  if (value >= max) {
    return max;
  }

  return value;
};
/**
 * @ignore
 */


var ensureValuePrecision = function (value, marks, step, min, max) {
  var v = getClosestPoint(value, marks, step, min, max);
  var closest = Number.isFinite(v) ? v : 0;
  return !(0, _utils.isset)(step) ? closest : parseFloat(closest.toFixed(getPrecision(step)));
};
/**
 * @ignore
 */


var isEventFromHandle = function (e, handles) {
  try {
    if ((0, _utils.isArray)(handles)) {
      return handles.some(function (element) {
        return e.target === element;
      });
    }

    return Object.keys(handles).some(function (key) {
      return e.target === handles[key];
    });
  } catch (error) {
    return false;
  }
};
/**
 * @ignore
 */


var getHandlePosition = function (element) {
  var bounds = (0, _DOM.default)(element).bounds();
  return window.pageXOffset + bounds.left + bounds.width * 0.5;
};
/**
 * A `RangeSlider` is a slider component that allows you to define a value range and step interval
 * along the slider to allow a user to change values associated with the control.
 *
 * @export
 * @class RangeSlider
 * @extends {Component<RangeSliderOptions, RangeSliderState>}
 */


var RangeSlider =
/** @class */
function (_super) {
  __extends(RangeSlider, _super);
  /**
   * Initializes and returns a range slider instance configured with the specified options.
   *
   * @param {RangeSliderOptions} [opts]
   * @memberof RangeSlider
   */


  function RangeSlider(opts) {
    var _this = _super.call(this, (0, _utils.extend)({
      range: {
        min: 0,
        max: 100
      },
      count: 1,
      step: 10,
      marks: {},
      marksEvery: undefined,
      dots: true,
      disabled: false,
      tooltip: true,
      ui: {
        inner: '.awxjs__ui-slider-range-inner',
        track: '.awxjs__ui-slider-range-track',
        rail: '.awxjs__ui-slider-range-rail',
        steps: '.awxjs__ui-slider-range-steps',
        marks: '.awxjs__ui-slider-range-marks',
        handles: '.awxjs__ui-slider-range-handle'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? "ui-slider-range " + opts.className : 'ui-slider-range'
    })) || this;

    _this._onBoundsChange = function (state) {
      var bounds = state.bounds;
      var offsets = bounds.map(function (value) {
        return _this._offsetForValue(value);
      });
      offsets.forEach(function (offset, index) {
        var handleRef = _this._handles[index];

        if (handleRef) {
          handleRef.update(offsets[index]);
        }
      });

      _this._onChange(state);
    };

    _this._onChange = function (state) {
      var bounds = state.bounds,
          handle = state.handle;
      var offsets = bounds.map(function (value) {
        return _this._offsetForValue(value);
      });
      var handleRef = _this._handles[handle];

      if (handleRef) {
        handleRef.update(offsets[handle]);

        _this._updateTooltip(bounds[handle], handle);
      }

      if (offsets.length === 1) {
        _this.ui.track.css({
          left: '0%',
          width: offsets[0] + "%"
        });
      } else {
        var range = offsets[offsets.length - 1] - offsets[0];

        _this.ui.track.css({
          left: offsets[0] + "%",
          width: range + "%"
        });
      }

      _this.setState({
        bounds: bounds
      });

      var lower = _this._getLowerBound();

      var upper = _this._getUpperBound();

      _this.ui.steps.children().forEach(function (el) {
        var $el = (0, _DOM.default)(el);
        var point = parseFloat($el.data('key'));
        var active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-dot-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-dot-active');
        }
      });

      _this.ui.marks.children().forEach(function (el) {
        var $el = (0, _DOM.default)(el);
        var point = parseFloat($el.data('key'));
        var active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-mark-text-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-mark-text-active');
        }
      });

      _this.trigger('change', {
        value: __assign({}, state.bounds)
      });
    };

    _this._onStart = function (position) {
      var bounds = _this.value;

      var value = _this._valueAtPosition(position);

      var closest = _this._getClosestBound(value);

      var prevMovedHandle = _this._getBoundNeedMoving(value, closest);

      _this.trigger('change:start', {
        value: _this.value
      });

      _this.setState({
        handle: prevMovedHandle,
        recent: prevMovedHandle
      });

      var prevValue = bounds[prevMovedHandle];
      if (value === prevValue) return;

      var nextBounds = _this.state.bounds.slice();

      nextBounds[prevMovedHandle] = value;
      _this._lastMovedHandle = prevMovedHandle;

      _this._onChange({
        bounds: nextBounds,
        handle: prevMovedHandle
      });
    };

    _this._onEnd = function (force) {
      if (force === void 0) {
        force = false;
      }

      var handle = _this.state.handle;

      _this._removeDocumentEvents();

      if ((0, _utils.isset)(handle) || force) {}

      _this.setState({
        handle: null
      });

      _this.trigger('change:end', {
        value: _this.value
      });
    };

    _this._onMove = function (e, position) {
      var _a = _this.state,
          bounds = _a.bounds,
          handle = _a.handle;

      var value = _this._valueAtPosition(position);

      var previous = bounds[handle];
      if (value === previous) return;

      _this._moveTo(value);
    };

    _this._onKeyboard = function (e) {};

    _this._onMouseDown = function (e) {
      if (e.button !== 0) return;
      var position = e.pageX;

      if (isEventFromHandle(e, _this._handles.map(function (handle) {
        return handle.$el;
      })) === false) {
        _this._dragOffset = 0;
      } else {
        var handlePosition = getHandlePosition(e.target);
        _this._dragOffset = position - handlePosition;
        position = handlePosition;
      }

      _this._removeDocumentEvents();

      _this._onStart(position);

      _this._addDocumentEvents();

      var _a = _this.state,
          bounds = _a.bounds,
          handle = _a.handle;

      _this._updateTooltip(bounds[handle], handle);

      _this._tooltip.show(false);
    };

    _this._onMouseUp = function (e) {
      _this._tooltip.hide();

      _this._onEnd();
    };

    _this._onMouseMove = function (e) {
      if (!_this.ui.rail) {
        _this._onEnd();

        return;
      }

      var pos = e.pageX;

      _this._onMove(e, pos - _this._dragOffset);
    }; // if `value` is defined, check that it's divisible by the `step value, otherwise we won't
    // be able to show the correct range


    if ((0, _utils.isArray)(_this.opts.value)) {
      var _a = _this.opts.value,
          from = _a[0],
          to = _a[1];
      var step = _this.opts.step;

      if (from % step !== 0) {
        var msg = '[Aeris] The `value` property passed to the range configuration \
					([' + from + ', ' + to + ']) does not contain from/to values equally divisible by the \
					step value (' + step + '), which may affect the rendered step range in the \
					control.';
        console.warn(msg.replace(/\s+/g, ' '));
      }
    }

    var initialValue = _this.opts.value || Array.apply(void 0, Array(_this.opts.count + 1)).map(function () {
      return _this.opts.range.min;
    });
    var bounds = initialValue.map(function (v, i) {
      return _this._trimAlignValue(v, i);
    });

    _this.setState({
      bounds: bounds
    });

    _this._tooltip = new _Tooltip.default();

    _this.render();

    return _this;
  }

  Object.defineProperty(RangeSlider.prototype, "value", {
    /**
     * Current value, which is an array of values corresponding to the bounds. The first value is
     * the minimum value in the range, whereas the second value in the array is the maximum value.
     *
     * @readonly
     * @type {number[]}
     * @memberof RangeSlider
     */
    get: function () {
      var bounds = this.state.bounds;
      return bounds;
    },
    set: function (bounds) {
      var _this = this;

      var value = bounds.map(function (v, i) {
        return _this._trimAlignValue(v, i);
      });
      this.setState({
        bounds: value
      });

      this._onBoundsChange(this.state);
    },
    enumerable: true,
    configurable: true
  });

  RangeSlider.prototype.render = function (data) {
    var bounds = this.state.bounds;

    if (!bounds) {
      return;
    }

    _super.prototype.render.call(this, data);
  };

  RangeSlider.prototype._render = function () {
    var bounds = this.state.bounds;
    if (!bounds) return null;
    var _a = this.opts,
        _b = _a.range,
        min = _b.min,
        max = _b.max,
        marks = _a.marks,
        marksEvery = _a.marksEvery,
        step = _a.step;
    var range = max - min;
    var dots = this.opts.dots && step > 1;
    var points = Object.keys(marks).map(parseFloat).filter(function (value) {
      return value >= min && value <= max;
    }).sort(function (a, b) {
      return a - b;
    });

    if (dots) {
      for (var i = min; i <= max; i += step) {
        if (points.indexOf(i) === -1) {
          points.push(i);
        }
      }
    }

    var _marks = marks || {};

    if ((0, _utils.isset)(marksEvery)) {
      var every = 1;
      var modulo = false;

      if ((0, _utils.isString)(marksEvery)) {
        var str = "" + marksEvery;
        modulo = /^%\s*\d+$/.test(str);
        every = parseInt(str.replace(/\D/, ''), 10);
      } else {
        every = parseInt("" + marksEvery, 10);
      }

      var n = min;
      var i = 0;

      while (n <= max) {
        var include = modulo ? n % every === 0 : i % every === 0;

        if (include) {
          var val = "" + n;

          if (!(0, _utils.isset)(_marks[n])) {
            _marks[val] = val;
          }
        }

        n += step;
        i += 1;
      } // update `marks` value on the main config


      (0, _utils.set)(this.opts, 'marks', _marks);
    }

    var labels = Object.keys(_marks).map(parseFloat).filter(function (value) {
      return value >= min && value <= max;
    }).sort(function (a, b) {
      return a - b;
    }).map(function (point) {
      var label = _marks[point];

      if ((0, _utils.isEmpty)(label)) {
        return null;
      }

      var offset = Math.abs(point - min) / range * 100 + "%";
      return "<div\n\t\t\t\t\tclass=\"awxjs__ui-slider-range-mark-text\"\n\t\t\t\t\tstyle=\"left:" + offset + ";transform:translateX(-50%);msTransform:translateX(-50%);\"\n\t\t\t\t\tdata-key=\"" + point + "\"\n\t\t\t\t>" + label + "</div>";
    });
    var steps = points.map(function (point) {
      var offset = Math.abs(point - min) / range * 100 + "%";
      return "<div\n\t\t\t\tclass=\"awxjs__ui-slider-range-dot\"\n\t\t\t\tstyle=\"left:" + offset + ";\"\n\t\t\t\tdata-key=\"" + point + "\"\n\t\t\t></div>";
    }); // generate handle objects and append to container

    this._handles = bounds.map(function (value, index) {
      return new _SliderHandle.default({
        values: {
          min: min,
          max: max,
          current: value
        }
      });
    });
    return "\n\t\t\t" + (this.opts.title ? "<div class=\"awxjs__ui-slider-range-title\">" + this.opts.title + "</div>" : '') + "\n\t\t\t<div class=\"awxjs__ui-slider-range-inner\">\n\t\t\t\t<div class=\"awxjs__ui-slider-range-rail\"></div>\n\t\t\t\t<div class=\"awxjs__ui-slider-range-track\"></div>\n\t\t\t\t<div class=\"awxjs__ui-slider-range-steps\">" + steps.join('') + "</div>\n\t\t\t\t<div class=\"awxjs__ui-slider-range-marks\">" + labels.join('') + "</div>\n\t\t\t</div>\n\t\t";
  };

  RangeSlider.prototype._afterRender = function () {
    var _this = this;

    var bounds = this.state.bounds;
    var offsets = bounds.map(function (value) {
      return _this._offsetForValue(value);
    });

    if (this.opts.ui) {
      this.setUI(this.opts.ui);

      if (this.ui.marks.children().length > 0) {
        this.$el.addClass('awxjs__ui-slider-range-with-marks');
      }

      this._setupEvents();

      if (this.opts.width > 0) {
        this.ui.inner.width(this.opts.width);
      }

      this._handles.forEach(function (handle, index) {
        handle.addTo(_this.ui.inner);
        handle.update(offsets[index]);
      });
    }

    this._onChange(this.state);
  };

  RangeSlider.prototype._setupEvents = function () {
    _super.prototype._setupEvents.call(this);

    this.$el.on('mousedown', this._onMouseDown);
  };

  RangeSlider.prototype._getClosestBound = function (value) {
    var bounds = this.state.bounds;
    var closest = 0;

    for (var i = 1; i < bounds.length - 1; i += 1) {
      if (value > bounds[i]) {
        closest = i;
      }
    }

    if (Math.abs(bounds[closest + 1] - value) < Math.abs(bounds[closest] - value)) {
      closest += 1;
    }

    return closest;
  };

  RangeSlider.prototype._getBoundNeedMoving = function (value, closestBound) {
    var _a = this.state,
        bounds = _a.bounds,
        recent = _a.recent;
    var boundNeedMoving = closestBound;
    var atSamePoint = bounds[closestBound + 1] === bounds[closestBound];

    if (atSamePoint && bounds[recent] === bounds[closestBound]) {
      boundNeedMoving = recent;
    }

    if (atSamePoint && value !== bounds[closestBound + 1]) {
      boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
    }

    return boundNeedMoving;
  };

  RangeSlider.prototype._getLowerBound = function () {
    var bounds = this.state.bounds;
    return bounds[0];
  };

  RangeSlider.prototype._getUpperBound = function () {
    var bounds = this.state.bounds;
    return bounds[bounds.length - 1];
  };

  RangeSlider.prototype._getPoints = function () {
    var _a = this.opts,
        marks = _a.marks,
        _b = _a.range,
        min = _b.min,
        max = _b.max,
        step = _a.step;
    var cache = this._points;

    if (!cache || cache.marks !== marks || cache.step !== step) {
      var points = __assign({}, marks);

      if ((0, _utils.isset)(step)) {
        for (var p = min; p <= max; p += step) {
          points[p] = p;
        }
      }

      var result = Object.keys(points).map(parseFloat);
      result.sort(function (a, b) {
        return a - b;
      });
      this._points = {
        marks: marks,
        step: step,
        points: result
      };
    }

    return this._points.points;
  };

  RangeSlider.prototype._moveTo = function (value, isFromKeyboardEvent) {
    if (isFromKeyboardEvent === void 0) {
      isFromKeyboardEvent = false;
    }

    var _a = this.state,
        handle = _a.handle,
        recent = _a.recent,
        bounds = _a.bounds;
    var target = !(0, _utils.isset)(handle) ? recent : handle;
    var nextBounds = bounds.slice();
    nextBounds[target] = value;
    var nextHandle = target;

    this._onChange({
      handle: nextHandle,
      bounds: nextBounds
    }); // if (isFromKeyboardEvent) {
    // }

  };

  RangeSlider.prototype._trimAlignValue = function (value, handle) {
    var _a = this.opts.range,
        min = _a.min,
        max = _a.max;
    var inRange = ensureValueInRange(value, min, max);

    var notConflict = this._ensureValueNotConflict(inRange, handle);

    return ensureValuePrecision(notConflict, this.opts.marks, this.opts.step, this.opts.range.min, this.opts.range.max);
  };

  RangeSlider.prototype._ensureValueNotConflict = function (value, handle) {
    var _a = this.state,
        bounds = _a.bounds,
        stateHandle = _a.handle;
    var allowCross = false;
    handle = !(0, _utils.isset)(handle) ? stateHandle : handle;

    if (!allowCross && (0, _utils.isset)(handle) && (0, _utils.isset)(bounds)) {
      if (handle > 0 && value <= bounds[handle - 1]) {
        return bounds[handle - 1];
      }

      if (handle < bounds.length - 1 && value >= bounds[handle + 1]) {
        return bounds[handle + 1];
      }
    }

    return value;
  };

  RangeSlider.prototype._valueAtPosition = function (pos) {
    var sliderBounds = this.ui.rail.bounds();
    var offset = pos - (sliderBounds.left + window.pageXOffset);

    var nextValue = this._trimAlignValue(this._valueAtOffset(offset));

    return nextValue;
  };

  RangeSlider.prototype._valueAtOffset = function (offset) {
    var _a = this.opts.range,
        min = _a.min,
        max = _a.max;
    var length = this.ui.rail ? this.ui.rail.bounds().width : 0;
    var ratio = Math.abs(Math.max(offset, 0) / length);
    return ratio * (max - min) + min;
  };

  RangeSlider.prototype._offsetForValue = function (value) {
    var _a = this.opts.range,
        min = _a.min,
        max = _a.max;
    var ratio = (value - min) / (max - min);
    return ratio * 100;
  };

  RangeSlider.prototype._updateTooltip = function (value, handle) {
    var handleRef = this._handles[handle];
    var str = value.toString();

    if ((0, _utils.isFunction)(this.opts.tooltip)) {
      str = this.opts.tooltip(value);
    }

    this._tooltip.setContent(str).position(handleRef.$el);
  };

  RangeSlider.prototype._addDocumentEvents = function () {
    (0, _DOM.default)(document).on('mousemove', this._onMouseMove).on('mouseup', this._onMouseUp);
  };

  RangeSlider.prototype._removeDocumentEvents = function () {
    (0, _DOM.default)(document).off('mousemove', this._onMouseMove).off('mouseup', this._onMouseUp);
  };

  return RangeSlider;
}(_Component.default);

var _default = RangeSlider;
exports.default = _default;
module.exports = exports.default;