"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @ignore
 * Check whether value is a window object.
 *
 * Uses duck typing to determine window. Without IE8 all we need is:
 *
 *   var type = Object.prototype.toString.call(val);
 *   return type === '[object global]' || type === '[object Window]' || type === '[object DOMWindow]';
 *
 * @param  {Mixed} val
 * @return {Boolean}
 */
var isWindow = function (val) {
  var doc = val ? val.document : null;
  var docWin = doc ? doc.defaultView || doc.parentWindow : null;
  return !!(val && typeof val === 'object' && typeof val.window === 'object' && val.window === val && val.setTimeout && val.alert && (0, _utils.isset)(doc) && typeof doc === 'object' && (0, _utils.isset)(docWin) && typeof docWin === 'object' && docWin === val);
};
/**
 * @ignore
 */


var transitionDuration = function (element) {
  var computed = window.getComputedStyle(element);
  var duration = String(computed.getPropertyValue('transition-duration') || computed.getPropertyValue('-webkit-transition-duration'));
  var match = duration.match(/([0-9.]+)([ms]{1,2})/);
  var val = 0;

  if (match) {
    val = Number(match[1]);
    if (match[2] === 's') val *= 1000;
  }

  return val || 0;
};
/**
 * @ignore
 * Returns element's position object with `left`, `top`, `bottom`, `right`,
 * `width`, and `height` properties indicating the position and dimensions
 * of element on a page, or relative to other element.
 *
 * @param {Element} element
 * @param {Element} [relativeTo] Defaults to `document.documentElement`.
 *
 * @return {Object|null}
 */


var position = function (element, relativeTo) {
  var isWin = isWindow(element);
  var doc = isWin ? element.document : element.ownerDocument || element;
  var docEl = doc.documentElement;
  var win = isWindow(relativeTo) ? relativeTo : doc.defaultView || window; // normalize arguments

  if (element === doc) element = docEl;
  relativeTo = !relativeTo || relativeTo === doc ? docEl : relativeTo;
  var winTop = (win.pageYOffset || docEl.scrollTop) - docEl.clientTop;
  var winLeft = (win.pageXOffset || docEl.scrollLeft) - docEl.clientLeft;
  var box = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  };

  if (isWin) {
    box.width = win.innerWidth || docEl.clientWidth;
    box.height = win.innerHeight || docEl.clientHeight;
    box.right = box.width;
    box.bottom = box.height;
  } else if (element === docEl) {
    // we need to do  this manually because docEl.getBoundingClientRect
    // is inconsistent in <IE11
    box.top = -winTop;
    box.left = -winLeft;
    box.width = Math.max(docEl.clientWidth, docEl.scrollWidth);
    box.height = Math.max(docEl.clientHeight, docEl.scrollHeight);
    box.right = box.width - winLeft;
    box.bottom = box.height - winTop;
  } else if (docEl.contains(element) && element.getBoundingClientRect) {
    // new object needed because DOMRect properties are read-only
    var bounds_1 = element.getBoundingClientRect();
    Object.keys(box).forEach(function (key) {
      box[key] = bounds_1[key];
    }); // width & height don't exist in <IE9

    box.width = box.right - box.left;
    box.height = box.bottom - box.top;
  } else {
    return null;
  } // current box is already relative to window


  if (relativeTo === win) return box; // add window offsets, making the box relative to documentElement

  box.top += winTop;
  box.left += winLeft;
  box.right += winLeft;
  box.bottom += winTop; // current box is already relative to documentElement

  if (relativeTo === docEl) return box; // subtract position of other element

  var relBox = position(relativeTo);
  box.left -= relBox.left;
  box.right -= relBox.left;
  box.top -= relBox.top;
  box.bottom -= relBox.top;
  return box;
};

var activeTooltip;
/**
 * A `Tooltip` is a component for displaying additional information or content in a popover when
 * the target element is hovered over or clicked on.
 *
 * @export
 * @class Tooltip
 * @extends {EventDispatcher}
 */

var Tooltip =
/** @class */
function (_super) {
  __extends(Tooltip, _super);
  /**
   * Initializes and returns a tooltip instance configured with the specified content and options.
   *
   * @param {(string | HTMLElement)} [content]
   * @param {TooltipOptions} [opts]
   * @memberof Tooltip
   */


  function Tooltip(content, opts) {
    var _this = _super.call(this) || this;

    _this._reposition = function () {
      var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
        return setTimeout(fn, 17);
      };

      var requestReposition = function () {
        raf(function () {
          _this.position();
        });
      };

      requestReposition();
    };

    _this._opts = (0, _utils.extend)({
      place: 'top',
      effect: 'slide',
      spacing: 5
    }, opts);
    _this._hidden = true;
    _this._element = (0, _DOM.default)('<div class="awxjs__ui-tooltip"></div>');

    if (_this._opts.className) {
      _this.$el.addClass(_this._opts.className);
    }

    if (_this._opts.effect) {
      _this.$el.addClass(_this._opts.effect);
    }

    if (content) {
      _this.setContent(content);
    }

    return _this;
  }

  Object.defineProperty(Tooltip.prototype, "$el", {
    /**
     * DOM element.
     *
     * @readonly
     * @type {*}
     * @memberof Tooltip
     */
    get: function () {
      return this._element;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Tooltip.prototype, "$target", {
    /**
     * Target DOM element.
     *
     * @readonly
     * @type {*}
     * @memberof Tooltip
     */
    get: function () {
      return this._target;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Tooltip.prototype, "size", {
    /**
     * Size of the tooltip.
     *
     * @readonly
     * @type {ISize}
     * @memberof Tooltip
     */
    get: function () {
      return this._size;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Tooltip.prototype, "visible", {
    /**
     * A Boolean indicating whether the tooltip is currently visible.
     *
     * @readonly
     * @type {boolean}
     * @memberof Tooltip
     */
    get: function () {
      return this._hidden === false;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Shows the tooltip from the previously configured target.
   *
   * To present the tooltip from a different target, call `attachTo()` before showing the
   * tooltip.
   *
   * @param {boolean} [hideOthers=true] A Boolean indicating whether all existing tooltips
   * should be hidden when showing this instance.
   * @returns {Tooltip}
   * @memberof Tooltip
   */

  Tooltip.prototype.show = function (hideOthers) {
    var _this = this;

    if (hideOthers === void 0) {
      hideOthers = true;
    }

    clearTimeout(this._hideTimeout);

    if (activeTooltip && hideOthers) {
      activeTooltip.hide();
      activeTooltip = this;
    }

    if (this._target) {
      this.position(this._target);
    }

    if (this._hidden) {
      this._hidden = false;
      (0, _DOM.default)('body').append(this.$el);
    }

    (0, _DOM.default)(window).on('scroll resize', this._reposition); // trigger layout and start the transition

    setTimeout(function () {
      _this.$el.addClass('in');
    }, 100);
    return this;
  };
  /**
   * Hides the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.hide = function () {
    var _this = this;

    if (this._hidden) {
      return this;
    }

    this.$el.removeClass('in');
    (0, _DOM.default)(window).off('scroll resize', this._reposition);
    clearTimeout(this._hideTimeout);
    var duration = transitionDuration(this.$el[0]);
    this._hideTimeout = setTimeout(function () {
      _this.$el.remove();
    }, duration);
    this._hidden = true;
    return this;
  };
  /**
   * Toggles the visibility of the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.toggle = function () {
    if (this.visible) {
      return this.hide();
    }

    return this.show();
  };
  /**
   * Sets the content, which can either be a text string or HTML string.
   *
   * @param {(string | HTMLElement)} content
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.setContent = function (content) {
    if ((0, _utils.isString)(content)) {
      this.$el.html(content);
    } else {
      this.$el.empty().append(content);
    }

    this._updateSize();

    return this;
  };
  /**
   * Sets the current target.
   *
   * @param {*} element
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.attachTo = function (element) {
    this._target = element;

    if (!this._hidden) {
      this.position();
    }

    return this;
  };
  /**
   * Hides the tooltip and removes its associated with the current target.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.detach = function () {
    this.hide();
    this._target = null;
    return this;
  };
  /**
   * Updates the tooltip's position.
   *
   * This method accepts either an x and y pixel coordinate from which to position the tooltip.
   * Alternatively, a single DOM element argument can be provided which will be used when
   * calculating the new position.
   *
   * @param {(number | Element)} [x]
   * @param {number} [y]
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  Tooltip.prototype.position = function (x, y) {
    x = this._target || x;

    if (!(0, _utils.isset)(x) && this._p) {
      x = this._p[0];
      y = this._p[1];
    } else {
      this._p = [];
      if (x) this._p.push(x);
      if (y) this._p.push(y);
    }

    x = x[0] || x;
    var target = (0, _utils.isNumber)(x) ? {
      left: x || 0,
      right: x || 0,
      top: y || 0,
      bottom: y || 0,
      width: 0,
      height: 0
    } : position(x);

    if (!target) {
      return this;
    }

    var spacing = this._opts.spacing || 0;

    var newPlace = this._pickPlace(target);

    if (newPlace !== this._lastPlace) {
      if (this._lastPlace) {
        this.$el.removeClass(this._lastPlace);
      }

      this.$el.addClass(newPlace);
      this._lastPlace = newPlace;
    } // position the tip


    var anchor = this._lastPlace;
    var _a = this.size,
        w = _a.width,
        h = _a.height;
    var top = 0;
    var left = 0;

    if (/^top/.test(anchor)) {
      top = target.top - h - spacing;
    } else if (/^bottom/.test(anchor)) {
      top = target.bottom + spacing;
    } else if (/^left/.test(anchor)) {
      left = target.left - w - spacing;
    } else if (/^right/.test(anchor)) {
      left = target.right + spacing;
    }

    if (/-left$/.test(anchor)) {
      left = target.right - w;
    } else if (/-right$/.test(anchor)) {
      left = target.left;
    } else if (/-top$/.test(anchor)) {
      top = target.bottom - h;
    } else if (/-bottom$/.test(anchor)) {
      top = target.top;
    }

    if (anchor === 'left' || anchor === 'right') {
      top = target.top + target.height / 2 - h / 2;
    } else if (anchor === 'top' || anchor === 'bottom') {
      left = target.left + target.width / 2 - w / 2;
    }

    this.$el.css({
      top: Math.round(top) + "px",
      left: Math.round(left) + "px"
    });
    return this;
  };

  Tooltip.prototype._updateSize = function () {
    if (this._hidden) {
      this.$el.css('visibility', 'hidden');
      (0, _DOM.default)('body').append(this.$el);
    }

    this._size = {
      width: this.$el.outerWidth(true),
      height: this.$el.outerHeight(true)
    };

    if (this._hidden) {
      this.$el.remove();
      this.$el.css('visibility', '');
    } else {
      this.position();
    }
  };

  Tooltip.prototype._pickPlace = function (target) {
    var pos = position(window);

    var place = this._opts.place.split('-');

    var spacing = this._opts.spacing || 0;
    var verticals = ['top', 'bottom'];

    if (verticals.indexOf(place[0]) !== -1) {
      if (target.top - this.size.height - spacing <= pos.top) {
        place[0] = 'bottom';
      } else if (target.bottom + this.size.height + spacing >= pos.bottom) {
        place[0] = 'top';
      }

      switch (place[1]) {
        case 'left':
          if (target.right - this.size.width <= pos.left) {
            place[1] = 'right';
          }

          break;

        case 'right':
          if (target.left + this.size.width >= pos.right) {
            place[1] = 'left';
          }

          break;

        default:
          if (target.left + target.width / 2 + this.size.width / 2 >= pos.right) {
            place[1] = 'left';
          } else if (target.right - target.width / 2 - this.size.width / 2 <= pos.left) {
            place[1] = 'right';
          }

      }
    } else {
      if (target.left - this.size.width - spacing <= pos.left) {
        place[0] = 'right';
      } else if (target.right + this.size.width + spacing >= pos.right) {
        place[0] = 'left';
      }

      switch (place[1]) {
        case 'top':
          if (target.bottom - this.size.height <= pos.top) {
            place[1] = 'bottom';
          }

          break;

        case 'bottom':
          if (target.top + this.size.height >= pos.bottom) {
            place[1] = 'top';
          }

          break;

        default:
          if (target.top + target.height / 2 + this.size.height / 2 >= pos.bottom) {
            place[1] = 'top';
          } else if (target.bottom - target.height / 2 - this.size.height / 2 <= pos.top) {
            place[1] = 'bottom';
          }

      }
    }

    return place.join('-');
  };

  return Tooltip;
}(_EventDispatcher.default);

var _default = Tooltip;
exports.default = _default;
module.exports = exports.default;