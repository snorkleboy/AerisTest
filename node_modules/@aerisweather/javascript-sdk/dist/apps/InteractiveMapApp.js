"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _ApiRequest = require("../network/api/ApiRequest");

var _InteractiveMap = _interopRequireDefault(require("../maps/interactive/InteractiveMap"));

var _ButtonPanel = _interopRequireDefault(require("./views/ButtonPanel"));

var _InfoPanel = _interopRequireDefault(require("./views/InfoPanel"));

var _TimelinePanel = _interopRequireDefault(require("./views/TimelinePanel"));

var _LegendPanel = _interopRequireDefault(require("./views/LegendPanel"));

var _PlaceSearchPanel = _interopRequireDefault(require("./views/PlaceSearchPanel"));

var _CoordinateBounds = require("../geo/CoordinateBounds");

var _layout = require("../utils/layout");

var _utils = require("./utils");

var _utils2 = require("../utils");

var _DOM = _interopRequireDefault(require("../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * An `InteractiveMapApp` object provides an full-featured weather map application that manages an
 * interactive map and enables runtime interaction of map content using a series of panel
 * view components.
 *
 * @export
 * @class InteractiveMapApp
 * @extends {EventDispatcher}
 */
var InteractiveMapApp =
/** @class */
function (_super) {
  __extends(InteractiveMapApp, _super);
  /**
   * Initializes an interactive map application with the specified DOM target and configuration
   * object.
   *
   * @param {HTMLElement} target
   * @param {InteractiveMapAppOptions} [opts]
   * @memberof InteractiveMapApp
   */


  function InteractiveMapApp(target, opts) {
    var _this = _super.call(this) || this;

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for InteractiveMapApp');
    }

    var vp = (0, _layout.viewportSizeClass)();
    opts = (0, _utils2.extend)({
      map: {
        account: opts.account,
        servers: opts.servers
      },
      panels: {
        layers: {
          title: 'Layers',
          enabled: true,
          toggleable: vp.width === 'compact',
          className: 'app__ui-panel-layers',
          position: {
            pin: 'topright',
            translate: {
              x: -10,
              y: 10
            }
          },
          icon: "\n\t\t\t\t\t\t<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 100 80.5\">\n\t\t\t\t\t\t\t<g>\n\t\t\t\t\t\t\t\t<path d=\"M98.5,51.3l-13.7-7.3L58,58.2c-2.5,1.3-5.2,2-8,2c-2.8,0-5.5-0.7-8-2L15.2,44.1L1.5,51.3C0.6,51.8,0,52.8,0,53.8\n\t\t\t\t\t\t\t\t\ts0.6,2,1.5,2.5l43.5,23c3.2,1.7,6.9,1.7,10.1,0l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5S99.4,51.8,98.5,51.3L98.5,51.3z\"/>\n\t\t\t\t\t\t\t\t<path d=\"M1.5,29.2l43.5,23c1.6,0.8,3.3,1.2,5,1.2c1.7,0,3.5-0.4,5-1.3l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5c0-1-0.6-2-1.5-2.5L55,1.3\n\t\t\t\t\t\t\t\t\tC53.5,0.4,51.7,0,50,0c-1.7,0-3.4,0.4-5,1.3l-43.5,23C0.6,24.7,0,25.7,0,26.7C0,27.8,0.6,28.7,1.5,29.2L1.5,29.2z\"/>\n\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t"
        },
        timeline: {
          enabled: true,
          position: {
            pin: vp.width === 'compact' ? 'bottomleft' : 'bottom',
            translate: {
              x: vp.width === 'compact' ? 10 : 0,
              y: -10
            }
          }
        },
        info: {
          enabled: true,
          position: {
            pin: 'topleft',
            translate: {
              x: 10,
              y: 10
            }
          },
          marker: {
            svg: {
              shape: {
                type: 'circle',
                fill: {
                  color: '#15a8e1'
                },
                stroke: {
                  color: '#ffffff',
                  width: 2
                }
              }
            },
            size: [20, 20]
          }
        },
        legends: {
          title: 'Legends',
          enabled: true,
          toggleable: true,
          position: {
            pin: 'bottomright',
            translate: {
              x: -10,
              y: -10
            }
          },
          icon: "\n\t\t\t\t\t\t<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 90 90\">\n\t\t\t\t\t\t\t<g>\n\t\t\t\t\t\t\t\t<path d=\"M45,9c19.9,0,36,16.1,36,36S64.9,81,45,81S9,64.9,9,45C9,25.1,25.1,9,45,9 M45,0C20.1,0,0,20.1,0,45s20.1,45,45,45\n\t\t\t\t\t\t\t\t\ts45-20.1,45-45C90,20.1,69.9,0,45,0z\"/>\n\t\t\t\t\t\t\t\t<path d=\"M48.7,29.3c0,1-0.4,1.9-1.1,2.7c-0.7,0.7-1.6,1.1-2.6,1.1c-0.5,0-0.9-0.1-1.4-0.3c-0.4-0.2-0.8-0.5-1.2-0.8\n\t\t\t\t\t\t\t\t\tc-0.3-0.3-0.6-0.7-0.8-1.2c-0.2-0.5-0.3-0.9-0.3-1.5c0-0.5,0.1-0.9,0.3-1.3c0.2-0.4,0.5-0.8,0.8-1.2c0.3-0.3,0.7-0.6,1.2-0.8\n\t\t\t\t\t\t\t\t\tc0.4-0.2,0.9-0.3,1.4-0.3s0.9,0.1,1.4,0.3c0.4,0.2,0.8,0.5,1.2,0.8c0.4,0.3,0.6,0.7,0.8,1.1C48.6,28.3,48.7,28.8,48.7,29.3\n\t\t\t\t\t\t\t\t\tL48.7,29.3z M48.3,59.8c0,1.1-0.3,2-0.9,2.6c-0.6,0.7-1.4,1-2.4,1s-1.8-0.3-2.4-1c-0.6-0.7-0.9-1.5-0.9-2.6v-18\n\t\t\t\t\t\t\t\t\tc0-1.1,0.3-2,0.9-2.6c0.6-0.7,1.4-1,2.4-1s1.8,0.3,2.4,1c0.6,0.7,0.9,1.5,0.9,2.6V59.8z\"/>\n\t\t\t\t\t\t\t</g>\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t"
        },
        search: {
          enabled: true,
          account: opts.account,
          position: {
            pin: 'top',
            translate: {
              y: 10
            }
          }
        }
      }
    }, opts);
    _this._opts = opts;
    _this._account = opts.account;

    if (!target) {
      throw new Error('Invalid target for InteractiveMapApp');
    }

    if (!_this.account) {
      throw new Error('An InteractiveMapApp must be configured with a valid `account` value.');
    }

    (0, _DOM.default)(target).html("\n\t\t\t<div class=\"awxjs__app__component awxjs__app__fullscreen\">\n\t\t\t\t<div class=\"awxjs__app__map\"></div>\n\t\t\t</div>\n\t\t");
    _this._target = (0, _DOM.default)('.awxjs__app__component', (0, _DOM.default)(target)); // panel and source cache

    _this._panels = {
      layers: null,
      info: null,
      timeline: null,
      legends: null,
      search: null
    };
    _this._sources = {}; // interface panels

    var _a = opts.panels,
        layersPanel = _a.layers,
        infoPanel = _a.info,
        timelinePanel = _a.timeline,
        searchPanel = _a.search,
        legendsPanel = _a.legends;
    var mapOpts = (0, _utils2.cloneDeep)(opts.map); // update opts.map.layers values by using the layer value associated with the matching
    // layer id from the layers panel buttons

    if (mapOpts && layersPanel) {
      var initialLayers = (0, _utils2.get)(opts, 'map.layers');

      if (initialLayers) {
        if ((0, _utils2.isString)(initialLayers)) {
          initialLayers = initialLayers.replace(/\s/g, '').split(',');
        }

        var buttons = layersPanel.buttons || [];
        var result = buttons.reduce(function (ar, item) {
          if ((0, _utils2.isset)(item.buttons) === false) {
            var value = item.value || item.id; // if button config has segments and is not a filter, iterate through the
            // segments to find a layer value that exists in the initial layers array

            var segments = item.segments;

            if (segments && (0, _utils2.isArray)(segments) && !item.filter) {
              segments.forEach(function (o) {
                var layer = o.value.replace(/\:.+$/, '');
                (0, _utils2.replace)(ar, layer, o.value);
              });
            } else {
              (0, _utils2.replace)(ar, item.value, value);
              (0, _utils2.replace)(ar, item.id, value);
            }
          }

          return ar;
        }, (0, _utils2.cloneDeep)(initialLayers));
        (0, _utils2.set)(opts, 'map.layers', result);
        (0, _utils2.set)(mapOpts, 'layers', null);
      }
    }

    _this._map = new _InteractiveMap.default((0, _DOM.default)('.awxjs__app__map', _this._target), mapOpts); // setup interface panels

    if (layersPanel && layersPanel.enabled !== false) {
      _this._setupLayersPanel(layersPanel);
    }

    if (infoPanel && infoPanel.enabled !== false) {
      _this._setupInfoPanel(infoPanel);
    }

    if (timelinePanel && timelinePanel.enabled !== false) {
      _this._setupTimeline(timelinePanel);
    }

    if (searchPanel && searchPanel.enabled !== false) {
      _this._setupSearchPanel(searchPanel);
    }

    if (legendsPanel && legendsPanel.enabled !== false) {
      _this._setupLegendsPanel(legendsPanel);
    }

    _this._map.on('ready', function () {
      return _this.trigger('ready');
    });

    (0, _DOM.default)(window).on('resize', function () {
      _this._layout();
    });

    _this._layout();

    setTimeout(function () {
      return _this._layout();
    }, 200);
    return _this;
  }

  Object.defineProperty(InteractiveMapApp.prototype, "account", {
    /**
     * The Aeris account to use when requesting data for the map.
     *
     * @readonly
     * @type {Account}
     * @memberof InteractiveMapApp
     */
    get: function () {
      return this._account;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMapApp.prototype, "$el", {
    /**
     * Primary DOM element associated with the view.
     *
     * @readonly
     * @type {*}
     * @memberof MapView
     */
    get: function () {
      return this._target;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMapApp.prototype, "map", {
    /**
     * Returns the underlying interactive map instance.
     *
     * @readonly
     * @type {InteractiveMap}
     * @memberof InteractiveMapApp
     */
    get: function () {
      return this._map;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(InteractiveMapApp.prototype, "panels", {
    /**
     * Returns the panel component instances for the application keyed by their type.
     *
     * @readonly
     * @type {{ layers: ButtonPanel, info: InfoPanel }}
     * @memberof InteractiveMapApp
     */
    get: function () {
      return this._panels;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Adds a map content source to the application cache that can be toggled on and off using the
   * unique key identifier. Note that this method does not render the source to the interactive
   * map.
   *
   * @param {string} key Identifier for the source
   * @param {string} type Type of map content source to use, `tile`, `vector`, `geojson` or `text`
   * @param {*} config Configuration options for the source
   * @returns {*}
   * @memberof InteractiveMapApp
   */

  InteractiveMapApp.prototype.addSource = function (key, type, config) {
    var source = this.map.createSource(key, type, config);
    source.strategy = this.map.strategy;

    if (source) {
      this._sources[key] = source;
    }

    return source;
  };
  /**
   * Shows the application's info panel component using the specified view key, title and data.
   *
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {*} [data] Data to use when rendering the view in the panel (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  InteractiveMapApp.prototype.showInfo = function (view, title, data) {
    var panel = this.panels.info;

    if (panel) {
      panel.showContent(view, title, data);
    }

    return panel;
  };
  /**
   * Shows the application's info panel component for the specified geographical coordinate. Data
   * will be requested for the coordinate using the view's request instance
   *
   * @param {ICoordinate} coord Coordinate to request data for
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {MarkerStyle} [marker] Marker style to use when placing the marker on the map at the
   * coordinate (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  InteractiveMapApp.prototype.showInfoAtCoord = function (coord, view, title, marker) {
    var panel = this.panels.info;

    if (!coord) {
      return panel;
    }

    if (!marker) {
      marker = (0, _utils2.get)(this._opts, 'panels.info.marker');
    }

    var _a = (0, _CoordinateBounds.normalize)(coord),
        lat = _a.lat,
        lon = _a.lon;

    if (panel && (0, _utils2.isset)(lat) && (0, _utils2.isset)(lon)) {
      panel.showContent(view, title).load({
        p: lat + "," + lon
      });

      if (this._infoPanelMarker) {
        this.map.strategy.removeMarker(this._infoPanelMarker);
      }

      if (marker) {
        this._infoPanelMarker = this.map.strategy.factory.marker('info', coord, marker);

        if (this._infoPanelMarker) {
          this.map.strategy.addMarker(this._infoPanelMarker);
        }
      }
    }

    return panel;
  };
  /**
   * Returns the panel view associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMapApp
   */


  InteractiveMapApp.prototype.getPanel = function (key) {
    var panel = this._panels[key];

    if (panel) {
      return panel;
    }

    console.error("[Aeris] Panel not found for key " + key + ".");
    return null;
  };

  InteractiveMapApp.prototype._setupLayersPanel = function (config) {
    var _this = this;

    var panel = new _ButtonPanel.default(config); // TODO: clean this layer/identifier handling up more...

    var updateSources = function (identifier, add, remove, multiselect, filter) {
      if (multiselect === void 0) {
        multiselect = false;
      }

      if (filter === void 0) {
        filter = false;
      }

      var sources = {
        added: [],
        removed: []
      };
      add = add || [];
      remove = remove || [];
      var addIds = add.map(function (config) {
        return config.layer;
      });
      remove = remove.filter(function (identifier) {
        return addIds.indexOf(identifier) === -1;
      });
      remove.forEach(function (layer) {
        var id = multiselect && !filter ? layer : identifier;

        var source = _this.map.getSourceForId(id);

        if (source) {
          _this.map.removeSource(source);
        } else {
          source = _this.map.getSourceForLayer(layer);

          if (!source) {
            source = _this.map.getSourceForId(identifier);
          }

          if (source) {
            _this.map.removeLayerForId(id);
          }
        }

        if (source) sources.removed.push(source);
      });
      add.forEach(function (config) {
        var layer = config.layer;
        var options = config.options;
        var id = multiselect && !filter ? layer : identifier;
        options = options || {};
        var source = _this._sources[layer];

        if (source) {
          _this.map.addSource(source, layer);
        } else {
          source = _this.map.getSourceForId(id);

          if (!source && id === layer) {
            source = _this.map.getSourceForLayer(layer);
          }

          if (!source) {
            options.id = id;

            _this.map.addLayer(layer, options);
          }
        }

        if (source) sources.added.push(source);
      });
      return sources;
    };

    panel.on('select', function (e) {
      var _a = e.data,
          id = _a.id,
          value = _a.value,
          opts = _a.options,
          filter = _a.filter,
          multiselect = _a.multiselect;
      var options = opts;

      if (value && _this.map.isReady()) {
        var identifier = id || value;
        var layer = filter ? identifier : value;
        options = options || {};
        options.id = identifier;
        var sourcesToAdd = !(0, _utils2.isArray)(layer) ? [{
          layer: layer,
          options: options
        }] : layer.map(function (code) {
          return {
            layer: code,
            options: options
          };
        });
        var added = updateSources(identifier, sourcesToAdd, null, multiselect, filter).added;

        _this.trigger('layer:select', {
          id: id,
          layer: layer,
          options: options,
          added: added
        });

        if (filter) {
          var source = _this._sources[identifier];

          _this.trigger('layer:change:option', {
            id: id,
            layer: layer,
            value: value,
            options: options,
            source: source
          });

          if (source) {
            source.reload({
              filter: value
            });
          }
        }
      }
    }).on('deselect', function (e) {
      var _a = e.data,
          id = _a.id,
          value = _a.value,
          filter = _a.filter,
          multiselect = _a.multiselect;

      if (value && _this.map.isReady()) {
        var identifier = id || value;
        var layer = filter ? identifier : value;
        var sourcesToRemove = !(0, _utils2.isArray)(layer) ? [layer] : layer;
        var removed = updateSources(identifier, null, sourcesToRemove, multiselect, filter).removed;

        _this.trigger('layer:deselect', {
          id: id,
          layer: layer,
          removed: removed
        });
      }
    }).on('change', function (e) {
      var _a = e.data,
          id = _a.id,
          value = _a.value,
          previous = _a.previous,
          options = _a.options,
          filter = _a.filter,
          multiselect = _a.multiselect;

      if (_this.map.isReady()) {
        var identifier = id || value;

        if (previous && value) {
          var source = _this.map.getSource(id) || _this._sources[id];

          if (filter) {
            _this.trigger('layer:change:option', {
              id: id,
              layer: id,
              value: value,
              options: options,
              source: source
            });

            if (source) {
              if (source.service) {
                source.service.filter(value);
              }

              source.reload({
                filter: value
              });
            }
          } else {
            // source = this._sources[identifier];
            // const previousSource = this._sources[previous];
            var sourcesToAdd = !(0, _utils2.isArray)(value) ? [{
              layer: value,
              options: options
            }] : value.map(function (code) {
              return {
                layer: code,
                options: options
              };
            });
            var sourcesToRemove = !(0, _utils2.isArray)(previous) ? [previous] : previous;
            updateSources(identifier, sourcesToAdd, sourcesToRemove, multiselect);

            _this.trigger('layer:change', {
              id: id,
              current: value,
              previous: previous,
              options: options
            });
          }
        }
      }
    });
    panel.addTo(this.$el);
    this._panels.layers = panel; // select initial buttons based on map.layers value if defined

    var layers = (0, _utils2.get)(this._opts, 'map.layers');

    if (layers) {
      if ((0, _utils2.isString)(layers)) {
        layers = layers.replace(/\s/g, '').split(',');
      }

      this.map.on('ready', function () {
        panel.select(layers);
      });
    }
  };

  InteractiveMapApp.prototype._setupInfoPanel = function (config) {
    var _this = this;

    var panel = new _InfoPanel.default(config);
    panel.addTo(this.$el);
    this._panels.info = panel;
    panel.on('close', function () {
      if (_this._infoPanelMarker) {
        _this.map.strategy.removeMarker(_this._infoPanelMarker);

        _this._infoPanelMarker = null;
      }
    }); // add default panel content views

    var localWeatherConfig = {
      request: function () {
        var account = _this.account;
        var request = account.api();
        var forecastFields = 'timestamp,dateTimeISO,tempF,icon,weatherPrimary,windSpeedMPH,windSpeedMinMPH,windSpeedMaxMPH,windGustMPH,snowIN,precipIN'.split(',').map(function (key) {
          return "periods." + key;
        });
        request.addRequest(account.api().endpoint('forecasts').fields(forecastFields.join(',')).filter('3hr').limit(7));
        request.addRequest(account.api().endpoint('places'));
        request.addRequest(account.api().endpoint('threats').radius('50mi'));
        request.addRequest(account.api().endpoint('alerts').fields('details.type,details.name,timestamps'));
        request.addRequest(account.api().endpoint('phrases/summary'));
        request.addRequest(account.api().endpoint('observations'));
        request.addRequest(account.api().endpoint('convective/outlook').action(_ApiRequest.ApiAction.CONTAINS));
        request.addRequest(account.api().endpoint('lightning/summary').action(_ApiRequest.ApiAction.CLOSEST).radius('60mi').limit(100));
        return request;
      },
      views: [{
        renderer: 'place'
      }, {
        title: 'Active Threats',
        renderer: 'threats'
      }, {
        title: 'Active Alerts',
        renderer: 'alerts'
      }, {
        title: 'Impacts',
        renderer: 'hazards'
      }, {
        title: 'Observations',
        renderer: 'obs'
      }, {
        title: 'Outlook',
        renderer: 'outlook'
      }, {
        title: 'Short-Term Forecast',
        renderer: 'forecast'
      }]
    };
    this.panels.info.setContentView('localweather', localWeatherConfig);
  };

  InteractiveMapApp.prototype._setupTimeline = function (config) {
    var _this = this;

    var initRange = (0, _utils2.get)(config, 'range.value');
    var initTimelineFrom = (0, _utils2.get)(this._opts, 'map.timeline.from');
    var initTimelineTo = (0, _utils2.get)(this._opts, 'map.timeline.to'); // if the slider's `range.value` is defined and the map.timeline from/to are not, then
    // update the map's initial timeline range to the value of `range.value`

    if (initRange && !(0, _utils2.isset)(initTimelineFrom) && !(0, _utils2.isset)(initTimelineTo)) {
      var from = initRange[0],
          to = initRange[1];

      if ((0, _utils2.isNumber)(from)) {
        this.map.timeline.setStartOffset(from * 3600 * 1000);
      }

      if ((0, _utils2.isNumber)(to)) {
        this.map.timeline.setEndOffset(to * 3600 * 1000);
      }
    } else {
      // update initial slider `range.value` based on underlying map's timeline range
      (0, _utils2.set)(config, 'range.value', [this.map.timeline.startOffset() / 3600 / 1000, this.map.timeline.endOffset() / 3600 / 1000]);
    }

    var panel = new _TimelinePanel.default(this.map.timeline, config);
    panel.on('change:range', function () {
      var time = _this.map.timeline.currentTime;

      _this.map.timeline.goToTime(time);
    });
    panel.addTo(this.$el);
    this._panels.timeline = panel;
  };

  InteractiveMapApp.prototype._setupSearchPanel = function (config) {
    var _this = this;

    var panel = new _PlaceSearchPanel.default(config);
    panel.addTo(this.$el);
    this._panels.search = panel;
    panel.on('select', function (e) {
      var loc = (0, _utils2.get)(e.data, 'result.loc');

      if (loc) {
        var lat = loc.lat,
            lon = loc.long;
        var coord = {
          lat: lat,
          lon: lon
        };

        _this.map.setView(coord, 8);

        _this.showInfoAtCoord(coord, 'localweather', 'Local Weather');
      }
    });
  };

  InteractiveMapApp.prototype._setupLegendsPanel = function (config) {
    var _this = this;

    var panel = new _LegendPanel.default(config);
    panel.addTo(this.$el);
    this._panels.legends = panel;
    this.map.on('layer:add', function (e) {
      if (!(0, _utils2.isset)(e.data)) return;
      var _a = e.data,
          layer = _a.layer,
          id = _a.id;
      var keys = layer || id;

      if (keys) {
        var layers = keys.replace(/\:[^,]+/g, '').split(',');
        layers.forEach(function (layer) {
          panel.legend.add(layer, {
            account: _this.account
          });

          if (layer === 'alerts') {
            setTimeout(function () {
              panel.legend.update({
                account: _this.account,
                within: {
                  bounds: _this.map.getBounds()
                }
              });
            }, 500);
          }
        });
      }
    }).on('layer:remove source:remove', function (e) {
      if (!(0, _utils2.isset)(e.data)) return;
      var _a = e.data,
          layer = _a.layer,
          id = _a.id;
      var keys = layer || id;

      if (keys) {
        var layers = keys.replace(/\:[^,]+/g, '').split(',');
        layers.forEach(function (layer) {
          panel.legend.remove(layer);
        });
      }
    }).on('change:bounds', function (e) {
      var opts = {
        account: _this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      opts.within = {
        bounds: _this.map.getBounds()
      };
      panel.legend.update(opts);
    });
  };

  InteractiveMapApp.prototype._layout = function () {
    var _this = this;

    Object.keys(this._panels).forEach(function (key) {
      var panel = _this._panels[key];

      if (panel) {
        var pos = (0, _utils2.get)(_this._opts, "panels." + key + ".position");

        if (pos && (0, _utils2.isPlainObject)(pos)) {
          if (pos.pin) {
            panel.pinTo(pos.pin, pos.translate);
          } else if ((0, _utils2.isset)(pos.x) && (0, _utils2.isset)(pos.y)) {
            panel.moveTo(pos);
          }
        }
      }
    });
    Object.keys(this._panels).forEach(function (key) {
      var panel = _this._panels[key];

      if (panel) {
        // set max-height on layers panel
        if (key === 'layers') {
          var size = panel.contentSize();

          var parent_1 = _this.$el.bounds(true);

          var bounds = panel.$el.bounds(true, _this.$el);
          var margin = bounds.top;
          var maxh = parent_1.height; // ensure layers panel doesn't overlap legend button if in bottom-right

          var legendsPanel = _this.getPanel('legends');

          var timelinePanel = _this.getPanel('timeline');

          if (legendsPanel) {
            var b = legendsPanel.$el.bounds(true, _this.$el);

            if (b.left >= bounds.left) {
              maxh = b.top;
            }
          }

          if (timelinePanel) {
            var b = timelinePanel.$el.bounds(true, _this.$el);

            if (b.right >= bounds.left) {
              maxh = b.top;
            }
          }

          maxh -= margin * 2;
          panel.$el.css({
            'height': maxh + "px",
            'overflow-y': 'auto',
            'width': size.width + (0, _utils.scrollBarWidth)() + "px"
          });
        }
      }
    });
  };

  return InteractiveMapApp;
}(_EventDispatcher.default);

var _default = InteractiveMapApp;
exports.default = _default;
module.exports = exports.default;