"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dateFns = require("date-fns");

var _View = _interopRequireDefault(require("../ui/View"));

var _Slider = _interopRequireDefault(require("../ui/Slider"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var TimeSlider =
/** @class */
function (_super) {
  __extends(TimeSlider, _super);

  function TimeSlider(animation, opts) {
    var _this = this;

    opts = (0, _utils.extend)({
      className: (0, _utils.get)(opts, 'className') ? "ui-timeline " + opts.className : 'ui-timeline',
      ui: {
        periods: '.awxjs__ui-timeline__periods'
      }
    }, opts);
    _this = _super.call(this, opts) || this;
    _this._slider = new _Slider.default(opts.slider);
    _this._animation = animation;
    return _this;
  }

  Object.defineProperty(TimeSlider.prototype, "slider", {
    get: function () {
      return this._slider;
    },
    enumerable: true,
    configurable: true
  });

  TimeSlider.prototype.setPosition = function (value, fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    this._slider.setPosition(value, fireEvents);
  };

  TimeSlider.prototype.setProgress = function (value, fireEvents) {
    if (fireEvents === void 0) {
      fireEvents = true;
    }

    this._slider.setProgress(value, fireEvents);
  };

  TimeSlider.prototype._render = function () {
    return "<div class=\"awxjs__ui-timeline__periods\"></div>";
  };

  TimeSlider.prototype._layout = function () {
    var from = this._animation.startDate();

    var to = this._animation.endDate();

    this._layoutPeriods(from, to);

    this._setupSliderTicks(from, to);
  };

  TimeSlider.prototype._onAddedToDOM = function () {
    this._slider.addTo(this.$el);

    if (this._animation) {
      this._handleDateRangeChange(this._animation.startDate(), this._animation.endDate());

      this._updateForTime(this._animation.currentTime);
    }
  };

  TimeSlider.prototype._setupEvents = function () {
    var _this = this;

    var anim = this._animation;
    var slider = this._slider;

    if (anim) {
      anim.on('start:change end:change', function (e) {
        var _a = e.data,
            from = _a.from,
            to = _a.to;

        if (from && to) {
          _this._handleDateRangeChange(from, to); // this._updateForTime(anim.currentTime);

        }
      }).on('advance', function (e) {
        _this._updateForTime(anim.currentTime);
      });
    }

    if (slider) {
      if (!this._sliderChangeHandler) {
        this._sliderChangeHandler = (0, _utils.debounce)(function (e) {
          var delta = anim.endDate().getTime() - anim.startDate().getTime();
          var time = Math.round(anim.startDate().getTime() + delta * e.data.progress);
          anim.stop();
          anim.goToTime(time);
        }, 250);
      } // update animation position when slider drag occurs


      slider.on('change', function (e) {
        anim.pause();

        _this._sliderChangeHandler(e);
      });
    }
  };

  TimeSlider.prototype._updateForTime = function (time) {
    var anim = this._animation;

    if (anim) {
      // update slider position during animation playback
      var delta = anim.endDate().getTime() - anim.startDate().getTime();
      var progress = anim.currentOffset / delta;
      this.setProgress(progress, false);
    }
  };

  TimeSlider.prototype._handleDateRangeChange = function (from, to) {
    this._layout();

    this._slider.setDateRange(from, to);
  };

  TimeSlider.prototype._layoutPeriods = function (from, to) {
    var range = to.getTime() - from.getTime();
    var $periods = this.ui.periods;
    var maxWidth = $periods.width();
    var x = 0;

    if (this._slider) {
      var size = this._slider.indicatorSize();

      maxWidth -= size.width;
      x = size.width / 2;
    }

    $periods.empty();

    if (from.getDate() !== to.getDate()) {
      var tw = 0;
      var time = (0, _dateFns.startOfDay)(from).getTime(); // get start date ignoring time

      var totalWidth = 0;

      while (time < to.getTime()) {
        var date = new Date(time); // calculate the total width of this period as a percentage of the total time range

        var w = 1;

        if (date.getDate() === from.getDate()) {
          var d = (0, _dateFns.startOfDay)((0, _dateFns.addDays)(date, 1));
          w = (d.getTime() - from.getTime()) / range;
        } else if (date.getDate() === to.getDate()) {
          w = 1 - tw;
        } else {
          var d1 = (0, _dateFns.startOfDay)(date);
          var d2 = (0, _dateFns.addDays)(date, 1);
          w = (d2.getTime() - d1.getTime()) / range;
        }

        w = Math.min(1, Math.max(w, 0));
        var dateFormat = w * maxWidth < 100 ? 'ddd' : 'ddd MMM D';
        var itemLabel = (0, _dateFns.format)(date, dateFormat);
        var itemWidth = Math.round(w * 100 * 100) / 100; // make sure itemWidth percentage never forces totalWidth over 100%
        // itemWidth = Math.min(itemWidth, (100 - totalWidth));

        itemWidth = Math.min(w * maxWidth, maxWidth);
        $periods.append("<div class=\"awxjs__ui-timeline__periods-item\" style=\"left:" + x + "px;width:" + itemWidth + "px;\"><span>" + itemLabel + "</span></div>");
        time += 86400 * 1000;
        tw += w;
        x += itemWidth;
        totalWidth += itemWidth;
      }
    } else {
      var itemLabel = (0, _dateFns.format)(to, 'ddd MMM D');
      $periods.append("<div class=\"awxjs__ui-timeline__periods-item\" style=\"left:" + x + "px;width:" + maxWidth + "px;\"><span>" + itemLabel + "</span></div>");
    } // if (this._slider) {
    // 	this._slider.updateRanges(from, to);
    // }

  };

  TimeSlider.prototype._setupSliderTicks = function (from, to) {
    var range = to.getTime() - from.getTime();
    var intervals = {
      second: 1000,
      minute: 60000,
      hour: 3600000,
      day: 86400000
    };
    intervals.minute5 = intervals.minute * 5;
    intervals.minute10 = intervals.minute * 10;
    intervals.minute15 = intervals.minute * 15;
    intervals.minute30 = intervals.minute * 30;
    intervals.hour2 = intervals.hour * 2;
    intervals.hour3 = intervals.hour * 3;
    intervals.hour6 = intervals.hour * 6;
    intervals.hour12 = intervals.hour * 12;
    intervals.month = intervals.day * 30;
    intervals.year = intervals.day * 365;
    intervals.decade = intervals.year * 10;
    var maxWidth = this.ui.periods.width();

    if (this._slider) {
      var size = this._slider.indicatorSize();

      maxWidth -= size.width;
    }

    var timeUnitForRange = function (timeRange) {
      var result = 0;
      var units = Object.keys(intervals).map(function (key) {
        return intervals[key];
      });
      units.sort(function (a, b) {
        return a - b;
      }).forEach(function (interval) {
        var total = timeRange / interval;
        var spacing = maxWidth / total; // console.log(interval, spacing);

        if (spacing >= 50 && result === 0) {
          result = interval;
        }
      });
      return result;
    };

    if (this._slider) {
      var fromTime = from.getTime();
      var toTime = to.getTime();
      var timeDelta = toTime - fromTime; // let tickInterval = 15 * 60 * 1000;

      var tickInterval = timeUnitForRange(timeDelta); // console.log('using interval', tickInterval);
      // let tickSpacing = maxWidth / (timeDelta / tickInterval);
      // // determine if the configured tick interval will allow proper spacing
      // // if not, then increase the interval until we find a good fit
      // if (tickSpacing < 50) {
      // 	const factor = Math.ceil(50 / tickSpacing);
      // 	tickInterval *= factor;
      // 	tickSpacing = maxWidth / (timeDelta / tickInterval);
      // }

      var tickValue = Math.floor(fromTime);

      if (tickValue % tickInterval !== 0) {
        tickValue += tickInterval - tickValue % tickInterval;
      }

      var ticks = {};

      while (tickValue <= toTime) {
        var delta = (tickValue - fromTime) / range;
        ticks[delta] = (0, _dateFns.format)(new Date(tickValue), 'h:mm');
        tickValue += tickInterval;
      } // console.log('ticks', ticks, range, maxWidth);


      this._slider.setTicks(ticks);
    }
  };

  return TimeSlider;
}(_View.default);

var _default = TimeSlider;
exports.default = _default;
module.exports = exports.default;