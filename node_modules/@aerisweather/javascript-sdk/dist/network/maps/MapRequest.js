"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.MapRequestType = void 0;

var _dateFns = require("date-fns");

var _Http = _interopRequireDefault(require("../Http"));

var _MapResult = _interopRequireDefault(require("./MapResult"));

var _Layer = _interopRequireDefault(require("./Layer"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function () {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];

      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;

        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };

        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;

        case 7:
          op = _.ops.pop();

          _.trys.pop();

          continue;

        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }

          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }

          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }

          if (t && _.label < t[2]) {
            _.label = t[2];

            _.ops.push(op);

            break;
          }

          if (t[2]) _.ops.pop();

          _.trys.pop();

          continue;
      }

      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var toArray = function (str) {
  return (str || '').replace(/\s/, '').split(',');
};

var toCodeArray = function (value) {
  if ((0, _utils.isEmpty)(value)) {
    return [];
  }

  if (!(0, _utils.isArray)(value)) {
    return toArray(value);
  }

  var result = value.map(function (v) {
    if (v instanceof _Layer.default) {
      return v.toString();
    }

    return v;
  });
  return result;
};

var normalize = function (params) {
  Object.keys(params).forEach(function (key) {
    var val = params[key];

    if (key === 'layers') {
      if ((0, _utils.isPlainObject)(val)) {
        Object.keys(val).forEach(function (k) {
          val[k] = toCodeArray(val[k]);
        });
      } else {
        params[key] = toCodeArray(val);
      }
    } else if (key === 'p') {
      if ((0, _utils.isObject)(params[key])) {
        var _a = params[key],
            lat = _a.lat,
            lon = _a.lon;

        if (lat && lon) {
          params[key] = lat + "," + lon;
        }
      }
    }
  });
  return params;
};
/**
 * An enumerated value representing the type of map request.
 */


var MapRequestType;
exports.MapRequestType = MapRequestType;

(function (MapRequestType) {
  MapRequestType["IMAGE"] = "image";
  MapRequestType["TILE"] = "tile";
})(MapRequestType || (exports.MapRequestType = MapRequestType = {}));
/**
 * An object that is responsible for configuring and performing a single request to the Aeris Weather API.
 *
 * @export
 * @class MapRequest
 * @implements {IRequest}
 */


var MapRequest =
/** @class */
function () {
  /**
   * Initializes a new request instance configured with the specified client access keys.
   *
   * @param config
   */
  function MapRequest(config, opts) {
    /**
     * Base configuration for the request.
     *
     * @type {ApiConfig}
     * @memberof MapRequest
     */
    this.config = {
      server: 'https://maps.aerisapi.com',
      client: {
        id: undefined,
        secret: undefined
      }
    };
    /**
     * Parameters associated with the request.
     *
     * @private
     * @type {IMapOptions}
     * @memberof MapRequest
     */

    this._params = {
      type: MapRequestType.IMAGE,
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      p: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: undefined,
        height: undefined
      },
      offset: '0',
      metric: false,
      format: 'png'
    };
    this._paramKeys = ['type', 'layers', 'layers.base', 'layers.data', 'layers.overlays', 'layers.text', 'p', 'center', 'zoom', 'bounds', 'size', 'size.width', 'size.height', 'offset', 'metric'];
    this.config = (0, _utils.merge)(this.config, config);
    this._http = new _Http.default(this.config.server, {
      'Content-Type': null
    });

    if (opts) {
      this.setParams(opts);
    }
  }
  /**
   * Sets or returns the specified parameter.
   *
   * @param key
   * @param value
   */


  MapRequest.prototype.param = function (key, value) {
    if (value) {
      if (this._paramKeys.indexOf(key) !== -1) {
        (0, _utils.set)(this._params, key, value);

        if (/^layers/.test(key)) {
          this._params = normalize(this._params);
        }
      }

      return this;
    }

    return (0, _utils.get)(this._params, key);
  };
  /**
   * Sets multiple request parameters.
   *
   * @param params
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.setParams = function (params) {
    this._params = normalize((0, _utils.merge)(this._params, params));
    return this;
  };
  /**
   * Sets the type of map image to request, either `image` (default) or `tile`.
   *
   * @param {MapRequestType} type
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.type = function (type) {
    this.param('type', type);
    return this;
  };
  /**
   * Sets the base layers, which will be rendered at the bottom of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.base = function (value) {
    this.param('layers.base', toCodeArray(value));
    return this;
  };
  /**
   * Sets the weather data layers, which will be rendered above the base layers but below overlays and text.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.data = function (value) {
    this.param('layers.data', toCodeArray(value));
    return this;
  };
  /**
   * Sets the overlay layers, which will be rendered above weather data layers but below text layers.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.overlays = function (value) {
    this.param('layers.overlays', toCodeArray(value));
    return this;
  };
  /**
   * Sets the text layers, which will be rendered at the top of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.text = function (value) {
    this.param('layers.text', toCodeArray(value));
    return this;
  };
  /**
   * Sets all layers, which will be rendered in the order in which they are provided by `value`.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.layers = function (value) {
    this.param('layers', toCodeArray(value));
    return this;
  };
  /**
   * Sets the location the map will be centered on.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.place = function (value) {
    this.param('p', value);
    return this;
  };
  /**
   * Sets the center for the map request. The center can be a place name or a geographical
   * coordinate value.
   *
   * @param {(string | ICoordinate)} [value]
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.center = function (value) {
    if ((0, _utils.isObject)(value)) {
      var _a = value,
          lat = _a.lat,
          lon = _a.lon;

      if (lat && lon) {
        value = lat + "," + lon;
      }
    }

    this.param('p', value);
    return this;
  };
  /**
   * Sets the zoom level.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.zoom = function (value) {
    this.param('zoom', value);
    return this;
  };
  /**
   * Sets the bounding box coordinates for the rendered map region.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.bounds = function (value) {
    this.param('bounds', value);
    return this;
  };
  /**
   * Sets the map width and height.
   *
   * @param w
   * @param h
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.size = function (w, h) {
    this.param('size', {
      width: w,
      height: h
    });
    return this;
  };
  /**
   * Sets the time offset value.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.offset = function (value) {
    this.param('offset', "" + value);
    return this;
  };
  /**
   * Sets the time offset value using the specified date.
   *
   * @param {Date} value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.date = function (value) {
    // eliminate seconds and milliseconds from date
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // time string must be in GMT

    var date = new Date(value.getTime() + value.getTimezoneOffset() * 60 * 1000);
    return this.offset((0, _dateFns.format)(date, 'YYYYMMDDHHmm00'));
  };
  /**
   * Sets whether text data should be rendered as Metric units.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.metric = function (value) {
    if (value) {
      this.param('metric', value);
      return this;
    }

    return this.param('metric');
  };
  /**
   * Perform the request.
   */


  MapRequest.prototype.get = function (callback) {
    return __awaiter(this, void 0, void 0, function () {
      var url, result_1, res, image, error, json, result, e_1;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 5,, 6]);

            url = this.url();

            if (!url) {
              result_1 = new _MapResult.default(null, null, new Error('Invalid map url'), this._params);

              if (callback) {
                callback(result_1);
              }

              return [2
              /*return*/
              , result_1];
            }

            return [4
            /*yield*/
            , this._http.get(url)];

          case 1:
            res = _a.sent();
            image = void 0;
            error = void 0;
            if (!(res.status >= 400)) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , res.data];

          case 2:
            json = _a.sent();
            error = json.error;

            if (error && (error.code === 'warn_no_data' || error.code === 'warn_invalid_param' || error.code === 'invalid_location')) {
              error = null;
            }

            return [3
            /*break*/
            , 4];

          case 3:
            image = new Image();
            image.src = url.indexOf(this.config.server) >= 0 ? url : this.config.server + "/" + url;
            _a.label = 4;

          case 4:
            result = new _MapResult.default(res, image, error, this._params);

            if (callback) {
              callback(result);
            }

            return [2
            /*return*/
            , result];

          case 5:
            e_1 = _a.sent();
            console.error('MapRequest Error', e_1);
            return [3
            /*break*/
            , 6];

          case 6:
            return [2
            /*return*/
            , null];
        }
      });
    });
  };
  /**
   * Returns the url string for the request based on the configured parameters and options.
   *
   * @param {string[]} [groups=[]]
   * @returns {string}
   * @memberof MapRequest
   */


  MapRequest.prototype.url = function (groups) {
    if (groups === void 0) {
      groups = [];
    }

    var url = this.config.server;
    var params = (0, _utils.merge)({}, (0, _utils.pickBy)(this._params, function (o) {
      return !(0, _utils.isEmpty)(o);
    }), {
      layers: []
    });

    if ((0, _utils.isString)(params.p)) {
      params.p = params.p.replace(/\+/, '%20');
    }

    var layers = this._params.layers;

    if ((0, _utils.isPlainObject)(layers)) {
      var layerGroups_1 = layers;
      groups = !(0, _utils.isEmpty)(groups) ? groups : Object.keys(layerGroups_1); // console.log(groups, layers);

      if (!(0, _utils.isEmpty)(groups)) {
        groups.forEach(function (group) {
          var glayers = layerGroups_1[group];

          if (!(0, _utils.isEmpty)(glayers)) {
            if (!(0, _utils.isArray)(glayers)) {
              glayers = toArray(glayers);
            }

            params.layers = params.layers.concat(glayers);
          }
        });
      }
    } else if ((0, _utils.isArray)(layers)) {
      params.layers = layers;
    }

    if ((0, _utils.isEmpty)(params.layers)) {
      if (groups.length > 1) {
        console.warn("No map layers specified - layers: " + params.layers + "; groups: " + groups.join(','));
      }

      return undefined;
    }

    if (params.type === MapRequestType.TILE) {
      url += "/" + this.config.client.id + "_" + this.config.client.secret + "/" + params.layers + "/{z}/{x}/{y}/" + params.offset + "." + params.format;
    } else {
      // exit if no valid location or bounds defined
      if (((0, _utils.isEmpty)(params.p) || params.p === ':auto') && (0, _utils.isEmpty)(params.bounds)) {
        console.warn("No valid location or bounds provided for the map - p: " + params.p + "; bounds: " + params.bounds);
        return undefined;
      }

      var b = params.bounds;
      params.loc = !(0, _utils.isEmpty)(b) ? b.south + "," + b.west + "," + b.north + "," + b.east : params.p + "," + params.zoom;
      url += "/" + this.config.client.id + "_" + this.config.client.secret + "/" + params.layers + "/" + params.size.width + "x" + params.size.height + "/" + params.loc + "/" + params.offset + "." + params.format;
    }

    return url;
  };
  /**
   * Returns a copy of the request.
   *
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  MapRequest.prototype.clone = function () {
    var request = new MapRequest(this.config);
    request.setParams(this._params);
    return request;
  };

  return MapRequest;
}();

var _default = MapRequest;
exports.default = _default;