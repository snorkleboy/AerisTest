"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVG = void 0;

var _utils = require("../utils");

/**
 * @private
 */
var getPosition = function (pos, size, container, translate) {
  var x = 0;
  var y = 0;
  translate = (0, _utils.extend)({
    x: 0,
    y: 0
  }, translate);

  if ((0, _utils.isString)(pos)) {
    var anchor = pos;
    x = (container.width - size.width) / 2;
    y = (container.height - size.height) / 2;

    if (/^top/.test(anchor)) {
      y = 0;
    } else if (/^bottom/.test(anchor)) {
      y = container.height - size.height;
    }

    if (/left$/.test(anchor)) {
      x = 0;
    } else if (/right$/.test(anchor)) {
      x = container.width - size.width;
    }
  } else {
    var p = pos;
    x = p.x;
    y = p.y;
  }

  x += translate.x;
  y += translate.y;
  return {
    x: x,
    y: y
  };
};
/**
 * @private
 */


var getStyleAttributes = function (opts) {
  var strokeOpts = opts.stroke ? Object.keys(opts.stroke).reduce(function (value, key) {
    var val = opts.stroke[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'width') value += " stroke-width=\"" + val + "\"";
      if (key === 'color') value += " stroke=\"" + val + "\"";
      if (key === 'opacity') value += " stroke-opacity=\"" + val + "\"";
    }

    return value;
  }, '') : '';
  var fillOpts = opts.fill ? Object.keys(opts.fill).reduce(function (value, key) {
    var val = opts.fill[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'color') value += " fill=\"" + val + "\"";
      if (key === 'opacity') value += " fill-opacity=\"" + val + "\"";
    }

    return value;
  }, '') : '';
  return fillOpts || strokeOpts ? "" + fillOpts + strokeOpts : '';
};
/**
 * The `SVG` module provides utility functions for generating the necessary HTML for various SVG
 * elements based on certain configurations and styles.
 */


var SVG;
exports.SVG = SVG;

(function (SVG) {
  SVG.calculateTextSize = function (str, fontSize, fontStyle, padding) {
    var width = 0;
    var height = 0;
    padding = padding || [0, 0];
    fontSize = fontSize || 12; // calculate bounding box of actual text if we have a document object

    if (window && window.document) {
      var doc = window.document;
      var el = doc.createElement('text');
      el.style.fontSize = (0, _utils.isString)(fontSize) ? "" + fontSize : fontSize + "px";
      el.style.fontWeight = fontStyle || 'normal';
      el.style.visibility = 'hidden';
      el.innerHTML = str;
      doc.body.appendChild(el);
      var bbox = el.getBoundingClientRect();
      doc.body.removeChild(el);

      if (bbox.width > 0) {
        width = bbox.width;
      }

      if (bbox.height > 0) {
        height = bbox.height;
      }
    } // adjust size by text padding amounts


    var ph = padding[0],
        pv = padding[1];
    width += ph * 2;
    height += pv * 2;
    return [width, height];
  };
  /**
   * Returns the SVG path string using the specified path value string and style options.
   *
   * @param {string} value
   * @param {SVGPathOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.path = function (value, opts) {
    opts = (0, _utils.extend)({
      stroke: {
        opacity: 1
      },
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    var attr = getStyleAttributes(opts);
    return "<g" + (opts.transform ? " transform=\"" + opts.transform + "\"" : "") + "><path d=\"" + value + "\"" + attr + " /></g>";
  };
  /**
   * Returns the SVG rectangle string for the specified width, height and style options.
   *
   * @param {number} width
   * @param {number} height
   * @param {SVGRectOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.rect = function (width, height, opts) {
    opts = (0, _utils.extend)({
      margin: 0,
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    var margin = opts.margin,
        radius = opts.radius;
    var offset = margin;

    if (opts.stroke && opts.stroke.width > 0) {
      offset += opts.stroke.width / 2;
      width -= opts.stroke.width;
      height -= opts.stroke.width;
    }

    var p = "M" + (offset + radius) + "," + offset + " ";
    p += "L" + (offset + width - radius) + "," + offset + " ";
    if (radius > 0) p += "A" + radius + "," + radius + " 0 0,1 " + (offset + width) + "," + (offset + radius) + " ";
    p += "L" + (offset + width) + "," + (offset + height - radius) + " ";
    if (radius > 0) p += "A" + radius + "," + radius + " 0 0,1 " + (offset + width - radius) + "," + (offset + height) + " ";
    p += "L" + (offset + radius) + "," + (offset + height) + " ";
    if (radius > 0) p += "A" + radius + "," + radius + " 0 0,1 " + offset + "," + (offset + height - radius) + " ";
    p += "L" + offset + "," + (offset + radius) + " ";
    if (radius > 0) p += "A" + radius + "," + radius + " 0 0,1 " + (offset + radius) + "," + offset + " ";
    p += 'Z';
    return SVG.path(p, opts);
  };
  /**
   * Returns the SVG circle string for the specified style options.
   *
   * @param {SVGCircleOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.circle = function (container, opts) {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    var radius = opts.radius || 8;
    var size = (radius + ((0, _utils.get)(opts, 'stroke.width') || 0) + 1) * 2;
    var pos = getPosition(opts.position, {
      width: size,
      height: size
    }, container, opts.translate);
    var attr = getStyleAttributes(opts); // shift position values to the center

    pos.x += size / 2;
    pos.y += size / 2;
    return "<circle" + (opts.transform ? " transform=\"" + opts.transform + "\"" : "") + " cx=\"" + pos.x + "\" cy=\"" + pos.y + "\" r=\"" + opts.radius + "\"" + attr + " />";
  };
  /**
   * Returns the SVG text string for the specified value and style options.
   *
   * @param {string | number} value
   * @param {SVGTextOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.text = function (value, container, opts) {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      anchor: 'start',
      size: 12,
      font: "'Helvetica','Arial',sans-serif",
      style: 'bold',
      color: '#222222'
    }, opts);
    value = value || opts.value;

    var _a = SVG.calculateTextSize("" + value, opts.size, opts.style, opts.padding),
        w = _a[0],
        h = _a[1]; // svg text is positioned relative to the baseline, so add the height to the vertical translate value
    // opts.translate.x += 1;


    opts.translate.y += h - 1;
    var pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    return "<text" + (opts.transform ? " transform=\"" + opts.transform + "\"" : "") + " dominent-baseline=\"hanging\" text-anchor=\"" + opts.anchor + "\" x=\"" + pos.x + "\" y=\"" + pos.y + "\" style=\"font-family:" + opts.font + ";font-size:" + opts.size + "px;font-weight:" + opts.style + ";\" fill=\"" + opts.color + "\">" + (value || '') + "</text>"; // eslint-disable-line max-len
  };

  SVG.image = function (url, container, opts) {
    opts = (0, _utils.extend)({
      position: 'center',
      size: [30, 30]
    }, opts);
    url = url || opts.url;
    var _a = opts.size,
        w = _a[0],
        h = _a[1];
    var pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    var _b = opts.size,
        width = _b[0],
        height = _b[1];
    return "<image" + (opts.transform ? " transform=\"" + opts.transform + "\"" : "") + " x=\"" + pos.x + "\" y=\"" + pos.y + "\" width=\"" + width + "\" height=\"" + height + "\" xlink:href=\"" + url + "\" />";
  };
  /**
   * Returns the SVG HTML string for the specified options and array of drawable elements.
   *
   * @param {number} width
   * @param {number} height
   * @param {string[]} elements
   * @param {string} [viewBox]
   * @returns {string}
   * @memberof SVG
   */


  SVG.svg = function (width, height, elements, viewBox) {
    if (viewBox === void 0) {
      viewBox = null;
    }

    return (// eslint-disable-line max-len
      "<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" width=\"" + width + "\" height=\"" + height + "\"" + (viewBox ? " viewBox=\"" + viewBox + "\"" : '') + ">\n\t\t\t" + (elements || []).map(function (el) {
        return el;
      }).join('') + "\n\t\t</svg>"
    );
  };
  /**
   * Returns the SVG HTML string using the specified size and options.
   *
   * @param {number} width
   * @param {number} height
   * @param {any} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.draw = function (width, height, opts) {
    var value = opts.value;
    var allow = true;
    var requiresText = false;
    var shapeOpts = opts.shape,
        textOpts = opts.text,
        imageOpts = opts.image;
    var elements = []; // setup text element first if defined so we can adjust shape sizing as needed

    var textElements = [];

    if (textOpts) {
      var generateTextEl_1 = function (textValue, config) {
        var val = textValue || config.value || '';
        var x = config.x || 0;
        var y = config.y || 0;
        var size = config.size || 12;

        var _a = SVG.calculateTextSize(val, size, config.style, config.padding),
            w = _a[0],
            h = _a[1];

        var autoSize = (0, _utils.isset)(config.autosize) ? config.autosize : true; // don't allow this element if the text value is empty

        if ((0, _utils.isEmpty)(val)) return null;

        if (autoSize) {
          // update width and height if we have text to display
          if (w && h) {
            width = w;
            height = h;
          } else {
            width = 5 * val.length;
            height = size + 2;
          }
        }

        var offset = 0;

        if (shapeOpts && shapeOpts.stroke) {
          offset = shapeOpts.stroke.width / 2 || 0;
        }

        var element = SVG.text(val, {
          width: width,
          height: height
        }, (0, _utils.extend)(config, {
          x: offset + width / 2 + x,
          y: offset + Math.round(height - (height - size * 0.7) / 2) + y
        }));
        return element;
      };

      if ((0, _utils.isArray)(textOpts)) {
        textOpts.forEach(function (config) {
          var el = generateTextEl_1(value, config);
          if (el) textElements.push(el);
        });
      } else {
        var el = generateTextEl_1(value, textOpts);
        if (el) textElements.push(el);
      }

      if (textElements.length > 0) {
        requiresText = true;
      }
    }

    if (shapeOpts) {
      var w = width;
      var h = height;
      var type = shapeOpts.type,
          size = shapeOpts.size;

      if (size && size.length === 2) {
        w = size[0];
        h = size[1];
      }

      if (type === 'rect') {
        var shape = SVG.rect(w, h, shapeOpts);
        elements.push(shape);
      } else if (type === 'path') {
        var shape = SVG.path((0, _utils.get)(shapeOpts, 'path'), shapeOpts);
        elements.push(shape);
      } else {
        var strokeWidth = (0, _utils.get)(shapeOpts, 'stroke.width') || 0;
        shapeOpts.radius = Math.floor((w - strokeWidth * 2) / 2);
        shapeOpts.center = {
          x: Math.round(w / 2) + 1,
          y: Math.round(h / 2) + 1
        };
        var shape = SVG.circle({
          width: width,
          height: height
        }, shapeOpts);
        elements.push(shape);
      }
    }

    if (imageOpts) {
      var url = imageOpts.url;

      if (url) {
        var x = imageOpts.x || 0;
        var y = imageOpts.y || 0;
        var center = {
          x: width / 2,
          y: height / 2
        };

        var _a = imageOpts.size || [30, 30],
            w = _a[0],
            h = _a[1];

        var imageEl = SVG.image(url, {
          width: width,
          height: height
        }, (0, _utils.extend)(imageOpts, {
          x: center.x - w / 2 + x,
          y: center.y - h / 2 + y
        }));
        elements.push(imageEl);
      }
    }

    if (textElements.length > 0) {
      elements = elements.concat(textElements);
    } else if (requiresText) {
      allow = false;
    }

    return allow ? SVG.svg(width, height, elements, opts.viewBox) : null;
  };
})(SVG || (exports.SVG = SVG = {}));